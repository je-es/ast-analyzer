{"version":3,"sources":["../lib/ast-analyzer.ts","../lib/components/DiagnosticManager.ts","../lib/components/ContextTracker.ts","../lib/components/DebugManager.ts","../lib/components/ScopeManager.ts","../lib/components/IdGenerator.ts","../lib/phases/SymbolCollector.ts","../lib/utils/PathUtils.ts","../lib/interfaces/PhaseBase.ts","../lib/phases/SymbolResolver.ts","../lib/phases/TypeValidator.ts","../lib/components/ExpressionEvaluator.ts","../lib/phases/SemanticValidator.ts"],"sourcesContent":["// Analyzer.ts — A library for analyzing and validating Abstract Syntax Trees.\r\n//\r\n// Developed with ❤️ by Maysara.\r\n\r\n\r\n\r\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\r\n\r\n    import * as AST                                 from '@je-es/ast';\r\n    import * as Diag                                from './components/DiagnosticManager';\r\n    import { ContextTracker, AnalysisPhase }        from './components/ContextTracker';\r\n    import { DebugManager, DebugKind }              from './components/DebugManager';\r\n    import { ScopeManager }                         from './components/ScopeManager';\r\n    import { SymbolCollector }                      from './phases/SymbolCollector';\r\n    import { SymbolResolver }                       from './phases/SymbolResolver';\r\n    import { TypeValidator }                        from './phases/TypeValidator';\r\n    import { SemanticValidator }                    from './phases/SemanticValidator';\r\n\r\n    // Re-export\r\n    export * from './components/DiagnosticManager';\r\n    export * from './components/ScopeManager';\r\n    export * from './components/DebugManager';\r\n    export * from './components/ContextTracker';\r\n\r\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\r\n\r\n\r\n\r\n// ╔════════════════════════════════════════ TYPE ════════════════════════════════════════╗\r\n\r\n    /** Analysis configuration options */\r\n    export interface AnalysisConfig {\r\n        /** Debug output level */\r\n        debug               ?: DebugKind;\r\n        /** Stop after specific phase */\r\n        stopAtPhase         ?: AnalysisPhase;\r\n        /** Enable strict mode (fail fast) */\r\n        strictMode          ?: boolean;\r\n        /** Maximum number of errors before stopping */\r\n        maxErrors           ?: number;\r\n\r\n        services            : AnalysisServices;\r\n\r\n        program             : AST.Program | null;\r\n    }\r\n\r\n    /** Analysis result with diagnostics and metadata */\r\n    export interface AnalysisResult {\r\n\r\n        /** Whether analysis succeeded without errors */\r\n        success             : boolean;\r\n\r\n        /** All diagnostic messages */\r\n        diagnostics         : Diag.Diagnostic[];\r\n\r\n        // /** Analysis performance metrics */\r\n        // performance?: PerformanceReport;\r\n\r\n        /** Phase where analysis stopped */\r\n        completedPhase      ?: AnalysisPhase;\r\n\r\n        /** Debug information (if enabled) */\r\n        debugInfo           ?: {\r\n            totalTime: number;\r\n            phaseTimings: Map<AnalysisPhase, number>;\r\n            memoryUsage?: number;\r\n        };\r\n    }\r\n\r\n    /** Internal phase result */\r\n    export interface PhaseResult {\r\n        success             : boolean;\r\n        phase               : AnalysisPhase;\r\n        duration            : number;\r\n        errors              : number;\r\n        warnings            : number;\r\n    }\r\n\r\n    /** Analysis services */\r\n    export interface AnalysisServices {\r\n        debugManager        : DebugManager;\r\n        contextTracker      : ContextTracker;\r\n        diagnosticManager   : Diag.DiagnosticManager;\r\n        scopeManager        : ScopeManager;\r\n    }\r\n\r\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\r\n\r\n\r\n\r\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\r\n\r\n    /**\r\n     * Multi-phase AST analyzer for je-es language\r\n     *\r\n     * Provides comprehensive analysis including:\r\n     * - Symbol collection and scope management\r\n     * - Symbol resolution and usage validation\r\n     * - Type checking and inference\r\n     * - Semantic validation\r\n     */\r\n    export class Analyzer {\r\n\r\n        // ┌────────────────────────── INITIALIZATION ──────────────────────────┐\r\n\r\n            config              : Required<AnalysisConfig>;\r\n            phaseTimings        : Map<AnalysisPhase, number> = new Map();\r\n            symbolCollector     : SymbolCollector;\r\n            symbolResolver      : SymbolResolver;\r\n            typeValidator       : TypeValidator;\r\n            semanticValidator   : SemanticValidator;\r\n\r\n            private constructor(config: Partial<AnalysisConfig> = {}) {\r\n                // Merge with defaults\r\n                this.config = this.createConfig(config);\r\n\r\n                // Initialize phase validators\r\n                this.symbolCollector    = new SymbolCollector(this.config);\r\n                this.symbolResolver     = new SymbolResolver(this.config);\r\n                this.typeValidator      = new TypeValidator(this.config);\r\n                this.semanticValidator  = new SemanticValidator(this.config);\r\n\r\n                this.log('verbose', `🚀 Analyzer initialized with config: ${JSON.stringify(this.config)}`);\r\n            }\r\n\r\n            getDiagMgr = () => this.config.services.diagnosticManager;\r\n\r\n            /** Factory method to create analyzer instance */\r\n            static create(config?: Partial<AnalysisConfig>): Analyzer {\r\n                return new Analyzer(config);\r\n            }\r\n\r\n            private log(kind: DebugKind = 'verbose', message: string ) {\r\n                this.config.services.debugManager.log(kind, message);\r\n            }\r\n\r\n        // └────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌──────────────────────── MAIN ANALYSIS INTERFACE ───────────────────┐\r\n\r\n            /**\r\n             * Analyze a program through all configured phases\r\n             * @param program The AST program to analyze\r\n             * @param config Optional runtime configuration overrides\r\n             * @returns Analysis result with diagnostics and metadata\r\n             */\r\n            analyze(program: AST.Program, config?: Partial<AnalysisConfig>): AnalysisResult {\r\n                const startTime = Date.now();\r\n                this.log('verbose', '🔍 Starting multi-phase analysis...');\r\n\r\n                try {\r\n                    // Apply runtime config overrides\r\n                    const effectiveConfig = { ...this.config, ...config };\r\n\r\n                    // Reset all components\r\n                    // this.reset();\r\n\r\n                    // Validate program structure\r\n                    if (!this.validateProgramStructure(program)) {\r\n                        return this.createErrorResult('Invalid program structure', AnalysisPhase.Collection);\r\n                    }\r\n\r\n                    // Set the program\r\n                    this.config.program = program;\r\n\r\n                    // Execute phases in order\r\n                    const phases: Array<{ phase: AnalysisPhase, executor: () => boolean }> = [\r\n\r\n                        { phase: AnalysisPhase.Collection,          executor: () => this.executePhase1() },\r\n                        { phase: AnalysisPhase.Resolution,          executor: () => this.executePhase2() },\r\n                        { phase: AnalysisPhase.TypeValidation,      executor: () => this.executePhase3() },\r\n                        { phase: AnalysisPhase.SemanticValidation,  executor: () => this.executePhase4() },\r\n                    ];\r\n\r\n                    let completedPhase: AnalysisPhase = AnalysisPhase.Collection;\r\n                    let shouldContinue = true;\r\n\r\n                    for (const { phase, executor } of phases) {\r\n                        if (!shouldContinue || this.shouldStopAtPhase(phase, effectiveConfig.stopAtPhase)) {\r\n                            break;\r\n                        }\r\n\r\n                        const phaseResult = this.runPhase(phase, executor);\r\n                        completedPhase = phase;\r\n\r\n                        // Check if we should continue\r\n                        if (!phaseResult.success) {\r\n                            if (effectiveConfig.strictMode) {\r\n                                this.log('errors', `❌ Stopping analysis at phase ${phase} due to errors (strict mode)`);\r\n                                shouldContinue = false;\r\n                            }\r\n                        }\r\n\r\n                        // Check error limit\r\n                        if (this.config.services.diagnosticManager.length() >= effectiveConfig.maxErrors) {\r\n                            this.log('errors', `⚠️ Stopping analysis due to error limit (${effectiveConfig.maxErrors})`);\r\n                            shouldContinue = false;\r\n                        }\r\n                    }\r\n\r\n                    // Generate final result\r\n                    const totalTime = Date.now() - startTime;\r\n                    const result = this.createFinalResult(completedPhase, totalTime);\r\n\r\n                    this.log('verbose',\r\n                        `Analysis completed in ${totalTime}ms\\n` +\r\n                        `   Success: ${result.success}\\n` +\r\n                        `   Errors: ${result.diagnostics.filter(d => d.kind === 'error').length}\\n` +\r\n                        `   Warnings: ${result.diagnostics.filter(d => d.kind === 'warning').length}\\n` +\r\n                        `   Completed phase: ${completedPhase}`\r\n                    );\r\n\r\n                    // if we have errors log it\r\n                    for (const diagnostic of result.diagnostics) {\r\n                        this.log('errors', `${diagnostic.kind}: ${diagnostic.msg}`);\r\n                    }\r\n\r\n                    return result;\r\n\r\n                } catch (error) {\r\n                    this.log('errors', `💥 Fatal analysis error: ${error}`);\r\n                    return this.createFatalErrorResult(error instanceof Error ? error.message : String(error));\r\n                }\r\n            }\r\n\r\n            private createServices(config ?: Partial<AnalysisConfig>): AnalysisServices {\r\n                const debugManager       = new DebugManager(undefined, config?.debug ?? 'off');\r\n                const contextTracker     = new ContextTracker(debugManager);\r\n                const diagnosticManager  = new Diag.DiagnosticManager(contextTracker, config?.strictMode ?? false);\r\n                const scopeManager       = new ScopeManager(diagnosticManager, debugManager);\r\n\r\n                return { debugManager, contextTracker, diagnosticManager, scopeManager }\r\n            }\r\n\r\n            private createConfig(config: Partial<AnalysisConfig>): Required<AnalysisConfig> {\r\n                return {\r\n                    debug           : config.debug          ?? 'off',\r\n                    stopAtPhase     : config.stopAtPhase    ?? AnalysisPhase.SemanticValidation,\r\n                    strictMode      : config.strictMode     ?? false,\r\n                    maxErrors       : config.maxErrors      ?? 100,\r\n                    services        : this.createServices(config),\r\n                    program         : config.program     ?? null,\r\n                };\r\n            }\r\n\r\n        // └────────────────────────────────────────────────────────────────────┘\r\n\r\n        // ┌────────────────────────── PHASE EXECUTION ─────────────────────────┐\r\n\r\n            private executePhase1(): boolean {\r\n                this.log('symbols', '📂 Phase 1: Symbol Collection');\r\n                return this.symbolCollector.handle();\r\n            }\r\n\r\n            private executePhase2(): boolean {\r\n                this.log('symbols', '🔗 Phase 2: Symbol Resolution');\r\n                return this.symbolResolver.handle();\r\n            }\r\n\r\n            private executePhase3(): boolean {\r\n                this.log('symbols', '🔍 Phase 3: Type Validation');\r\n                return this.typeValidator.handle();\r\n            }\r\n\r\n            private executePhase4(): boolean {\r\n                this.log('symbols', 'Phase 4: Semantic Validation');\r\n                return this.semanticValidator.handle();\r\n            }\r\n\r\n            private runPhase(phase: AnalysisPhase, executor: () => boolean): PhaseResult {\r\n                const startTime = Date.now();\r\n                const errorsBefore = this.config.services.diagnosticManager.length();\r\n\r\n                this.log('verbose', `🔄 Starting phase: ${phase}`);\r\n                this.config.services.debugManager.increaseIndent();\r\n\r\n                try {\r\n                    const success = executor();\r\n                    const duration = Date.now() - startTime;\r\n                    const errorsAfter = this.config.services.diagnosticManager.length();\r\n                    const newErrors = Math.max(0, errorsAfter - errorsBefore);\r\n                    const newWarnings = this.config.services.diagnosticManager.getDiagnostics()\r\n                        .slice(errorsBefore)\r\n                        .filter(d => d.kind === 'warning').length;\r\n\r\n                    this.phaseTimings.set(phase, duration);\r\n\r\n                    const result: PhaseResult = {\r\n                        success,\r\n                        phase,\r\n                        duration,\r\n                        errors: newErrors,\r\n                        warnings: newWarnings\r\n                    };\r\n\r\n                    this.log('verbose',\r\n                        `✨ Phase ${phase} completed in ${duration}ms ` +\r\n                        `(${newErrors} errors, ${newWarnings} warnings)`\r\n                    );\r\n\r\n                    // if we have errors log it\r\n                    for (const diagnostic of this.config.services.diagnosticManager.getDiagnostics().slice(errorsBefore)) {\r\n                        this.log('errors', `${diagnostic.kind}: ${diagnostic.msg}`);\r\n                    }\r\n\r\n                    return result;\r\n                } finally {\r\n                    this.config.services.debugManager.decreaseIndent();\r\n                }\r\n            }\r\n\r\n        // └────────────────────────────────────────────────────────────────────┘\r\n\r\n        // ┌─────────────────────── VALIDATION AND UTILITIES ───────────────────┐\r\n\r\n            private validateProgramStructure(program: AST.Program): boolean {\r\n                if (!program) {\r\n                    this.config.services.diagnosticManager.reportError(\r\n                        Diag.DiagCode.INTERNAL_ERROR,\r\n                        'Program is null or undefined'\r\n                    );\r\n                    return false;\r\n                }\r\n\r\n                if (!program.modules || program.modules.size === 0) {\r\n                    this.config.services.diagnosticManager.reportError(\r\n                        Diag.DiagCode.MODULE_NOT_FOUND,\r\n                        'Program contains no modules'\r\n                    );\r\n                    return false;\r\n                }\r\n\r\n                // Validate entry module exists if specified\r\n                const entryModule = program.metadata?.entryModule as string;\r\n                if (entryModule && !program.modules.has(entryModule)) {\r\n                    this.config.services.diagnosticManager.reportError(\r\n                        Diag.DiagCode.ENTRY_MODULE_NOT_FOUND,\r\n                        `Entry module '${entryModule}' not found`\r\n                    );\r\n                    return false;\r\n                }\r\n\r\n                return true;\r\n            }\r\n\r\n            private shouldStopAtPhase(currentPhase: AnalysisPhase, targetPhase: AnalysisPhase): boolean {\r\n                const phaseOrder = [\r\n                    AnalysisPhase.Collection,\r\n                    AnalysisPhase.Resolution,\r\n                    AnalysisPhase.TypeValidation,\r\n                    AnalysisPhase.SemanticValidation,\r\n                ];\r\n\r\n                const currentIndex = phaseOrder.indexOf(currentPhase);\r\n                const targetIndex = phaseOrder.indexOf(targetPhase);\r\n\r\n                return currentIndex > targetIndex;\r\n            }\r\n\r\n            reset(): void {\r\n                this.log('verbose', '🔄 Resetting analyzer state...');\r\n\r\n                this.phaseTimings.clear();\r\n                this.config.services.contextTracker.reset();\r\n                this.config.services.diagnosticManager.reset();\r\n                this.config.services.debugManager.reset();\r\n                this.config.services.scopeManager.reset();\r\n\r\n                this.config.program = null;\r\n\r\n                this.symbolCollector.reset();\r\n                this.symbolResolver.reset();\r\n                this.typeValidator.reset();\r\n                this.semanticValidator.reset();\r\n            }\r\n\r\n        // └────────────────────────────────────────────────────────────────────┘\r\n\r\n        // ┌───────────────────────── RESULT GENERATION ────────────────────────┐\r\n\r\n            private createFinalResult(completedPhase: AnalysisPhase, totalTime: number): AnalysisResult {\r\n                const diagnostics = this.config.services.diagnosticManager.getDiagnostics();\r\n                const hasErrors = diagnostics.some(d => d.kind === Diag.DiagKind.ERROR);\r\n\r\n                const result: AnalysisResult = {\r\n                    success: !hasErrors,\r\n                    diagnostics,\r\n                    completedPhase,\r\n                    debugInfo: {\r\n                        totalTime,\r\n                        phaseTimings: new Map(this.phaseTimings),\r\n                        memoryUsage: this.getMemoryUsage()\r\n                    }\r\n                };\r\n\r\n                return result;\r\n            }\r\n\r\n            private createErrorResult(message: string, phase: AnalysisPhase): AnalysisResult {\r\n                this.config.services.diagnosticManager.reportError(Diag.DiagCode.ANALYSIS_ERROR, message);\r\n\r\n                return {\r\n                    success: false,\r\n                    diagnostics: this.config.services.diagnosticManager.getDiagnostics(),\r\n                    completedPhase: phase\r\n                };\r\n            }\r\n\r\n            private createFatalErrorResult(message: string): AnalysisResult {\r\n                return {\r\n                    success: false,\r\n                    diagnostics: [{\r\n                        code: Diag.DiagCode.INTERNAL_ERROR,\r\n                        kind: Diag.DiagKind.ERROR,\r\n                        msg: `Fatal analysis error: ${message}`,\r\n                        targetSpan: { start: 0, end: 0 }\r\n                    }]\r\n                };\r\n            }\r\n\r\n            private getMemoryUsage(): number | undefined {\r\n                try {\r\n                    if (typeof process !== 'undefined' && process.memoryUsage) {\r\n                        return process.memoryUsage().heapUsed;\r\n                    }\r\n                } catch {\r\n                    // Ignore memory usage collection errors\r\n                }\r\n                return undefined;\r\n            }\r\n\r\n        // └────────────────────────────────────────────────────────────────────┘\r\n    }\r\n\r\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// DiagnosticManager.ts — Simplified diagnostic management.\n//\n// Developed with ❤️ by Maysara.\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span }                 from '@je-es/ast';\n    import { ContextTracker }       from './ContextTracker';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n// ╔════════════════════════════════════════ TYPE ════════════════════════════════════════╗\n\n    export enum DiagCode {\n        // General\n        INTERNAL_ERROR              = 'INTERNAL_ERROR',\n        PARSER_ERROR                = 'PARSER_ERROR',\n        MODULE_SCOPE_NOT_FOUND      = 'MODULE_SCOPE_NOT_FOUND',\n        MODULE_NOT_FOUND            = 'MODULE_NOT_FOUND',\n        TYPE_INFERENCE_FAILED       = 'TYPE_INFERENCE_FAILED',\n        OPTIMIZATION_HINT           = 'OPTIMIZATION_HINT',\n        SYMBOL_NOT_FOUND            = 'SYMBOL_NOT_FOUND',\n        ANONYMOUS_STRUCT            = 'ANONYMOUS_STRUCT',\n        TYPE_CYCLE_DETECTED         = 'TYPE_CYCLE_DETECTE',\n        TYPE_NESTING_TOO_DEEP       = 'TYPE_NESTING_TOO_DEEP',\n        SYMBOL_NOT_EXPORTED         = 'SYMBOL_NOT_EXPORTED',\n        MISSING_REQUIRED_FIELD      = 'MISSING_REQUIRED_FIELD',\n        INVALID_VISIBILITY          = 'INVALID_VISIBILITY',\n        INVALID_TYPE_WIDTH          = 'INVALID_TYPE_WIDTH',\n        MISSING_RETURN_STATEMENT    = 'MISSING_RETURN_STATEMENT',\n        INVALID_STATIC_ACCESS       = 'INVALID_STATIC_ACCESS',\n        SYMBOL_NOT_ACCESSIBLE       = 'SYMBOL_NOT_ACCESSIBLE',\n        INVALID_SIZEOF_TARGET       = 'INVALID_SIZEOF_TARGET',\n\n        // Error handling codes - MORE SPECIFIC\n        THROW_WITHOUT_ERROR_TYPE    = 'THROW_WITHOUT_ERROR_TYPE',\n        THROW_TYPE_MISMATCH         = 'THROW_TYPE_MISMATCH',\n        THROW_OUTSIDE_FUNCTION      = 'THROW_OUTSIDE_FUNCTION',\n        INVALID_ERROR_TYPE          = 'INVALID_ERROR_TYPE',\n        ERROR_MEMBER_NOT_FOUND      = 'ERROR_MEMBER_NOT_FOUND',        // Error set member not found\n        SELFERR_INVALID_CONTEXT     = 'SELFERR_INVALID_CONTEXT',       // selferr used outside self-group\n        THROW_NON_ERROR_TYPE        = 'THROW_NON_ERROR_TYPE',          // Throwing non-error value\n\n        TYPE_VALIDATION_FAILED      = 'TYPE_VALIDATION_FAILED',\n        INVALID_TYPE_OPERATION      = 'INVALID_TYPE_OPERATION',\n        TYPE_INCOMPATIBLE           = 'TYPE_INCOMPATIBLE',\n        TYPE_INFERENCE_ERROR        = 'TYPE_INFERENCE_ERROR',\n        NULL_POINTER_ERROR          = 'NULL_POINTER_ERROR',\n        TYPE_SAFETY_ERROR           = 'TYPE_SAFETY_ERROR',\n\n        // Syntax & Structure\n        SYNTAX_ERROR                = 'SYNTAX_ERROR',\n        ANALYSIS_ERROR              = 'ANALYSIS_ERROR',\n\n        // Entry Point\n        ENTRY_MODULE_NOT_FOUND      = 'ENTRY_MODULE_NOT_FOUND',\n        ENTRY_MODULE_NO_MAIN        = 'ENTRY_MODULE_NO_MAIN',\n        ENTRY_MODULE_PRIVATE_MAIN   = 'ENTRY_MODULE_PRIVATE_MAIN',\n\n        // Type System - MORE SPECIFIC\n        TYPE_MISMATCH               = 'TYPE_MISMATCH',\n        TYPE_MISMATCH_CALL          = 'TYPE_MISMATCH_CALL',            // Calling non-function\n        TYPE_MISMATCH_ASSIGNMENT    = 'TYPE_MISMATCH_ASSIGNMENT',      // Assignment type mismatch\n        TYPE_MISMATCH_RETURN        = 'TYPE_MISMATCH_RETURN',          // Return type mismatch\n        TYPE_MISMATCH_PARAMETER     = 'TYPE_MISMATCH_PARAMETER',       // Parameter type mismatch\n        TYPE_MISMATCH_FIELD         = 'TYPE_MISMATCH_FIELD',           // Struct field type mismatch\n        ARRAY_TO_NON_ARRAY          = 'ARRAY_TO_NON_ARRAY',\n        NON_ARRAY_TO_ARRAY          = 'NON_ARRAY_TO_ARRAY',\n        BOOL_TO_NON_BOOL            = 'BOOL_TO_NON_BOOL',\n        NON_BOOL_TO_BOOL            = 'NON_BOOL_TO_BOOL',\n        NEGATIVE_TO_UNSIGNED        = 'NEGATIVE_TO_UNSIGNED',\n        LITERAL_OVERFLOW            = 'LITERAL_OVERFLOW',\n        CANNOT_INFER_TYPE           = 'CANNOT_INFER_TYPE',\n\n        // Symbol Resolution - MORE SPECIFIC\n        UNDEFINED_IDENTIFIER        = 'UNDEFINED_IDENTIFIER',\n        UNDEFINED_IDENTIFIER_MEMBER = 'UNDEFINED_IDENTIFIER_MEMBER',   // Member access on undefined\n        UNDEFINED_IDENTIFIER_TYPEOF = 'UNDEFINED_IDENTIFIER_TYPEOF',   // typeof on undefined\n        UNDEFINED_BUILTIN           = 'UNDEFINED_BUILTIN',\n        UNDEFINED_FUNCTION          = 'UNDEFINED_FUNCTION',\n        NOT_A_FUNCTION              = 'NOT_A_FUNCTION',\n        USED_BEFORE_DECLARED        = 'USED_BEFORE_DECLARED',\n        USED_BEFORE_INITIALIZED     = 'USED_BEFORE_INITIALIZED',\n        UNDEFINED_TYPE              = 'UNDEFINED_TYPE',\n        UNSUPPORTED_TYPE            = 'UnsupportedType',\n\n        // Self Reference\n        VARIABLE_SELF_INIT          = 'VARIABLE_SELF_INIT',\n        PARAMETER_SELF_INIT         = 'PARAMETER_SELF_INIT',\n        PARAMETER_FORWARD_REFERENCE = 'PARAMETER_FORWARD_REFERENCE',\n\n        // Shadowing\n        USE_SHADOWING               = 'USE_SHADOWING',\n        DEFINITION_SHADOWING        = 'DEFINITION_SHADOWING',\n        VARIABLE_SHADOWING          = 'VARIABLE_SHADOWING',\n        FUNCTION_SHADOWING          = 'FUNCTION_SHADOWING',\n        PARAMETER_SHADOWING         = 'PARAMETER_SHADOWING',\n        STRUCT_FIELD_SHADOWING      = 'STRUCT_FIELD_SHADOWING',\n        ENUM_VARIANT_SHADOWING      = 'ENUM_VARIANT_SHADOWING',\n        ERROR_SHADOWING             = 'ERROR_SHADOWING',\n        DUPLICATE_SYMBOL            = 'DUPLICATE_SYMBOL',\n\n        // Function Calls\n        TOO_FEW_ARGUMENTS           = 'TOO_FEW_ARGUMENTS',\n        TOO_MANY_ARGUMENTS          = 'TOO_MANY_ARGUMENTS',\n\n        // Unused Symbols\n        UNUSED_VARIABLE             = 'UNUSED_VARIABLE',\n        UNUSED_PARAMETER            = 'UNUSED_PARAMETER',\n        UNUSED_FUNCTION             = 'UNUSED_FUNCTION',\n\n        // Type Operations\n        UNARY_MINUS_NON_NUMERIC     = 'UNARY_MINUS_NON_NUMERIC',\n        UNARY_PLUS_NON_NUMERIC      = 'UNARY_PLUS_NON_NUMERIC',\n\n        // Import System\n        IMPORT_NOT_FOUND            = 'IMPORT_NOT_FOUND',\n        IMPORT_CIRCULAR_DEPENDENCY  = 'IMPORT_CIRCULAR_DEPENDENCY',\n        IMPORT_PRIVATE_SYMBOL       = 'IMPORT_PRIVATE_SYMBOL',\n\n        // OVERFLOW - MORE SPECIFIC\n        NEGATIVE_SHIFT              = 'NEGATIVE_SHIFT',\n        SHIFT_OVERFLOW              = 'SHIFT_OVERFLOW',\n        SHIFT_RESULT_OVERFLOW       = 'SHIFT_RESULT_OVERFLOW',\n        ARITHMETIC_OVERFLOW         = 'ARITHMETIC_OVERFLOW',\n        ARITHMETIC_OVERFLOW_COMPTIME = 'ARITHMETIC_OVERFLOW_COMPTIME',  // Overflow in comptime\n        POTENTIAL_OVERFLOW          = 'POTENTIAL_OVERFLOW',\n\n        DIVISION_BY_ZERO            = 'DIVISION_BY_ZERO',\n        MODULO_BY_ZERO              = 'MODULO_BY_ZERO',\n        PRECISION_LOSS              = 'PRECISION_LOSS',\n        ARITHMETIC_ERROR            = 'ARITHMETIC_ERROR',\n\n        ARRAY_SIZE_MISMATCH         = 'ARRAY_SIZE_MISMATCH',\n        MUTABILITY_MISMATCH         = 'MUTABILITY_MISMATCH',\n        MUTABILITY_MISMATCH_POINTER = 'MUTABILITY_MISMATCH_POINTER',   // Pointer mutability mismatch\n        POTENTIAL_PRECISION_LOSS    = 'POTENTIAL_PRECISION_LOSS',\n        POTENTIAL_DATA_LOSS         = 'POTENTIAL_DATA_LOSS',\n\n        // Comptime - MORE SPECIFIC\n        COMPTIME_EVAL_FAILED        = 'COMPTIME_EVAL_FAILED',          // Comptime evaluation failed\n        COMPTIME_NON_CONST          = 'COMPTIME_NON_CONST',            // Non-const in comptime context\n    }\n\n    export enum DiagKind {\n        ERROR                       = 'error',\n        WARNING                     = 'warning',\n        INFO                        = 'info'\n    }\n\n    export interface Diagnostic {\n        code        : DiagCode;\n        kind        : DiagKind;\n        contextSpan ?: Span;\n        targetSpan  ?: Span;\n        msg         : string;\n        fixes       ?: DiagnosticFix[];\n\n        sourceModuleName ?: string;\n        sourceModulePath ?: string;\n    }\n\n    export interface DiagnosticFix {\n        kind        : 'add' | 'remove' | 'replace' | 'rename';\n        span        : Span;\n        msg         : string;\n        fix         ?: () => void;\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class DiagnosticManager {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public diagnostics          : Diagnostic[] = [];\n            private readonly strictMode : boolean;\n            private contextTracker      : ContextTracker;\n\n            constructor(contextTracker: ContextTracker, strictMode = false) {\n                this.strictMode         = strictMode;\n                this.contextTracker     = contextTracker;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            push(diagnostic: Diagnostic): void {\n                if (!diagnostic.sourceModuleName) {\n                    diagnostic.sourceModuleName = this.contextTracker.getModuleName();\n                }\n                if (!diagnostic.sourceModulePath) {\n                    const ctxPath = this.contextTracker.getModulePath();\n                    if (ctxPath && ctxPath.length > 0) {\n                        diagnostic.sourceModulePath = ctxPath;\n                    } else {\n                        const moduleName = this.contextTracker.getModuleName();\n                        if (moduleName && moduleName.length > 0) {\n                            diagnostic.sourceModulePath = `./${moduleName}`;\n                        }\n                    }\n                }\n                if (!diagnostic.contextSpan) {\n                    diagnostic.contextSpan = this.contextTracker.getContextSpan();\n                }\n\n                if (this.strictMode && this.diagnostics.length > 0 && diagnostic.kind === DiagKind.ERROR) {\n                    return;\n                }\n\n                this.diagnostics.push(diagnostic);\n            }\n\n            reportError(code: DiagCode, msg: string, targetSpan?: Span): void {\n                this.push({ code, kind: DiagKind.ERROR, msg, targetSpan });\n            }\n\n            reportWarning(code: DiagCode, msg: string, targetSpan?: Span): void {\n                this.push({ code, kind: DiagKind.WARNING, msg, targetSpan });\n            }\n\n            reportInfo(code: DiagCode, msg: string, targetSpan?: Span): void {\n                this.push({ code, kind: DiagKind.INFO, msg, targetSpan });\n            }\n\n            addErrorDiagnostic(diagnostic: { message: string, phase: any, severity: 'error' | 'warning' | 'info' }): void {\n                this.push({\n                    code: DiagCode.ANALYSIS_ERROR,\n                    kind: diagnostic.severity === 'error' ? DiagKind.ERROR :\n                          diagnostic.severity === 'warning' ? DiagKind.WARNING :\n                          DiagKind.INFO,\n                    msg: diagnostic.message\n                });\n            }\n\n            getDiagnostics(): Diagnostic[] {\n                return this.filterDuplicates(this.diagnostics);\n            }\n\n            reset(): void {\n                this.diagnostics = [];\n            }\n\n            hasErrors(): boolean {\n                return this.diagnostics.some(d => d.kind === DiagKind.ERROR);\n            }\n\n            length(): number {\n                return this.diagnostics.length;\n            }\n\n            getAllErrors(): Diagnostic[] {\n                return this.diagnostics.filter(d => d.kind === DiagKind.ERROR);\n            }\n\n            getAllWarnings(): Diagnostic[] {\n                return this.diagnostics.filter(d => d.kind === DiagKind.WARNING);\n            }\n\n            getAllInfos(): Diagnostic[] {\n                return this.diagnostics.filter(d => d.kind === DiagKind.INFO);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n        // ┌──────────────────────────────── HELP ──────────────────────────────┐\n\n            private isMoreSpecific(d1: Diagnostic, d2: Diagnostic): boolean {\n                // Define priority hierarchy for related errors\n                const errorPriority = new Map<DiagCode, number>([\n                    // Most specific errors (highest priority)\n                    [DiagCode.MODULE_NOT_FOUND, 100],\n                    [DiagCode.ERROR_MEMBER_NOT_FOUND, 100],\n                    [DiagCode.USED_BEFORE_DECLARED, 100],\n                    [DiagCode.SELFERR_INVALID_CONTEXT, 100],\n                    [DiagCode.NOT_A_FUNCTION, 90],\n                    [DiagCode.ARITHMETIC_OVERFLOW_COMPTIME, 90],\n                    [DiagCode.UNDEFINED_IDENTIFIER_MEMBER, 90],\n                    [DiagCode.UNDEFINED_IDENTIFIER_TYPEOF, 90],\n\n                    // Specific errors (high priority)\n                    [DiagCode.UNDEFINED_IDENTIFIER, 80],\n                    [DiagCode.ARITHMETIC_OVERFLOW, 80],\n                    [DiagCode.THROW_WITHOUT_ERROR_TYPE, 80],\n                    [DiagCode.MISSING_RETURN_STATEMENT, 70],\n                    [DiagCode.SYMBOL_NOT_FOUND, 60],\n\n                    // Generic errors (low priority)\n                    [DiagCode.THROW_TYPE_MISMATCH, 40],\n                    [DiagCode.TYPE_MISMATCH_CALL, 30],\n                    [DiagCode.TYPE_MISMATCH, 20],\n                    [DiagCode.TYPE_INFERENCE_FAILED, 10],\n                    [DiagCode.COMPTIME_EVAL_FAILED, 10],\n                    // [DiagCode.ANALYSIS_ERROR, 5],\n                ]);\n\n                const priority1 = errorPriority.get(d1.code) ?? 50;\n                const priority2 = errorPriority.get(d2.code) ?? 50;\n\n                if (priority1 !== priority2) {\n                    return priority1 > priority2;\n                }\n\n                // Longer message usually means more context\n                if (d1.msg.length !== d2.msg.length) {\n                    return d1.msg.length > d2.msg.length;\n                }\n\n                // Larger context span means more detail\n                const context1Size = d1.contextSpan\n                    ? d1.contextSpan.end - d1.contextSpan.start\n                    : 0;\n                const context2Size = d2.contextSpan\n                    ? d2.contextSpan.end - d2.contextSpan.start\n                    : 0;\n\n                if (context1Size !== context2Size) {\n                    return context1Size > context2Size;\n                }\n\n                return this.hasHigherPriority(d1, d2);\n            }\n\n            private hasHigherPriority(d1: Diagnostic, d2: Diagnostic): boolean {\n                const priority = { error: 2, warning: 1, info: 0 };\n                return (priority[d1.kind] || 0) > (priority[d2.kind] || 0);\n            }\n\n            private filterDuplicates(diagnostics: Diagnostic[]): Diagnostic[] {\n                const seen = new Map<string, Diagnostic>();\n\n                for (const diagnostic of diagnostics) {\n                    let foundDuplicate = false;\n                    let duplicateKey: string | null = null;\n\n                    // Check if this is the same issue as any existing diagnostic\n                    for (const [key, existingDiagnostic] of seen.entries()) {\n                        if (this.isSameIssue(diagnostic, existingDiagnostic)) {\n                            foundDuplicate = true;\n                            duplicateKey = key;\n                            break;\n                        }\n                    }\n\n                    if (!foundDuplicate) {\n                        const targetKey = this.getTargetKey(diagnostic);\n                        seen.set(targetKey, diagnostic);\n                    } else if (duplicateKey) {\n                        // Found a duplicate - keep the more specific one\n                        const existing = seen.get(duplicateKey)!;\n                        if (this.isMoreSpecific(diagnostic, existing)) {\n                            seen.set(duplicateKey, diagnostic);\n                        }\n                    }\n                }\n\n                return Array.from(seen.values());\n            }\n\n            private getTargetKey(diagnostic: Diagnostic): string {\n                const targetKey = diagnostic.targetSpan\n                    ? `t:${diagnostic.targetSpan.start}-${diagnostic.targetSpan.end}`\n                    : 'no-target';\n                return targetKey;\n            }\n\n            private isSameIssue(d1: Diagnostic, d2: Diagnostic): boolean {\n                const target1 = d1.targetSpan ? `${d1.targetSpan.start}-${d1.targetSpan.end}` : 'no-target';\n                const target2 = d2.targetSpan ? `${d2.targetSpan.start}-${d2.targetSpan.end}` : 'no-target';\n\n                // Multiple errors of these types are ALWAYS distinct, even at same location\n                const alwaysDistinctCodes = new Set([\n                    DiagCode.MODULE_NOT_FOUND,\n                    DiagCode.TYPE_MISMATCH,\n                    DiagCode.TYPE_MISMATCH_FIELD,\n                    DiagCode.SYMBOL_NOT_FOUND,\n                    DiagCode.USED_BEFORE_DECLARED,\n                    DiagCode.USED_BEFORE_INITIALIZED,\n                    DiagCode.MUTABILITY_MISMATCH,\n                ]);\n\n                // If both are \"always distinct\" codes, they're different issues\n                if (alwaysDistinctCodes.has(d1.code) && alwaysDistinctCodes.has(d2.code)) {\n                    return false;\n                }\n\n                // Check for overlapping target spans (not necessarily exact match)\n                const hasOverlappingTargets = target1 !== 'no-target' && target2 !== 'no-target' &&\n                    this.spansOverlap(d1.targetSpan!, d2.targetSpan!);\n\n                if (hasOverlappingTargets) {\n                    // Define known cascading patterns with related error codes\n                    const cascadingPatterns = [\n                        // [Root cause, Cascading error]\n                        [DiagCode.UNDEFINED_IDENTIFIER, DiagCode.TYPE_INFERENCE_FAILED],\n                        [DiagCode.UNDEFINED_IDENTIFIER_MEMBER, DiagCode.TYPE_INFERENCE_FAILED],\n                        [DiagCode.UNDEFINED_IDENTIFIER_TYPEOF, DiagCode.TYPE_INFERENCE_FAILED],\n                        [DiagCode.USED_BEFORE_DECLARED, DiagCode.TYPE_MISMATCH],\n                        [DiagCode.NOT_A_FUNCTION, DiagCode.TYPE_MISMATCH],\n                        [DiagCode.NOT_A_FUNCTION, DiagCode.TYPE_MISMATCH_CALL],\n                        [DiagCode.THROW_WITHOUT_ERROR_TYPE, DiagCode.MISSING_RETURN_STATEMENT],\n                        [DiagCode.ARITHMETIC_OVERFLOW, DiagCode.ANALYSIS_ERROR],\n                        [DiagCode.MODULE_NOT_FOUND, DiagCode.ANALYSIS_ERROR],\n                        [DiagCode.ARITHMETIC_OVERFLOW_COMPTIME, DiagCode.COMPTIME_EVAL_FAILED],\n                        [DiagCode.MISSING_RETURN_STATEMENT, DiagCode.ANALYSIS_ERROR],\n                        [DiagCode.MISSING_RETURN_STATEMENT, DiagCode.COMPTIME_EVAL_FAILED],\n\n                        // Duplicate detection from different validation layers\n                        [DiagCode.SYMBOL_NOT_FOUND, DiagCode.ERROR_MEMBER_NOT_FOUND],  // Error member - both report same issue\n                        [DiagCode.SYMBOL_NOT_FOUND, DiagCode.THROW_TYPE_MISMATCH],     // Symbol not found causes throw mismatch\n                        [DiagCode.ERROR_MEMBER_NOT_FOUND, DiagCode.THROW_TYPE_MISMATCH], // More specific error + generic\n                        [DiagCode.UNDEFINED_IDENTIFIER, DiagCode.SELFERR_INVALID_CONTEXT], // selferr detection in different phases\n                        [DiagCode.SELFERR_INVALID_CONTEXT, DiagCode.THROW_TYPE_MISMATCH], // selferr + throw mismatch\n                    ];\n\n                    // Check if this matches any known cascading pattern\n                    for (const [root, cascade] of cascadingPatterns) {\n                        if ((d1.code === root && d2.code === cascade) ||\n                            (d2.code === root && d1.code === cascade)) {\n                            return true;\n                        }\n                    }\n\n                    // Extract identifier from message\n                    const identifierPatterns = [\n                        /identifier '([^']+)'/i,\n                        /Symbol '([^']+)'/i,\n                        /'([^']+)' already imported/i,\n                        /'([^']+)' shadows/i\n                    ];\n\n                    let id1: string | null = null;\n                    let id2: string | null = null;\n\n                    for (const pattern of identifierPatterns) {\n                        id1 = id1 || d1.msg.match(pattern)?.[1] || null;\n                        id2 = id2 || d2.msg.match(pattern)?.[1] || null;\n                    }\n\n                    // If both mention the same identifier, it's likely the same issue\n                    if (id1 && id2 && id1 === id2) {\n                        return true;\n                    }\n\n                    // Check for duplicate/shadowing patterns\n                    const isDuplicateRelated = (code: DiagCode) =>\n                        code === DiagCode.DUPLICATE_SYMBOL ||\n                        code === DiagCode.USE_SHADOWING ||\n                        code === DiagCode.VARIABLE_SHADOWING ||\n                        code === DiagCode.FUNCTION_SHADOWING ||\n                        code === DiagCode.DEFINITION_SHADOWING ||\n                        code === DiagCode.PARAMETER_SHADOWING;\n\n                    if (isDuplicateRelated(d1.code) && isDuplicateRelated(d2.code)) {\n                        return true;\n                    }\n\n                    return true; // Same target = same issue by default\n                }\n\n                // Check if they share the same context and are related type errors\n                const context1 = d1.contextSpan ? `${d1.contextSpan.start}-${d1.contextSpan.end}` : 'no-context';\n                const context2 = d2.contextSpan ? `${d2.contextSpan.start}-${d2.contextSpan.end}` : 'no-context';\n\n                if (context1 === context2 && context1 !== 'no-context') {\n                    const isTypeError = (code: DiagCode) =>\n                        code === DiagCode.TYPE_MISMATCH ||\n                        code === DiagCode.ARITHMETIC_OVERFLOW ||\n                        code === DiagCode.LITERAL_OVERFLOW ||\n                        code === DiagCode.CANNOT_INFER_TYPE;\n\n                    // If both are type-related errors in the same context, treat as same issue\n                    if (isTypeError(d1.code) && isTypeError(d2.code)) {\n                        return true;\n                    }\n                }\n\n                return false;\n            }\n\n            private spansOverlap(s1: Span, s2: Span): boolean {\n                // Check if spans overlap at all\n                return s1.start <= s2.end && s2.start <= s1.end;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ContextTracker.ts — Context tracking utilitys.\r\n//\r\n// Developed with ❤️ by Maysara.\r\n\r\n\r\n\r\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\r\n\r\n    import * as AST                 from '@je-es/ast';\r\n    import { ScopeId, SymbolId }    from './ScopeManager';\r\n    import { DebugManager }         from './DebugManager';\r\n    import { DiagnosticManager }    from './DiagnosticManager';\r\n\r\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\r\n\r\n\r\n\r\n// ╔════════════════════════════════════════ TYPES ════════════════════════════════════════╗\r\n\r\n    export enum DeclarationPhase {\r\n        PreDeclaration          = 'PreDeclaration',\r\n        InDeclaration           = 'InDeclaration',\r\n        InInitialization        = 'InInitialization',\r\n        PostDeclaration         = 'PostDeclaration'\r\n    }\r\n\r\n    export enum ExpressionContext {\r\n        VariableInitializer     = 'VariableInitializer',\r\n        ParameterInitializer    = 'ParameterInitializer',\r\n        FunctionBody            = 'FunctionBody',\r\n        AssignmentTarget        = 'AssignmentTarget',\r\n        AssignmentSource        = 'AssignmentSource',\r\n        ConditionExpression     = 'ConditionExpression',\r\n        ReturnExpression        = 'ReturnExpression',\r\n        DeferExpression         = 'DeferExpression',\r\n        ThrowExpression         = 'ThrowExpression',\r\n        CallArgument            = 'CallArgument',\r\n        FunctionCall            = 'FunctionCall',\r\n        GeneralExpression       = 'GeneralExpression'\r\n    }\r\n\r\n    export interface DeclarationContext {\r\n        symbolName              : string;\r\n        symbolId                : SymbolId;\r\n        symbolKind              : ContextSymbolKind;\r\n        phase                   : DeclarationPhase;\r\n        span                    : AST.Span;\r\n        parentScope             : ScopeId;\r\n    }\r\n\r\n    export interface ExpressionContextInfo {\r\n        type                    : ExpressionContext;\r\n        relatedSymbol           ?: SymbolId;\r\n        depth                   : number;\r\n        span                    : AST.Span;\r\n    }\r\n\r\n    export interface AnalysisContext {\r\n        currentModuleName       : string;\r\n        currentModulePath       : string;\r\n        currentPhase            : AnalysisPhase;\r\n        contextSpanStack        : AST.Span[];\r\n        declarationStack        : DeclarationContext[];\r\n        expressionStack         : ExpressionContextInfo[];\r\n        currentScope            : ScopeId;\r\n        processingSymbols       : Set<SymbolId>;\r\n        pendingReferences       : Map<string, AST.Span[]>;\r\n        resolvedSymbols         : Set<SymbolId>;\r\n    }\r\n\r\n    export enum AnalysisPhase {\r\n        Collection              = 'Collection',\r\n        Resolution              = 'Resolution',\r\n        TypeValidation          = 'TypeValidation',\r\n        SemanticValidation      = 'SemanticValidation',\r\n        FinalValidation         = 'FinalValidation'\r\n    }\r\n\r\n    export type ContextSymbolKind = 'let' | 'Param' | 'fn' | 'Use' | 'def';\r\n\r\n    export interface SavedContextState {\r\n        scopeId                 : ScopeId;\r\n        moduleName              : string;\r\n        modulePath              : string;\r\n        spanStackDepth          : number;\r\n        declarationStackDepth   : number;\r\n        expressionStackDepth    : number;\r\n    }\r\n\r\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\r\n\r\n\r\n\r\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\r\n\r\n    export class ContextTracker {\r\n\r\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\r\n\r\n            private context             : AnalysisContext;\r\n            private currentPhase        : AnalysisPhase;\r\n            private phaseStack          : AnalysisPhase[];\r\n            private contextMap          : Map<string, unknown>;\r\n\r\n            constructor(\r\n                private debugManager?: DebugManager,\r\n                private diagnosticManager?: DiagnosticManager\r\n            ) {\r\n                this.context = this.genAnalysisContext();\r\n                this.currentPhase = AnalysisPhase.Collection;\r\n                this.phaseStack = [];\r\n                this.contextMap = new Map();\r\n            }\r\n\r\n            init(): void {\r\n                this.reset();\r\n            }\r\n\r\n            reset(): void {\r\n                this.context = this.genAnalysisContext();\r\n                this.currentPhase = AnalysisPhase.Collection;\r\n                this.phaseStack = [];\r\n                this.contextMap.clear();\r\n            }\r\n\r\n        // └────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\r\n\r\n            genAnalysisContext(): AnalysisContext {\r\n                return {\r\n                    currentModuleName   : '',\r\n                    currentModulePath   : '',\r\n                    currentPhase        : AnalysisPhase.Collection,\r\n                    contextSpanStack    : [],\r\n                    declarationStack    : [],\r\n                    expressionStack     : [],\r\n                    currentScope        : 0,\r\n                    processingSymbols   : new Set(),\r\n                    pendingReferences   : new Map(),\r\n                    resolvedSymbols     : new Set()\r\n                };\r\n            }\r\n\r\n        // └────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌─────────────────────── STATE SAVE/RESTORE (NEW) ──────────────────┐\r\n\r\n            saveState(): SavedContextState {\r\n                const state: SavedContextState = {\r\n                    scopeId                 : this.context.currentScope,\r\n                    moduleName              : this.context.currentModuleName,\r\n                    modulePath              : this.context.currentModulePath,\r\n                    spanStackDepth          : this.context.contextSpanStack.length,\r\n                    declarationStackDepth   : this.context.declarationStack.length,\r\n                    expressionStackDepth    : this.context.expressionStack.length\r\n                };\r\n\r\n                this.debugManager?.log('verbose',\r\n                    `💾 Saved context state: scope=${state.scopeId}, ` +\r\n                    `module=${state.moduleName}, spans=${state.spanStackDepth}`\r\n                );\r\n\r\n                return state;\r\n            }\r\n\r\n            restoreState(state: SavedContextState): void {\r\n                this.debugManager?.log('verbose',\r\n                    `♻️  Restoring context state: scope=${state.scopeId}, module=${state.moduleName}`\r\n                );\r\n\r\n                // Validate state before restoration\r\n                if (!this.validateSavedState(state)) {\r\n                    this.debugManager?.log('errors', `⚠️  Invalid saved state detected, attempting recovery`);\r\n                    // Don't throw - try to recover gracefully\r\n                }\r\n\r\n                // Restore scope\r\n                this.context.currentScope = state.scopeId;\r\n\r\n                // Restore module info\r\n                this.context.currentModuleName = state.moduleName;\r\n                this.context.currentModulePath = state.modulePath;\r\n\r\n                // Restore stack depths with overflow protection\r\n                this.restoreStack(this.context.contextSpanStack, state.spanStackDepth, 'contextSpan');\r\n                this.restoreStack(this.context.expressionStack, state.expressionStackDepth, 'expression');\r\n\r\n                // Declaration stack needs special handling for symbol cleanup\r\n                while (this.context.declarationStack.length > state.declarationStackDepth) {\r\n                    const decl = this.context.declarationStack.pop();\r\n                    if (decl) {\r\n                        this.context.processingSymbols.delete(decl.symbolId);\r\n                    }\r\n                }\r\n            }\r\n\r\n            withSavedState<T>(fn: () => T): T {\r\n                const savedState = this.saveState();\r\n                try {\r\n                    return fn();\r\n                } finally {\r\n                    this.restoreState(savedState);\r\n                }\r\n            }\r\n\r\n            private restoreStack<T>(stack: T[], targetDepth: number, name: string): void {\r\n                if (stack.length < targetDepth) {\r\n                    this.debugManager?.log('errors',\r\n                        `⚠️ Stack underflow for ${name}: current=${stack.length}, target=${targetDepth}. Clearing stack.`\r\n                    );\r\n                    stack.length = 0; // Clear corrupted stack\r\n                    return;\r\n                }\r\n                while (stack.length > targetDepth) {\r\n                    stack.pop();\r\n                }\r\n            }\r\n\r\n            private validateSavedState(state: SavedContextState): boolean {\r\n                if (state.scopeId < 0) return false;\r\n                if (state.spanStackDepth < 0) return false;\r\n                if (state.declarationStackDepth < 0) return false;\r\n                if (state.expressionStackDepth < 0) return false;\r\n                return true;\r\n            }\r\n\r\n        // └────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌──────────────────────────── MODULE & PHASE ────────────────────────┐\r\n\r\n            setModuleName(moduleName: string): void {\r\n                this.context.currentModuleName = moduleName;\r\n                this.debugManager?.log('verbose', `Context: Set module name to '${moduleName}'`);\r\n            }\r\n\r\n            setModulePath(modulePath: string): void {\r\n                this.context.currentModulePath = modulePath;\r\n                this.debugManager?.log('verbose', `Context: Set module path to '${modulePath}'`);\r\n            }\r\n\r\n            pushPhase(phase: AnalysisPhase): void {\r\n                this.phaseStack.push(this.currentPhase);\r\n                this.setPhase(phase);\r\n                this.debugManager?.log('verbose', `Context: Pushed phase '${phase}' (stack: ${this.phaseStack.length})`);\r\n            }\r\n\r\n            popPhase(): AnalysisPhase | undefined {\r\n                const previousPhase = this.phaseStack.pop();\r\n                if (previousPhase) {\r\n                    this.setPhase(previousPhase);\r\n                    this.debugManager?.log('verbose', `Context: Popped phase, returned to '${previousPhase}'`);\r\n                }\r\n                return previousPhase;\r\n            }\r\n\r\n            setPhase(phase: AnalysisPhase): void {\r\n                this.currentPhase = phase;\r\n                this.context.currentPhase = phase;\r\n                this.debugManager?.log('verbose', `Context: Entered phase '${phase}'`);\r\n            }\r\n\r\n            getCurrentPhase(): AnalysisPhase | undefined {\r\n                return this.context.currentPhase;\r\n            }\r\n\r\n            setScope(scopeId: ScopeId): void {\r\n                this.context.currentScope = scopeId;\r\n            }\r\n\r\n        // └────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌─────────────────────── CONTEXT SPAN MANAGEMENT ────────────────────┐\r\n\r\n            setCurrentContextSpan(span?: AST.Span): void {\r\n                if (span) {\r\n                    this.context.contextSpanStack.push(span);\r\n                    this.debugManager?.log('verbose', `Context: Pushed span [${span.start}-${span.end}] (stack depth: ${this.context.contextSpanStack.length})`);\r\n                } else {\r\n                    if (this.context.contextSpanStack.length > 0) {\r\n                        const removed = this.context.contextSpanStack.pop();\r\n                        this.debugManager?.log('verbose', `Context: Popped span [${removed?.start}-${removed?.end}] (stack depth: ${this.context.contextSpanStack.length})`);\r\n                    }\r\n                }\r\n            }\r\n\r\n            pushContextSpan(span: AST.Span): void {\r\n                this.context.contextSpanStack.push(span);\r\n                this.debugManager?.log('verbose', `Context: Pushed scoped span [${span.start}-${span.end}]`);\r\n            }\r\n\r\n            popContextSpan(): AST.Span | undefined {\r\n                const span = this.context.contextSpanStack.pop();\r\n                if (span) {\r\n                    this.debugManager?.log('verbose', `Context: Popped scoped span [${span.start}-${span.end}]`);\r\n                }\r\n                return span;\r\n            }\r\n\r\n            clearContextSpans(): void {\r\n                const count = this.context.contextSpanStack.length;\r\n                this.context.contextSpanStack = [];\r\n                this.debugManager?.log('verbose', `Context: Cleared ${count} context spans`);\r\n            }\r\n\r\n        // └────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌──────────────────────── DECLARATION TRACKING ──────────────────────┐\r\n\r\n            startDeclaration(\r\n                symbolName: string,\r\n                symbolId: SymbolId,\r\n                symbolKind: ContextSymbolKind | 'Use',\r\n                span: AST.Span,\r\n                parentScope: ScopeId\r\n            ): void {\r\n                const declaration: DeclarationContext = {\r\n                    symbolName,\r\n                    symbolId,\r\n                    symbolKind,\r\n                    phase: DeclarationPhase.InDeclaration,\r\n                    span,\r\n                    parentScope\r\n                };\r\n\r\n                this.context.declarationStack.push(declaration);\r\n                this.context.processingSymbols.add(symbolId);\r\n                this.pushContextSpan(span);\r\n\r\n                this.debugManager?.log('verbose', `Context: Started declaration of ${symbolKind} '${symbolName}' (id: ${symbolId})`);\r\n            }\r\n\r\n            startInitialization(symbolId: SymbolId): void {\r\n                const current = this.getCurrentDeclaration();\r\n                if (current && current.symbolId === symbolId) {\r\n                    current.phase = DeclarationPhase.InInitialization;\r\n                    this.debugManager?.log('verbose', `Context: Started initialization of symbol '${current.symbolName}' (id: ${symbolId})`);\r\n                }\r\n            }\r\n\r\n            completeDeclaration(symbolId: SymbolId): void {\r\n                const index = this.context.declarationStack.findIndex(d => d.symbolId === symbolId);\r\n                if (index >= 0) {\r\n                    const declaration = this.context.declarationStack[index];\r\n                    declaration.phase = DeclarationPhase.PostDeclaration;\r\n                    this.context.declarationStack.splice(index, 1);\r\n                    this.popContextSpan();\r\n                    this.debugManager?.log('verbose', `Context: Completed declaration of '${declaration.symbolName}' (id: ${symbolId})`);\r\n                }\r\n\r\n                this.context.processingSymbols.delete(symbolId);\r\n                this.context.resolvedSymbols.add(symbolId);\r\n            }\r\n\r\n            isInDeclaration(symbolName: string): boolean {\r\n                return this.context.declarationStack.some(d => d.symbolName === symbolName);\r\n            }\r\n\r\n            isInInitialization(symbolName: string): boolean {\r\n                return this.context.declarationStack.some(d =>\r\n                    d.symbolName === symbolName && d.phase === DeclarationPhase.InInitialization\r\n                );\r\n            }\r\n\r\n            getCurrentDeclaration(): DeclarationContext | undefined {\r\n                return this.context.declarationStack[this.context.declarationStack.length - 1];\r\n            }\r\n\r\n        // └────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌───────────────────────── EXPRESSION TRACKING ──────────────────────┐\r\n\r\n            enterExpression(type: ExpressionContext, span: AST.Span, relatedSymbol?: SymbolId): void {\r\n                if (!span) {\r\n                    this.debugManager?.log('verbose', 'Warning: Attempted to enter expression context without span');\r\n                    return;\r\n                }\r\n\r\n                const depth = this.context.expressionStack.length;\r\n                this.context.expressionStack.push({ type, relatedSymbol, depth, span });\r\n                this.pushContextSpan(span);\r\n                this.debugManager?.log('verbose', `Context: Entered expression ${type} at depth ${depth}`);\r\n            }\r\n\r\n            exitExpression(): ExpressionContextInfo | undefined {\r\n                if (this.context.expressionStack.length === 0) {\r\n                    return undefined;\r\n                }\r\n\r\n                const exited = this.context.expressionStack.pop();\r\n                this.popContextSpan();\r\n\r\n                if (exited) {\r\n                    this.debugManager?.log('verbose', `Context: Exited expression ${exited.type} from depth ${exited.depth}`);\r\n                }\r\n\r\n                return exited;\r\n            }\r\n\r\n            getCurrentExpressionContext(): ExpressionContextInfo | undefined {\r\n                return this.context.expressionStack[this.context.expressionStack.length - 1];\r\n            }\r\n\r\n            isInExpressionType(type: ExpressionContext): boolean {\r\n                return this.context.expressionStack.some(ctx => ctx.type === type);\r\n            }\r\n\r\n            getExpressionDepth(): number {\r\n                return this.context.expressionStack.length;\r\n            }\r\n\r\n        // └────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌────────────────────── SELF-REFERENCE DETECTION ────────────────────┐\r\n\r\n            checkSelfReference(symbolName: string, referenceSpan: AST.Span): {\r\n                isSelfReference: boolean;\r\n                declarationContext?: DeclarationContext;\r\n                errorType?: 'VARIABLE_SELF_INIT' | 'PARAMETER_SELF_INIT';\r\n            } {\r\n                const currentDeclaration = this.context.declarationStack.find(d =>\r\n                    d.symbolName === symbolName && d.phase === DeclarationPhase.InInitialization\r\n                );\r\n\r\n                if (currentDeclaration) {\r\n                    const errorType = currentDeclaration.symbolKind === 'let' ?\r\n                        'VARIABLE_SELF_INIT' as const : 'PARAMETER_SELF_INIT' as const;\r\n\r\n                    return {\r\n                        isSelfReference: true,\r\n                        declarationContext: currentDeclaration,\r\n                        errorType\r\n                    };\r\n                }\r\n\r\n                return { isSelfReference: false };\r\n            }\r\n\r\n        // └────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌───────────────────── FORWARD REFERENCE TRACKING ───────────────────┐\r\n\r\n            recordPendingReference(symbolName: string, span: AST.Span): void {\r\n                if (!this.context.pendingReferences.has(symbolName)) {\r\n                    this.context.pendingReferences.set(symbolName, []);\r\n                }\r\n                this.context.pendingReferences.get(symbolName)!.push(span);\r\n            }\r\n\r\n            resolvePendingReferences(symbolName: string): AST.Span[] {\r\n                const spans = this.context.pendingReferences.get(symbolName) || [];\r\n                this.context.pendingReferences.delete(symbolName);\r\n                return spans;\r\n            }\r\n\r\n            getPendingReferences(): Map<string, AST.Span[]> {\r\n                return new Map(this.context.pendingReferences);\r\n            }\r\n\r\n        // └────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌───────────────────── PARAMETER ORDER VALIDATION ───────────────────┐\r\n\r\n            checkParameterForwardReference(\r\n                parameterName: string,\r\n                currentParameterIndex: number,\r\n                allParameters: { name: string; index: number }[]\r\n            ): {\r\n                isForwardReference: boolean;\r\n                referencedParameterIndex?: number;\r\n            } {\r\n                const referencedParam = allParameters.find(p => p.name === parameterName);\r\n\r\n                if (referencedParam && referencedParam.index > currentParameterIndex) {\r\n                    return {\r\n                        isForwardReference: true,\r\n                        referencedParameterIndex: referencedParam.index\r\n                    };\r\n                }\r\n\r\n                return { isForwardReference: false };\r\n            }\r\n\r\n        // └────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌─────────────────────────── CONTEXT QUERIES ────────────────────────┐\r\n\r\n            getContextSpan(): AST.Span | undefined {\r\n                if (this.context.contextSpanStack.length > 0) {\r\n                    return this.context.contextSpanStack[this.context.contextSpanStack.length - 1];\r\n                }\r\n\r\n                const currentExpression = this.getCurrentExpressionContext();\r\n                if (currentExpression?.span) {\r\n                    return currentExpression.span;\r\n                }\r\n\r\n                const currentDeclaration = this.getCurrentDeclaration();\r\n                if (currentDeclaration?.span) {\r\n                    return currentDeclaration.span;\r\n                }\r\n\r\n                return undefined;\r\n            }\r\n\r\n            getContext(): Readonly<AnalysisContext> {\r\n                return this.context;\r\n            }\r\n\r\n            getPhase(): string {\r\n                return this.context.currentPhase;\r\n            }\r\n\r\n            getModuleName(): string {\r\n                return this.context.currentModuleName;\r\n            }\r\n\r\n            getModulePath(): string {\r\n                return this.context.currentModulePath;\r\n            }\r\n\r\n            getScope(): ScopeId {\r\n                return this.context.currentScope;\r\n            }\r\n\r\n            getProcessingSymbols(): Set<SymbolId> {\r\n                return new Set(this.context.processingSymbols);\r\n            }\r\n\r\n            getResolvedSymbols(): Set<SymbolId> {\r\n                return new Set(this.context.resolvedSymbols);\r\n            }\r\n\r\n            getDeclarationStack(): DeclarationContext[] {\r\n                return [...this.context.declarationStack];\r\n            }\r\n\r\n            getCurrentDeclarationContext(): DeclarationContext | undefined {\r\n                return this.context.declarationStack[this.context.declarationStack.length - 1];\r\n            }\r\n\r\n            getCurrentDeclarationSymbolId(): SymbolId | undefined {\r\n                const current = this.getCurrentDeclaration();\r\n                return current ? current.symbolId : undefined;\r\n            }\r\n\r\n            getCurrentDeclarationSymbolName(): string | undefined {\r\n                const current = this.getCurrentDeclaration();\r\n                return current ? current.symbolName : undefined;\r\n            }\r\n\r\n            getCurrentDeclarationSymbolKind(): ContextSymbolKind | undefined {\r\n                const current = this.getCurrentDeclaration();\r\n                return current ? current.symbolKind : undefined;\r\n            }\r\n\r\n            getCurrentDeclarationPhase(): DeclarationPhase | undefined {\r\n                const current = this.getCurrentDeclaration();\r\n                return current ? current.phase : undefined;\r\n            }\r\n\r\n            getCurrentDeclarationSpan(): AST.Span | undefined {\r\n                const current = this.getCurrentDeclaration();\r\n                return current ? current.span : undefined;\r\n            }\r\n\r\n            getCurrentDeclarationParentScope(): ScopeId | undefined {\r\n                const current = this.getCurrentDeclaration();\r\n                return current ? current.parentScope : undefined;\r\n            }\r\n\r\n            getCurrentDeclarationStackDepth(): number {\r\n                return this.context.declarationStack.length;\r\n            }\r\n\r\n            getCurrentDeclarationStackTrace(): string[] {\r\n                return this.context.declarationStack.map(d =>\r\n                    `${d.symbolKind} '${d.symbolName}' (${d.phase})`\r\n                );\r\n            }\r\n\r\n            isProcessingSymbol(symbolId: SymbolId): boolean {\r\n                return this.context.processingSymbols.has(symbolId);\r\n            }\r\n\r\n            isSymbolResolved(symbolId: SymbolId): boolean {\r\n                return this.context.resolvedSymbols.has(symbolId);\r\n            }\r\n\r\n            getDeclarationStackTrace(): string[] {\r\n                return this.context.declarationStack.map(d =>\r\n                    `${d.symbolKind} '${d.symbolName}' (${d.phase})`\r\n                );\r\n            }\r\n\r\n            getExpressionStackTrace(): string[] {\r\n                return this.context.expressionStack.map(e =>\r\n                    `${e.type} at depth ${e.depth}`\r\n                );\r\n            }\r\n\r\n        // └────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌─────────────────────────── DEBUG UTILITIES ────────────────────────┐\r\n\r\n            debugState(): void {\r\n                console.log('Enhanced Context Tracker State:', {\r\n                    module: this.context.currentModuleName,\r\n                    phase: this.context.currentPhase,\r\n                    scope: this.context.currentScope,\r\n                    contextSpanStack: this.context.contextSpanStack.map(s => `[${s.start}-${s.end}]`),\r\n                    declarationStack: this.getDeclarationStackTrace(),\r\n                    expressionStack: this.getExpressionStackTrace(),\r\n                    processingSymbols: Array.from(this.context.processingSymbols),\r\n                    pendingReferences: Array.from(this.context.pendingReferences.keys())\r\n                });\r\n            }\r\n\r\n        // └────────────────────────────────────────────────────────────────────┘\r\n    }\r\n\r\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// DebugManager.ts — Simplified debug management.\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { ContextTracker } from './ContextTracker';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ TYPE ════════════════════════════════════════╗\n\n    export type DebugKind = 'off' | 'errors' | 'symbols' | 'scopes' | 'nodes' | 'verbose';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class DebugManager {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            private debugLevel          : DebugKind = 'off';\n            private indentLevel         = 0;\n            private contextTracker?     : ContextTracker;\n\n            constructor(contextTracker?: ContextTracker, debugLevel: DebugKind = 'off') {\n                this.debugLevel         = debugLevel;\n                this.contextTracker     = contextTracker;\n            }\n\n            reset(): void {\n                this.indentLevel = 0;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            log(level: DebugKind, message: string): void {\n                if (this.debugLevel === 'off') {return;}\n\n                const levels: DebugKind[] = ['off', 'errors', 'symbols', 'scopes', 'nodes', 'verbose'];\n                const currentIndex = levels.indexOf(this.debugLevel);\n                const messageIndex = levels.indexOf(level);\n\n                if (messageIndex <= currentIndex) {\n                    const prefix = this.getDebugPrefix(level);\n                    const indent = '  '.repeat(this.indentLevel);\n\n                    // Get caller function name\n                    let callerName = '';\n                    try {\n                        const err = new Error();\n                        if (err.stack) {\n                            const stackLines = err.stack.split('\\n');\n\n                            // Try to extract function name and method name\n                            if (stackLines.length > 2) {\n                                const match = stackLines[2].match(/at (?:.*\\.)?([a-zA-Z0-9_$]+)(?: \\[as .*\\])? /);\n                                if (match && match[1]) {\n                                    callerName = match[1];\n                                }\n                            }\n                        }\n                    } catch { /* empty */ }\n\n                    const callerInfo = callerName ? `${callerName}() : ` : '';\n                    // Get short file path and line number\n                    let short_file_path = 'unknown';\n                    let line = 0;\n                    let column = 0;\n                    try {\n                        const err = new Error();\n                        if (err.stack) {\n                            const stackLines = err.stack.split('\\n');\n\n                            // Try to extract file path, line number, and column number\n                            if (stackLines.length > 2) {\n                                const match = stackLines[2].match(/at .* \\((.*):(\\d+):(\\d+)\\)/) ||\n                                              stackLines[2].match(/at (.*):(\\d+):(\\d+)/);\n                                if (match && match[1] && match[2] && match[3]) {\n                                    const fullPath = match[1];\n                                    short_file_path = fullPath.split('/').slice(-2).join('/'); // last two segments\n                                    line = parseInt(match[2], 10);\n                                    column = parseInt(match[3], 10);\n                                }\n                            }\n                        }\n                    } catch { /* empty */ }\n\n                    if(short_file_path !== 'unknown') {\n                        // Extract root folder (e.g., src, lib) and reconstruct path\n                        const match = short_file_path.match(/(src|lib)[/\\\\].*/);\n                        if (match) {\n                            short_file_path = `./${match[0].replace(/\\\\/g, '/')}`;\n                        } else {\n                            // fallback to last two segments\n                            const parts = short_file_path.split(/[/\\\\]/);\n                            if(parts.length > 2) {\n                                short_file_path = `./${parts.slice(-2).join('/')}`;\n                            } else if(parts.length === 2) {\n                                short_file_path = `./${short_file_path.replace(/\\\\/g, '/')}`;\n                            }\n                        }\n                    }\n\n                    // console.log(`${prefix} ${indent}${callerInfo}${message} at ${short_file_path}:${line}:${column}`);\n                }\n            }\n\n            increaseIndent(): void {\n                this.indentLevel++;\n            }\n\n            decreaseIndent(): void {\n                this.indentLevel = Math.max(0, this.indentLevel - 1);\n            }\n\n            setDebugLevel(level: DebugKind): void {\n                this.debugLevel = level;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HELP ──────────────────────────────┐\n\n            private getDebugPrefix(level: DebugKind): string {\n                const prefixes: Record<string, string> = {\n                    errors   : '🔥',\n                    symbols  : '', // 📝\n                    scopes   : '📦',\n                    nodes    : '🌳',\n                    verbose  : '', // 📊\n                };\n\n                const prefix = prefixes[level] === '' ? '' : `[${prefixes[level] || '⚡'}]`;\n\n                let phasePrefix = '';\n                if (this.contextTracker) {\n                    const phase = this.contextTracker.getCurrentPhase();\n                    if (phase) {\n                        phasePrefix = `[${phase}] `;\n                    }\n                }\n\n                return `${phasePrefix}${prefix}`;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ScopeManager.ts — Scope and symbol management.\r\n//\r\n// Developed with ❤️ by Maysara.\r\n\r\n\r\n\r\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\r\n\r\n    import * as AST                 from '@je-es/ast';\r\n    import { IdGenerator }          from \"./IdGenerator\";\r\n    import { DebugManager }         from './DebugManager';\r\n    import { DiagnosticManager}     from './DiagnosticManager';\r\n\r\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\r\n\r\n\r\n\r\n// ╔════════════════════════════════════════ TYPE ════════════════════════════════════════╗\r\n\r\n    export type ScopeId = number;\r\n    export type SymbolId = number;\r\n\r\n    export enum ScopeKind {\r\n        Global          = 'Global',\r\n        Module          = 'Module',\r\n        Function        = 'Function',\r\n        Loop            = 'Loop',\r\n        Block           = 'Block',\r\n        Expression      = 'Expression',\r\n        Type            = 'Type',\r\n    }\r\n\r\n    export enum SymbolKind {\r\n        Use             = 'Use',\r\n        Definition      = 'Definition',\r\n        Variable        = 'Variable',\r\n        Function        = 'Function',\r\n        Parameter       = 'Parameter',\r\n        StructField     = 'StructField',\r\n        EnumVariant     = 'EnumVariant',\r\n        Error           = 'Error'\r\n    }\r\n\r\n    export interface Scope {\r\n        id              : ScopeId;\r\n        kind            : ScopeKind;\r\n        name            : string;\r\n        parent          : ScopeId | null;\r\n        children        : ScopeId[];\r\n        symbols         : Map<string, Symbol>;\r\n        level           : number;\r\n        metadata       ?: Record<string, unknown>;\r\n    }\r\n\r\n    export interface Symbol {\r\n        id              : SymbolId;\r\n        name            : string;\r\n        kind            : SymbolKind;\r\n        type            : AST.TypeNode | null;\r\n        scope           : ScopeId;\r\n        contextSpan     : AST.Span;\r\n        targetSpan?     : AST.Span;\r\n\r\n        // State flags\r\n        declared        : boolean;\r\n        initialized     : boolean;\r\n        used            : boolean;\r\n        isTypeChecked   : boolean;\r\n\r\n        // Type information\r\n        typeInfo?       : {\r\n            baseTypes?      : SymbolId[];       // Base classes/interfaces\r\n            typeParams?     : Symbol[];         // Generic type parameters\r\n            constraints?    : AST.TypeNode[];   // Type parameter constraints\r\n            isGeneric?      : boolean;          // Whether this is a generic type/function\r\n        };\r\n\r\n        // Metadata\r\n        module?             : string;\r\n        namespace?          : string;\r\n        visibility          : AST.VisibilityInfo;\r\n        mutability          : AST.MutabilityInfo;\r\n        metadata?           : {\r\n            callable?       : boolean;      // For callable symbols\r\n            params?         : Symbol[];     // Function parameters\r\n            returnType?     : AST.TypeNode; // Function return type\r\n            errorType?      : AST.TypeNode; // Function error type\r\n            isAsync?        : boolean;      // Async function\r\n            isStatic?       : boolean;      // Static member\r\n            isAbstract?     : boolean;      // Abstract member\r\n            isBuiltin?      : boolean;      // Built-in symbol\r\n            errorMode?      : 'err-ident' | 'err-group' | 'any-error' | 'self-group';\r\n            selfGroupErrors?: string[];     // Only for self-group mode\r\n            [key: string]   : unknown;\r\n        };\r\n\r\n        // Import/Export metadata\r\n        importSource?   : string;       // Source module\r\n        importPath?     : string;       // Import path\r\n        importAlias?    : string;       // Import alias\r\n        sourceSymbol?   : SymbolId;     // Original symbol ID\r\n        isExported      : boolean;      // Is exported\r\n        exportAlias?    : string;       // Export alias\r\n    }\r\n\r\n    export interface BuiltinSymbolOption {\r\n        type            : AST.TypeNode | null\r\n    }\r\n\r\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\r\n\r\n\r\n\r\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\r\n\r\n    export class ScopeManager {\r\n\r\n        // ┌──────────────────────────────── INIT ────────────────────────────────┐\r\n\r\n            private static readonly SYMBOL_PROXIMITY_THRESHOLD = 1000;\r\n\r\n            private scopes!             : Map<ScopeId, Scope>;\r\n            private currentScope!       : ScopeId;\r\n            private globalScope!        : Scope;\r\n            private symbolTable!        : Map<SymbolId, Symbol>;\r\n            private namespaceLookup!    : Map<string, Set<SymbolId>>;\r\n\r\n            readonly idGenerator        : IdGenerator;\r\n            readonly symbolIdGenerator  : IdGenerator;\r\n\r\n            constructor(\r\n                private readonly diagnosticManager  : DiagnosticManager,\r\n                private readonly debugManager?      : DebugManager\r\n            ) {\r\n                this.idGenerator        = new IdGenerator();\r\n                this.symbolIdGenerator  = new IdGenerator();\r\n                this.init();\r\n            }\r\n\r\n        // └──────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌──────────────────────────────── MAIN ────────────────────────────────┐\r\n\r\n            init(): void {\r\n                this.scopes = new Map();\r\n                this.symbolTable = new Map();\r\n                this.namespaceLookup = new Map();\r\n\r\n                // Create global scope\r\n                this.globalScope = this.createScope(ScopeKind.Global, 'global', null);\r\n                this.currentScope = this.globalScope.id;\r\n\r\n                // Initialize built-in symbols\r\n                this.initializeBuiltins();\r\n            }\r\n\r\n            reset(): void {\r\n                // Store global scope ID before cleanup\r\n                const globalScopeId = this.globalScope.id;\r\n\r\n                // Clear all collections\r\n                this.scopes.clear();\r\n                this.symbolTable.clear();\r\n                this.namespaceLookup.clear();\r\n\r\n                // Re-add global scope\r\n                this.scopes.set(globalScopeId, this.globalScope);\r\n                this.currentScope = globalScopeId;\r\n\r\n                // Clear global scope symbols but keep the scope itself\r\n                this.globalScope.symbols.clear();\r\n                this.globalScope.children = [];\r\n\r\n                // Reinitialize built-ins\r\n                this.initializeBuiltins();\r\n            }\r\n\r\n            createScope(kind: ScopeKind, name: string, parentId: ScopeId | null): Scope {\r\n                const scope: Scope = {\r\n                    id: this.idGenerator.next(),\r\n                    kind,\r\n                    name,\r\n                    parent: parentId,\r\n                    children: [],\r\n                    symbols: new Map(),\r\n                    level: parentId ? this.getScope(parentId).level + 1 : 0\r\n                };\r\n\r\n                this.scopes.set(scope.id, scope);\r\n\r\n                if (parentId) {\r\n                    const parent = this.getScope(parentId);\r\n                    parent.children.push(scope.id);\r\n                }\r\n\r\n                return scope;\r\n            }\r\n\r\n            withScope<T>(scopeId: ScopeId, fn: () => T): T {\r\n                const previousScope = this.currentScope;\r\n\r\n                if (!this.scopes.has(scopeId)) {\r\n                    throw new Error(`Cannot switch to non-existent scope ${scopeId}`);\r\n                }\r\n\r\n                this.debugManager?.log('verbose',\r\n                    `→ Entering scope ${scopeId} (${this.getScope(scopeId).name}) from ${previousScope}`\r\n                );\r\n\r\n                this.currentScope = scopeId;\r\n\r\n                try {\r\n                    return fn();\r\n                } finally {\r\n                    this.debugManager?.log('verbose',\r\n                        `← Restoring scope ${previousScope} from ${scopeId}`\r\n                    );\r\n                    this.currentScope = previousScope;\r\n                }\r\n            }\r\n\r\n\r\n        // └──────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌──────────────────────────────── MAIN ────────────────────────────────┐\r\n\r\n            /**\r\n             * Find a scope by name, optionally filtered by kind.\r\n             * @param name - The scope name to search for\r\n             * @param kind - Optional: Filter by scope kind\r\n             * @param parentScopeId - Optional: Search only within this parent scope's children\r\n             */\r\n            findScopeByName(name: string, kind?: ScopeKind, parentScopeId?: ScopeId): Scope | null {\r\n                if (parentScopeId !== undefined) {\r\n                    // Search only in children of specified parent\r\n                    const parentScope = this.getScope(parentScopeId);\r\n                    for (const childId of parentScope.children) {\r\n                        const childScope = this.getScope(childId);\r\n                        if (childScope.name === name && (!kind || childScope.kind === kind)) {\r\n                            return childScope;\r\n                        }\r\n                    }\r\n                    return null;\r\n                }\r\n\r\n                // Global search through all scopes\r\n                for (const scope of this.scopes.values()) {\r\n                    if (scope.name === name && (!kind || scope.kind === kind)) {\r\n                        return scope;\r\n                    }\r\n                }\r\n                return null;\r\n            }\r\n\r\n            /**\r\n             * Find a child scope of the current scope by name.\r\n             */\r\n            findChildScopeByName(name: string, kind?: ScopeKind): Scope | null {\r\n                return this.findScopeByName(name, kind, this.currentScope);\r\n            }\r\n\r\n            /**\r\n             * Find a child scope by name from a specific parent scope.\r\n             */\r\n            findChildScopeByNameFromId(name: string, scopeId: ScopeId, kind?: ScopeKind): Scope | null {\r\n                return this.findScopeByName(name, kind, scopeId);\r\n            }\r\n\r\n        // └──────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌─────────────────────────── SCOPE ACCESSORS ──────────────────────────┐\r\n\r\n\r\n            getSymbolInCurrentScope(name: string): Symbol | null {\r\n                const currentScope = this.getScope(this.currentScope);\r\n                return currentScope.symbols.get(name) || null;\r\n            }\r\n\r\n            getScopeParent(scopeId: ScopeId): Scope | null {\r\n                const scope = this.getScope(scopeId);\r\n                return scope.parent !== null ? this.getScope(scope.parent) : null;\r\n            }\r\n\r\n            getScope(id: ScopeId): Scope {\r\n                const scope = this.scopes.get(id);\r\n                if (!scope) {\r\n                    throw new Error(`Scope ${id} not found`);\r\n                }\r\n                return scope;\r\n            }\r\n\r\n            getAllSymbols(): Symbol[] {\r\n                return Array.from(this.symbolTable.values());\r\n            }\r\n\r\n            getSymbol(id: SymbolId): Symbol {\r\n                const symbol = this.symbolTable.get(id);\r\n                if (!symbol) {\r\n                    throw new Error(`Symbol ${id} not found`);\r\n                }\r\n                return symbol;\r\n            }\r\n\r\n            getCurrentScope(): Scope {\r\n                return this.getScope(this.currentScope);\r\n            }\r\n\r\n            getGlobalScope(): Scope {\r\n                return this.globalScope;\r\n            }\r\n\r\n            getAllScopes(): Scope[] {\r\n                return Array.from(this.scopes.values());\r\n            }\r\n\r\n            setCurrentScope(scopeId: ScopeId): void {\r\n                if (!this.scopes.has(scopeId)) {\r\n                    throw new Error(`Scope ${scopeId} does not exist`);\r\n                }\r\n                this.currentScope = scopeId;\r\n            }\r\n\r\n            addSymbolToScope(symbol: Symbol, scopeId: ScopeId): void {\r\n                const scope = this.getScope(scopeId);\r\n                scope.symbols.set(symbol.name, symbol);\r\n                this.symbolTable.set(symbol.id, symbol);\r\n            }\r\n\r\n        // └──────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌────────────────────────── SCOPE NAVIGATION ──────────────────────────┐\r\n\r\n            enterScope(kind: ScopeKind, name: string): ScopeId {\r\n                const scope = this.createScope(kind, name, this.currentScope);\r\n                this.currentScope = scope.id;\r\n                return scope.id;\r\n            }\r\n\r\n            exitScope(): ScopeId | null {\r\n                const current = this.getScope(this.currentScope);\r\n                if (current.parent !== null) {\r\n                    const parentId = current.parent;\r\n                    this.currentScope = parentId;\r\n                    return parentId;\r\n                }\r\n                return null;\r\n            }\r\n\r\n        // └──────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌────────────────────────── SCOPE DEFINITION ──────────────────────────┐\r\n\r\n            defineSymbol(name: string, kind: SymbolKind, opts: {\r\n                type?: AST.TypeNode,\r\n                visibility?: AST.VisibilityInfo,\r\n                mutability?: AST.MutabilityInfo,\r\n                namespace?: string,\r\n                metadata?: Symbol['metadata'],\r\n                typeInfo?: Symbol['typeInfo'],\r\n                span?: AST.Span\r\n            }): SymbolId {\r\n                const symbol: Symbol = {\r\n                    id: this.symbolIdGenerator.next(),\r\n                    name,\r\n                    kind,\r\n                    type: opts.type || null,\r\n                    scope: this.currentScope,\r\n                    contextSpan: opts.span || { start: 0, end: 0 },\r\n                    declared: true,\r\n                    initialized: false,\r\n                    used: false,\r\n                    isTypeChecked: false,\r\n                    visibility: opts.visibility || { kind: 'Private' },\r\n                    mutability: opts.mutability || { kind: 'Immutable' },\r\n                    namespace: opts.namespace,\r\n                    metadata: opts.metadata,\r\n                    typeInfo: opts.typeInfo,\r\n                    isExported: false\r\n                };\r\n\r\n                const scope = this.getScope(this.currentScope);\r\n                scope.symbols.set(name, symbol);\r\n                this.symbolTable.set(symbol.id, symbol);\r\n\r\n                // Add to namespace lookup if in a namespace\r\n                if (opts.namespace) {\r\n                    const nsSymbols = this.namespaceLookup.get(opts.namespace) || new Set();\r\n                    nsSymbols.add(symbol.id);\r\n                    this.namespaceLookup.set(opts.namespace, nsSymbols);\r\n                }\r\n\r\n                return symbol.id;\r\n            }\r\n\r\n            resolveSymbol(name: string, opts: {\r\n                currentScopeOnly?: boolean,\r\n                includeParents?: boolean,\r\n                namespace?: string\r\n            } = {}): Symbol | null {\r\n                // Check namespace first if specified\r\n                if (opts.namespace) {\r\n                    const nsSymbols = this.namespaceLookup.get(opts.namespace);\r\n                    if (nsSymbols) {\r\n                        for (const symbolId of nsSymbols) {\r\n                            const symbol = this.symbolTable.get(symbolId);\r\n                            if (symbol && symbol.name === name) {\r\n                                return symbol;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // Regular scope-based lookup\r\n                let scope : Scope | null = this.getScope(this.currentScope);\r\n\r\n                do {\r\n                    const symbol = scope.symbols.get(name);\r\n                    if (symbol) {\r\n                        return symbol;\r\n                    }\r\n\r\n                    if (opts.currentScopeOnly) {\r\n                        break;\r\n                    }\r\n\r\n                    scope = scope.parent !== null ? this.getScope(scope.parent) : null;\r\n                } while (scope && (opts.includeParents ?? true));\r\n\r\n                return null;\r\n            }\r\n\r\n        // └──────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌────────────────────────────── BUILTINS ──────────────────────────────┐\r\n\r\n            private initializeBuiltins(): void {\r\n                // Functions\r\n                this.createBuiltinSymbol(SymbolKind.Function, '@print', {\r\n                    type: AST.TypeNode.asFunction({start: 0, end: 0}, [\r\n                            AST.TypeNode.asU8Array({start: 0, end: 0})\r\n                    ], AST.TypeNode.asVoid({start: 0, end: 0})),\r\n                    callable: true\r\n                });\r\n\r\n                // Types\r\n                this.createBuiltinSymbol(SymbolKind.Definition, 'slice', {\r\n                    type: AST.TypeNode.asU8Array({start: 0, end: 0})\r\n                });\r\n                this.createBuiltinSymbol(SymbolKind.Definition, 'char', {\r\n                    type: AST.TypeNode.asUnsigned({start: 0, end: 0}, 'u8', 8)\r\n                });\r\n                this.createBuiltinSymbol(SymbolKind.Definition, 'cpoint', {\r\n                    type: AST.TypeNode.asUnsigned({start: 0, end: 0}, 'u21', 21)\r\n                });\r\n                this.createBuiltinSymbol(SymbolKind.Definition, 'usize', {\r\n                    type: AST.TypeNode.asUnsigned({start: 0, end: 0}, 'usize', 64)\r\n                });\r\n                this.createBuiltinSymbol(SymbolKind.Definition, 'isize', {\r\n                    type: AST.TypeNode.asSigned({start: 0, end: 0}, 'isize', 64)\r\n                });\r\n            }\r\n\r\n            private createBuiltinSymbol(\r\n                kind: SymbolKind,\r\n                name: string,\r\n                options: { type: AST.TypeNode | null; callable?: boolean }\r\n            ): Symbol {\r\n                const symbol: Symbol = {\r\n                    id: this.symbolIdGenerator.next(),\r\n                    kind,\r\n                    name,\r\n                    contextSpan: { start: 0, end: 0 },\r\n                    scope: this.globalScope.id,\r\n                    visibility: { kind: 'Public' },\r\n                    mutability: { kind: 'Immutable'},\r\n                    type: options.type,\r\n                    used: false,\r\n                    initialized: true,\r\n                    declared: true,\r\n                    isTypeChecked: true,\r\n                    isExported: false,\r\n                    metadata: {\r\n                        callable: options.callable || false,\r\n                        isBuiltin: true\r\n                    }\r\n                };\r\n\r\n                this.globalScope.symbols.set(name, symbol);\r\n                this.symbolTable.set(symbol.id, symbol);\r\n\r\n                return symbol;\r\n            }\r\n\r\n        // └──────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌─────────────────────────── SYMBOL MARKERS ───────────────────────────┐\r\n\r\n            markSymbolUsed(symbolId: SymbolId): void {\r\n                const symbol = this.getSymbol(symbolId);\r\n                symbol.used = true;\r\n            }\r\n\r\n            markSymbolInitialized(symbolId: SymbolId): void {\r\n                const symbol = this.getSymbol(symbolId);\r\n                symbol.initialized = true;\r\n            }\r\n\r\n            markSymbolTypeChecked(symbolId: SymbolId): void {\r\n                const symbol = this.getSymbol(symbolId);\r\n                symbol.isTypeChecked = true;\r\n            }\r\n\r\n            setSymbolType(symbolId: SymbolId, type: AST.TypeNode): void {\r\n                const symbol = this.getSymbol(symbolId);\r\n                symbol.type = type;\r\n            }\r\n\r\n        // └──────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌───────────────────────── NAMESPACE QUERIES ──────────────────────────┐\r\n\r\n            getAllSymbolsInScope(scopeId: ScopeId): Symbol[] {\r\n                const scope = this.getScope(scopeId);\r\n                return Array.from(scope.symbols.values());\r\n            }\r\n\r\n        // └──────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌────────────────────────── SYMBOL LOOKUP ─────────────────────────────┐\r\n\r\n            /**\r\n             * Look up a symbol in the current scope chain.\r\n             * Prioritizes symbols from the current module before checking imported symbols.\r\n             */\r\n            lookupSymbol(name: string): Symbol | null {\r\n                return this.lookupSymbolInScopeChain(name, this.currentScope);\r\n            }\r\n\r\n            /**\r\n             * Walk up scope chain with module boundary awareness.\r\n             * This prevents symbols from other modules from shadowing local definitions.\r\n             */\r\n            lookupSymbolInScopeChain(name: string, scopeId: ScopeId): Symbol | null {\r\n                let scope: Scope | null = this.getScope(scopeId);\r\n                let currentModuleScope: Scope | null = null;\r\n\r\n                // STEP 1: Find which module we're currently in\r\n                let checkScope: Scope | null = scope;\r\n                while (checkScope) {\r\n                    if (checkScope.kind === ScopeKind.Module) {\r\n                        currentModuleScope = checkScope;\r\n                        break;\r\n                    }\r\n                    checkScope = checkScope.parent !== null ? this.getScope(checkScope.parent) : null;\r\n                }\r\n\r\n                // STEP 2: Search ONLY within the current module first\r\n                if (currentModuleScope) {\r\n                    checkScope = scope;\r\n                    while (checkScope && checkScope.id !== currentModuleScope.id) {\r\n                        const symbol = checkScope.symbols.get(name);\r\n                        if (symbol) {\r\n                            return symbol; // Found in current scope chain\r\n                        }\r\n                        checkScope = checkScope.parent !== null ? this.getScope(checkScope.parent) : null;\r\n                    }\r\n\r\n                    // Check the module scope itself\r\n                    const moduleSymbol = currentModuleScope.symbols.get(name);\r\n                    if (moduleSymbol) {\r\n                        return moduleSymbol; // Found in module scope\r\n                    }\r\n\r\n                    // STEP 3: Check child Type scopes (for struct/enum definitions)\r\n                    for (const childId of currentModuleScope.children) {\r\n                        const childScope = this.getScope(childId);\r\n                        if (childScope.kind === ScopeKind.Type && childScope.name === name) {\r\n                            // This is a type definition - return its symbol from the module scope\r\n                            return currentModuleScope.symbols.get(name) || null;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // STEP 4: Only check global scope for imports and built-ins\r\n                if (this.globalScope) {\r\n                    const globalSymbol = this.globalScope.symbols.get(name);\r\n                    if (globalSymbol) {\r\n                        // Only return if it's a Use (import) or built-in\r\n                        if (globalSymbol.kind === SymbolKind.Use ||\r\n                            globalSymbol.metadata?.isBuiltin) {\r\n                            return globalSymbol;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                return null; // Not found anywhere\r\n            }\r\n\r\n            lookupSymbolInParentScopes(name: string, startingScopeId: ScopeId): Symbol | null {\r\n                let scope: Scope | null = this.getScope(startingScopeId);\r\n                while (scope) {\r\n                    const symbol = scope.symbols.get(name);\r\n                    if (symbol) {\r\n                        return symbol;\r\n                    }\r\n                    scope = scope.parent !== null ? this.getScope(scope.parent) : null;\r\n                }\r\n                return null;\r\n            }\r\n\r\n        // └──────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌─────────────────────────── LSP SUPPORT ──────────────────────────────┐\r\n\r\n            /**\r\n             * Look up a symbol from LSP position information.\r\n             * This finds the narrowest scope at the given span and searches for the symbol.\r\n             *\r\n             * @param word - The identifier to search for\r\n             * @param position_span - The span where the hover/completion was requested\r\n             * @param moduleName - Optional: The name of the module to restrict search to\r\n             * @returns The symbol if found, null otherwise\r\n             */\r\n            lookupSymbolFromLSP(word: string, position_span: AST.Span, moduleName?: string): Symbol | null {\r\n                this.debugManager?.log('verbose',\r\n                    `LSP lookup for \"${word}\" at span ${JSON.stringify(position_span)}${moduleName ? ` in module \"${moduleName}\"` : ''}`\r\n                );\r\n\r\n                // STEP 1: If module name provided, find that specific module scope\r\n                let searchScope: Scope | null = null;\r\n\r\n                if (moduleName) {\r\n                    // Find the module scope by name\r\n                    for (const scope of this.scopes.values()) {\r\n                        if (scope.kind === ScopeKind.Module && scope.name === moduleName) {\r\n                            searchScope = scope;\r\n                            this.debugManager?.log('verbose', `Restricted search to module: ${moduleName} (id: ${scope.id})`);\r\n                            break;\r\n                        }\r\n                    }\r\n\r\n                    if (!searchScope) {\r\n                        this.debugManager?.log('errors', `Module \"${moduleName}\" not found`);\r\n                        return null;\r\n                    }\r\n\r\n                    // Check if position is within an import statement first\r\n                    const importSymbol = this.findImportAtPosition(position_span, searchScope);\r\n                    if (importSymbol) {\r\n                        this.debugManager?.log('verbose', `Position is within import statement, resolving to source symbol`);\r\n                        return this.resolveSymbolThroughImports(importSymbol);\r\n                    }\r\n\r\n                    // Within the module, find the narrowest scope at the position\r\n                    const narrowestScope = this.findNarrowestScopeAtPosition(position_span, searchScope.id);\r\n                    searchScope = narrowestScope || searchScope;\r\n                } else {\r\n                    // No module specified - use original behavior\r\n                    searchScope = this.findNarrowestScopeAtPosition(position_span);\r\n                }\r\n\r\n                if (!searchScope) {\r\n                    this.debugManager?.log('verbose', `No scope found at position`);\r\n                    return null;\r\n                }\r\n\r\n                this.debugManager?.log('verbose',\r\n                    `Found search scope: ${searchScope.name} (kind: ${searchScope.kind}, id: ${searchScope.id})`\r\n                );\r\n\r\n                // STEP 2: Search for the symbol starting from the search scope\r\n                const symbol = this.lookupSymbolInScopeChain(word, searchScope.id);\r\n\r\n                if (!symbol) {\r\n                    this.debugManager?.log('verbose', `Symbol \"${word}\" not found in scope chain`);\r\n                    return null;\r\n                }\r\n\r\n                this.debugManager?.log('verbose', `Found symbol: ${symbol.name} (kind: ${symbol.kind})`);\r\n\r\n                // Check if cursor is on the import statement itself or on usage\r\n                if (symbol.kind === SymbolKind.Use) {\r\n                    const isOnImportStatement = this.isPositionOnSymbolDefinition(position_span, symbol);\r\n\r\n                    if (isOnImportStatement) {\r\n                        this.debugManager?.log('verbose', `Position is ON import statement, returning Use symbol`);\r\n                        return symbol; // Show the import itself\r\n                    } else {\r\n                        this.debugManager?.log('verbose', `Position is on USAGE of imported symbol, resolving to source`);\r\n                        return this.resolveSymbolThroughImports(symbol); // Show what it imports\r\n                    }\r\n                }\r\n\r\n                return symbol;\r\n            }\r\n\r\n            /**\r\n            * Public method to get symbol at a specific position (used by LSP).\r\n            * This checks if the position directly points to a symbol definition.\r\n            */\r\n            getSymbolAtPosition(position: AST.Span): Symbol | null {\r\n                // First, try to find if the position directly points to a symbol\r\n                for (const symbol of this.symbolTable.values()) {\r\n                    const targetSpan = symbol.targetSpan || symbol.contextSpan;\r\n\r\n                    // Check if position is exactly on this symbol\r\n                    if (position.start >= targetSpan.start && position.start <= targetSpan.end) {\r\n                        this.debugManager?.log('verbose', `Found symbol directly at position: ${symbol.name}`);\r\n                        return symbol;\r\n                    }\r\n                }\r\n\r\n                return null;\r\n            }\r\n\r\n            /**\r\n             * Find if the position is within an import statement.\r\n             * Returns the Use symbol if position is within any import's contextSpan.\r\n             */\r\n            private findImportAtPosition(position: AST.Span, scope: Scope): Symbol | null {\r\n                // Check all symbols in this scope for Use symbols\r\n                for (const symbol of scope.symbols.values()) {\r\n                    if (symbol.kind === SymbolKind.Use) {\r\n                        const contextSpan = symbol.contextSpan;\r\n                        // Check if position is within this import statement\r\n                        if (position.start >= contextSpan.start && position.start <= contextSpan.end) {\r\n                            this.debugManager?.log('verbose',\r\n                                `Found position within import: ${symbol.name} (alias: ${symbol.importAlias || 'none'})`\r\n                            );\r\n                            return symbol;\r\n                        }\r\n                    }\r\n                }\r\n                return null;\r\n            }\r\n\r\n            /**\r\n             * Check if the position is on the symbol's definition/declaration.\r\n             * Returns true if hovering on where the symbol is defined, false if hovering on usage.\r\n             */\r\n            private isPositionOnSymbolDefinition(position: AST.Span, symbol: Symbol): boolean {\r\n                // For Use symbols, check BOTH targetSpan and contextSpan\r\n                // because the import statement spans across \"use x from ...\"\r\n                if (symbol.kind === SymbolKind.Use) {\r\n                    const contextSpan = symbol.contextSpan;\r\n                    const isInContext = position.start >= contextSpan.start && position.start <= contextSpan.end;\r\n                    return isInContext;\r\n                }\r\n\r\n                // For other symbols, check target span only\r\n                const targetSpan = symbol.targetSpan || symbol.contextSpan;\r\n                return position.start >= targetSpan.start && position.start <= targetSpan.end;\r\n            }\r\n\r\n            /**\r\n             * Resolve a symbol through imports to get the actual underlying symbol.\r\n             * If the symbol is a Use (import), this follows the chain to find the real definition.\r\n             */\r\n            private resolveSymbolThroughImports(symbol: Symbol): Symbol {\r\n                // If not an import, return as-is\r\n                if (symbol.kind !== SymbolKind.Use) {\r\n                    return symbol;\r\n                }\r\n\r\n                console.log(`[ScopeManager] Resolving import symbol: ${symbol.name} (alias: ${symbol.importAlias || 'none'})`);\r\n\r\n                // Try to find the source symbol by ID\r\n                if (symbol.sourceSymbol) {\r\n                    const sourceSymbol = this.symbolTable.get(symbol.sourceSymbol);\r\n                    if (sourceSymbol) {\r\n                        console.log(`[ScopeManager] Resolved via sourceSymbol ID to: ${sourceSymbol.name} (${sourceSymbol.kind}) in module ${sourceSymbol.module}`);\r\n                        return sourceSymbol;\r\n                    }\r\n                }\r\n\r\n                // Fallback: Search by import information\r\n                if (symbol.importSource) {\r\n                    console.log(`[ScopeManager] Searching in module \"${symbol.importSource}\"`);\r\n\r\n                    // The original imported name might be different from symbol.name if there's an alias\r\n                    // If symbol has an alias, we need to find what the original name was\r\n                    // For \"use x as y\", symbol.name is \"y\", but we need to search for \"x\" in the source module\r\n\r\n                    // Find the source module scope\r\n                    for (const scope of this.scopes.values()) {\r\n                        if (scope.kind === ScopeKind.Module && scope.name === symbol.importSource) {\r\n                            console.log(`[ScopeManager] Found source module scope: ${scope.name}`);\r\n\r\n                            // If there's an alias, the original name should be stored somewhere\r\n                            // Check metadata for original name\r\n                            const originalName = symbol.metadata?.originalImportName as string | undefined;\r\n                            const searchName = originalName || symbol.name;\r\n\r\n                            console.log(`[ScopeManager] Looking for symbol \"${searchName}\" in source module`);\r\n\r\n                            // Look for the symbol in that module\r\n                            const sourceSymbol = scope.symbols.get(searchName);\r\n                            if (sourceSymbol && sourceSymbol.kind !== SymbolKind.Use) {\r\n                                console.log(`[ScopeManager] Found source symbol: ${sourceSymbol.name} (${sourceSymbol.kind})`);\r\n                                return sourceSymbol;\r\n                            }\r\n\r\n                            // If not found with that name, try all exported symbols\r\n                            console.log(`[ScopeManager] Symbol not found directly, checking all exported symbols`);\r\n                            for (const [name, sym] of scope.symbols.entries()) {\r\n                                if (sym.isExported && sym.kind !== SymbolKind.Use) {\r\n                                    console.log(`[ScopeManager]   - Found exported: ${name} (${sym.kind})`);\r\n                                    // For now, if there's an alias but we can't find the original, return first exported\r\n                                    if (originalName === name || (!originalName && name === symbol.name)) {\r\n                                        return sym;\r\n                                    }\r\n                                }\r\n                            }\r\n\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // If we can't resolve, return the import symbol itself\r\n                console.log(`[ScopeManager] Could not resolve import, returning import symbol`);\r\n                return symbol;\r\n            }\r\n\r\n            /**\r\n             * Find the narrowest (most specific) scope that contains the given position.\r\n             * This walks the scope tree depth-first to find the deepest scope containing the position.\r\n             *\r\n             * @param position - The position to search for\r\n             * @param rootScopeId - Optional: Start search from this scope instead of global\r\n             */\r\n            private findNarrowestScopeAtPosition(position: AST.Span, rootScopeId?: ScopeId): Scope | null {\r\n                let narrowestScope: Scope | null = null;\r\n                let maxDepth = -1;\r\n\r\n                // Helper to check if a span contains a position\r\n                const spanContainsPosition = (scopeSpan: AST.Span | undefined, pos: AST.Span): boolean => {\r\n                    if (!scopeSpan) return false;\r\n\r\n                    // Position is within scope if it's between scope's start and end\r\n                    return pos.start >= scopeSpan.start && pos.end <= scopeSpan.end;\r\n                };\r\n\r\n                // Helper to check if scope contains symbols near the position\r\n                const scopeContainsSymbolsNearPosition = (scope: Scope, pos: AST.Span): boolean => {\r\n                    for (const symbol of scope.symbols.values()) {\r\n                        const symbolSpan = symbol.targetSpan || symbol.contextSpan;\r\n\r\n                        // Check if symbol is close to or contains the position\r\n                        if (Math.abs(symbolSpan.start - pos.start) < 1000 || // Within 1000 chars\r\n                            spanContainsPosition(symbolSpan, pos)) {\r\n                            return true;\r\n                        }\r\n                    }\r\n                    return false;\r\n                };\r\n\r\n                // Recursive function to search scopes\r\n                const searchScope = (scopeId: ScopeId, depth: number) => {\r\n                    const scope = this.getScope(scopeId);\r\n\r\n                    // Check if this scope contains the position\r\n                    const scopeSpan = scope.metadata?.span as AST.Span | undefined;\r\n\r\n                    let containsPosition = false;\r\n\r\n                    if (scopeSpan) {\r\n                        containsPosition = spanContainsPosition(scopeSpan, position);\r\n                    } else if (scope.kind === ScopeKind.Module) {\r\n                        // For module scopes, check if they have symbols near this position\r\n                        containsPosition = scopeContainsSymbolsNearPosition(scope, position);\r\n                    } else {\r\n                        // For other scopes, check if any symbols contain the position\r\n                        for (const symbol of scope.symbols.values()) {\r\n                            if (spanContainsPosition(symbol.contextSpan, position) ||\r\n                                (symbol.targetSpan && spanContainsPosition(symbol.targetSpan, position))) {\r\n                                containsPosition = true;\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    if (containsPosition && depth > maxDepth) {\r\n                        narrowestScope = scope;\r\n                        maxDepth = depth;\r\n                    }\r\n\r\n                    // Search children regardless (they might be more specific)\r\n                    for (const childId of scope.children) {\r\n                        searchScope(childId, depth + 1);\r\n                    }\r\n                };\r\n\r\n                // Start search from specified scope or global scope\r\n                const startScopeId = rootScopeId ?? this.globalScope.id;\r\n                searchScope(startScopeId, 0);\r\n\r\n                // If we found no scope, try to find by analyzing all symbols (within root scope)\r\n                if (!narrowestScope) {\r\n                    console.log(`[ScopeManager] No scope found via tree search, searching by symbol proximity`);\r\n                    narrowestScope = this.findScopeBySymbolProximity(position, rootScopeId);\r\n                }\r\n\r\n                // Final fallback: return the root scope\r\n                if (!narrowestScope) {\r\n                    console.log(`[ScopeManager] Using root scope as final fallback`);\r\n                    narrowestScope = rootScopeId ? this.getScope(rootScopeId) : this.globalScope;\r\n                }\r\n\r\n                return narrowestScope;\r\n            }\r\n\r\n            /**\r\n             * Find scope by symbol proximity - looks for symbols closest to position.\r\n             * This is used as a fallback when scope span information is not available.\r\n             *\r\n             * @param position - The position to search near\r\n             * @param rootScopeId - Optional: Restrict search to this scope and its children\r\n             */\r\n            private findScopeBySymbolProximity(position: AST.Span, rootScopeId?: ScopeId): Scope | null {\r\n                let bestMatch: { scope: Scope; distance: number; symbol: Symbol } | null = null;\r\n\r\n                console.log(`[ScopeManager] Searching by symbol proximity for position ${position.start}-${position.end}${rootScopeId ? ` within scope ${rootScopeId}` : ''}`);\r\n\r\n                // Helper to check if scope is within the root scope tree\r\n                const isWithinRootScope = (scope: Scope): boolean => {\r\n                    if (!rootScopeId) return true; // No restriction\r\n\r\n                    let current: Scope | null = scope;\r\n                    while (current) {\r\n                        if (current.id === rootScopeId) return true;\r\n                        current = current.parent !== null ? this.getScope(current.parent) : null;\r\n                    }\r\n                    return false;\r\n                };\r\n\r\n                // Search all module and function scopes\r\n                for (const scope of this.scopes.values()) {\r\n                    // Skip global scope\r\n                    if (scope.kind === ScopeKind.Global) continue;\r\n\r\n                    // If rootScopeId specified, only search within that scope tree\r\n                    if (rootScopeId && !isWithinRootScope(scope)) {\r\n                        continue;\r\n                    }\r\n\r\n                    // Prioritize Module and Function scopes\r\n                    if (scope.kind === ScopeKind.Module || scope.kind === ScopeKind.Function) {\r\n                        for (const symbol of scope.symbols.values()) {\r\n                            const symbolSpan = symbol.contextSpan;\r\n\r\n                            // If position is within this symbol's context span, this is likely the right scope\r\n                            if (position.start >= symbolSpan.start && position.start <= symbolSpan.end) {\r\n                                console.log(`[ScopeManager] Found scope by direct containment: ${scope.name} (symbol: ${symbol.name})`);\r\n                                return scope;\r\n                            }\r\n\r\n                            // Calculate distance from position to symbol\r\n                            const distance = Math.abs(symbolSpan.start - position.start);\r\n\r\n                            // Track the closest symbol (likely in the same scope as our position)\r\n                            if (!bestMatch || distance < bestMatch.distance) {\r\n                                bestMatch = { scope, distance, symbol };\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (bestMatch) {\r\n                    console.log(`[ScopeManager] Found scope by proximity: ${bestMatch.scope.name} (closest symbol: ${bestMatch.symbol.name}, distance: ${bestMatch.distance})`);\r\n                    return bestMatch.scope;\r\n                }\r\n\r\n                return null;\r\n            }\r\n\r\n        // └──────────────────────────────────────────────────────────────────────┘\r\n    }\r\n\r\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// IdGenerator.ts - Simple ID generation utility.\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class IdGenerator {\n\n        private counter = 0;\n\n        next(): number {\n            return ++this.counter;\n        }\n\n        reset(): void {\n            this.counter = 0;\n        }\n\n        current(): number {\n            return this.counter;\n        }\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// SymbolCollector.ts – Symbol collection Phase.\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import * as AST                 from '@je-es/ast';\n    import { AnalysisPhase }        from '../components/ContextTracker';\n    import { DiagCode, DiagKind }   from '../components/DiagnosticManager';\n    import { Scope, Symbol, SymbolKind, ScopeKind }\n                                    from '../components/ScopeManager';\n    import { PathUtils }            from '../utils/PathUtils';\n    import { PhaseBase }            from '../interfaces/PhaseBase';\n    import { AnalysisConfig }       from '../ast-analyzer';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ TYPE ════════════════════════════════════════╗\n\n    interface PathResolutionContext {\n        rootPath                    ?: string;\n        currentModulePath           ?: string;\n        pathMappings                : Map<string, string>;\n    }\n\n    interface CollectionStats {\n        modulesProcessed            : number;\n        symbolsCollected            : number;\n        importResolutionFailures    : number;\n        scopesCreated               : number;\n        startTime                   : number;\n        syntheticSymbolsInjected    : number;\n    }\n\n    interface TypeCollectionContext {\n        visitedTypes                : Set<string>;\n        currentTypePath             : string[];\n        nestingDepth                : number;\n        maxNestingDepth             : number;\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class SymbolCollector extends PhaseBase {\n\n        // ┌──────────────────────────────── INIT ────────────────────────────────┐\n\n            private pathContext     : PathResolutionContext     = { pathMappings: new Map() };\n            private stats           : CollectionStats           = this.initStats();\n            private typeContext     : TypeCollectionContext     = this.initTypeContext();\n            private typeRegistry    : Map<string, Symbol> = new Map();\n            private moduleExports   : Map<string, Set<string>> = new Map(); // moduleName -> exported symbol names\n\n            constructor( config : AnalysisConfig ) {\n                super(AnalysisPhase.Collection, config);\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ────────────────────────────────┐\n\n            handle(): boolean {\n                try {\n                    this.log('verbose', 'Starting symbol collection phase...');\n                    this.stats.startTime = Date.now();\n\n                    if (!this.init()) { return false; }\n                    if (!this.buildPathMappings()) { return false; }\n                    if (!this.collectAllModules()) { return false; }\n\n                    this.logStatistics();\n                    return !this.config.services.diagnosticManager.hasErrors();\n\n                } catch (error) {\n                    this.log('errors', `Fatal error during symbol collection: ${error}`);\n                    this.reportError( DiagCode.INTERNAL_ERROR, `Fatal error during symbol collection: ${error}` );\n                    return false;\n                }\n            }\n\n            reset(): void {\n                this.pathContext    = { pathMappings: new Map() };\n                this.stats          = this.initStats();\n                this.typeContext    = this.initTypeContext();\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌────────────────────────── [1] Program Level ─────────────────────────┐\n\n            private buildPathMappings(): boolean {\n                this.log('verbose', 'Building module path mappings...');\n                this.pathContext.pathMappings.clear();\n\n                const rootPath = this.config.program!.metadata?.path as string | undefined;\n                if (!rootPath) {\n                    this.reportWarning( DiagCode.MODULE_NOT_FOUND, 'No root path found in program metadata' );\n                    return false; // stop immediately\n                }\n\n                this.pathContext.rootPath = rootPath;\n\n                for (const [moduleName, module] of this.config.program!.modules) {\n                    const modulePath = module.metadata?.path as string | undefined;\n                    if (!modulePath) {\n                        this.reportWarning( DiagCode.MODULE_NOT_FOUND, `No file path found for module ${moduleName}` );\n                        continue;\n                    }\n\n                    try {\n                        const relativePath = PathUtils.getRelativePath(rootPath, modulePath);\n                        const normalizedPath = PathUtils.normalizePath(relativePath);\n\n                        // Detect path collisions\n                        if (this.pathContext.pathMappings.has(normalizedPath)) {\n                            const existing = this.pathContext.pathMappings.get(normalizedPath)!;\n                            if (existing !== moduleName) {\n                                this.reportError(\n                                    DiagCode.MODULE_NOT_FOUND,\n                                    `Path collision: '${normalizedPath}' maps to both '${existing}' and '${moduleName}'`\n                                );\n                                return false; // Stop immediately - invalid program\n                            }\n                        }\n\n                        this.pathContext.pathMappings.set(modulePath, moduleName);\n                        this.pathContext.pathMappings.set(relativePath, moduleName);\n                        this.pathContext.pathMappings.set(normalizedPath, moduleName);\n                        this.log('verbose', `Mapped ${moduleName} -> ${relativePath}`);\n                    } catch (error) {\n                        this.reportWarning( DiagCode.MODULE_NOT_FOUND, `Failed to map module path for ${moduleName}: ${error}` );\n                    }\n                }\n\n                return true;\n            }\n\n            private collectAllModules(): boolean {\n                this.log('verbose', 'Collecting symbols from all modules...');\n                const globalScope = this.config.services.scopeManager.getCurrentScope();\n\n                for (const [moduleName, module] of this.config.program!.modules) {\n                    this.config.services.contextTracker.pushContextSpan({ start: 0, end: 0 });\n                    try {\n                        if (!this.collectModule(moduleName, module, globalScope)) {\n                            if (this.config.services.contextTracker.getCurrentPhase() === AnalysisPhase.Collection) {\n                                this.log('errors', `Failed to collect from module ${moduleName}, continuing...`);\n                            }\n                        }\n                        this.stats.modulesProcessed++;\n                    } finally {\n                        this.config.services.contextTracker.popContextSpan();\n                    }\n                }\n\n                return true;\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌────────────────────────── [2] Module Level ──────────────────────────┐\n\n            private collectModule(moduleName: string, module: AST.Module, parentScope: Scope): boolean {\n                this.log('symbols', `Collecting from module '${moduleName}'`);\n\n                // Reset type context for each module\n                this.typeContext = this.initTypeContext();\n\n                try {\n                    this.config.services.contextTracker.setModuleName(moduleName);\n                    const modulePath = module.metadata?.path as string;\n                    if (modulePath) {\n                        this.config.services.contextTracker.setModulePath(modulePath);\n                        this.pathContext.currentModulePath = modulePath;\n                    }\n\n                    const moduleScope = this.createModuleScope(moduleName, parentScope);\n\n                    // PASS 1: Collect all local definitions FIRST\n                    for (const statement of module.statements) {\n                        if (statement.kind === 'Def' || statement.kind === 'Let' || statement.kind === 'Func') {\n                            this.collectStmt(statement, moduleScope, moduleName);\n                        }\n                    }\n\n                    // PASS 2: Then process imports\n                    for (const statement of module.statements) {\n                        if (statement.kind === 'Use') {\n                            this.collectStmt(statement, moduleScope, moduleName);\n                        }\n                    }\n\n                    // PASS 3: Process everything else\n                    for (const statement of module.statements) {\n                        if (statement.kind !== 'Def' && statement.kind !== 'Let' &&\n                            statement.kind !== 'Func' && statement.kind !== 'Use') {\n                            this.collectStmt(statement, moduleScope, moduleName);\n                        }\n                    }\n\n                    return true;\n\n                } catch (error) {\n                    this.reportError( DiagCode.MODULE_NOT_FOUND, `Failed to collect symbols from module '${moduleName}': ${error}` );\n                    return false;\n                }\n            }\n\n            private createModuleScope(moduleName: string, parentScope: Scope): Scope {\n                const moduleScope = this.config.services.scopeManager.createScope(ScopeKind.Module, moduleName, parentScope.id);\n                this.incrementScopesCreated();\n                this.log('scopes', `Created module scope ${moduleScope.id} for '${moduleName}'`);\n                return moduleScope;\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌─────────────────────────── [3] Stmt Level ───────────────────────────┐\n\n            private collectStmt(stmt: AST.StmtNode, currentScope: Scope, moduleName: string): void {\n                if (!stmt) {\n                    this.reportError(DiagCode.ANALYSIS_ERROR, 'Found null statement during collection');\n                    return;\n                }\n\n                this.log('verbose', `Collecting from ${stmt.kind} statement`);\n                this.config.services.contextTracker.pushContextSpan(stmt.span);\n\n                try {\n                    // Nest withScope and withSavedState for complete safety\n                    this.config.services.scopeManager.withScope(currentScope.id, () => {\n                        this.config.services.contextTracker.withSavedState(() => {\n                            this.config.services.contextTracker.setScope(currentScope.id);\n\n                            this.processStmtByKind(stmt, {\n                                'Block'     : (blockNode) => this.handleBlockStmt(blockNode, currentScope, moduleName),\n                                'Test'      : (testNode)  => this.handleTestStmt(testNode, currentScope, moduleName),\n                                'Use'       : (useNode)   => this.handleUseStmt(useNode, currentScope, moduleName),\n                                'Def'       : (defNode)   => this.handleDefStmt(defNode, currentScope, moduleName),\n                                'Let'       : (letNode)   => this.handleLetStmt(letNode, currentScope, moduleName),\n                                'Func'      : (funcNode)  => this.handleFuncStmt(funcNode, currentScope, moduleName),\n                                'Expression': (exprNode)  => this.collectExpr(exprNode, currentScope, moduleName),\n\n                                // special cases\n                                'While'     : () => this.handleLoopStmt(stmt, currentScope, moduleName),\n                                'Do'        : () => this.handleLoopStmt(stmt, currentScope, moduleName),\n                                'For'       : () => this.handleLoopStmt(stmt, currentScope, moduleName),\n\n                                'Return'    : () => this.handleControlflowStmt(stmt, currentScope, moduleName),\n                                'Defer'     : () => this.handleControlflowStmt(stmt, currentScope, moduleName),\n                                'Throw'     : () => this.handleControlflowStmt(stmt, currentScope, moduleName),\n                            });\n                        });\n                    });\n                } catch (error) {\n                    this.reportError(\n                        DiagCode.ANALYSIS_ERROR,\n                        `Failed to process ${stmt.kind} statement: ${error}`,\n                        stmt.span\n                    );\n                } finally {\n                    this.config.services.contextTracker.popContextSpan();\n                }\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────── [3.1] BLOCK ─────────────────────────────┐\n\n            private handleBlockStmt(blockNode: AST.BlockStmtNode, scope: Scope, moduleName: string): void {\n                this.collectBlockStmt(blockNode, scope, moduleName);\n            }\n\n            private createBlockScope(parentScope: Scope): Scope {\n                const blockScope = this.config.services.scopeManager.createScope(ScopeKind.Block, 'block', parentScope.id);\n                this.incrementScopesCreated();\n                this.log('scopes', `Created block scope ${blockScope.id} under parent ${parentScope.id}`);\n                return blockScope;\n            }\n\n            private collectBlockStmt(blockNode: AST.BlockStmtNode, parentScope: Scope, moduleName: string): void {\n                const blockScope = this.createBlockScope(parentScope);\n\n                this.config.services.scopeManager.withScope(blockScope.id, () => {\n                    this.config.services.contextTracker.withSavedState(() => {\n                        this.config.services.contextTracker.setScope(blockScope.id);\n\n                        for (const stmt of blockNode.stmts) {\n                            this.collectStmt(stmt, blockScope, moduleName);\n                        }\n                    });\n                });\n            }\n\n            private handleTestStmt(testNode: AST.TestStmtNode, scope: Scope, moduleName: string): void {\n                this.collectBlockStmt(testNode.block, scope, moduleName);\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌───────────────────────────── [3.2] USE ──────────────────────────────┐\n\n            private handleUseStmt(useNode: AST.UseStmtNode, scope: Scope, moduleName: string): void {\n                this.collectUseStmt(useNode, scope, moduleName);\n            }\n\n            private createUseSymbol(\n                useNode: AST.UseStmtNode,\n                currentScope: Scope,\n                moduleName: string,\n                targetModuleName?: string,\n            ): Symbol {\n                const symbolName = this.extractImportSymbolName(useNode);\n\n                // Handle wildcard vs specific import spans\n                const targetSpan = useNode.alias\n                    ? useNode.alias.span\n                    : useNode.targetArr\n                        ? useNode.targetArr[useNode.targetArr.length - 1].span\n                        : useNode.span; // Fallback for wildcard without proper span\n\n                const symbol = this.createBaseSymbol(\n                    symbolName,\n                    SymbolKind.Use,\n                    currentScope,\n                    moduleName,\n                    useNode.span,\n                    targetSpan\n                );\n\n                const isModuleScope = currentScope.kind === ScopeKind.Module;\n                const isPublic = useNode.visibility.kind === 'Public';\n\n                // Handle wildcard import metadata\n                const metadata: any = {};\n\n                if (!useNode.targetArr) {\n                    // Wildcard import\n                    metadata.isWildcardImport = true;\n                    metadata.exportedSymbols = targetModuleName\n                        ? Array.from(this.getModuleExports(targetModuleName) || [])\n                        : [];\n                } else if (useNode.targetArr.length > 1) {\n                    // Multi-part member path\n                    metadata.memberPath = useNode.targetArr.map(t => t.name);\n                    metadata.needsFullResolution = true;\n                }\n\n                return {\n                    ...symbol,\n                    initialized     : true,\n                    visibility      : useNode.visibility,\n                    isExported      : isModuleScope && isPublic,\n                    importSource    : targetModuleName,\n                    importPath      : targetModuleName ? useNode.path : undefined,\n                    importAlias     : targetModuleName ? useNode.alias?.name : undefined,\n                    metadata        : Object.keys(metadata).length > 0 ? metadata : undefined,\n                    declared        : false, // ⚠️ Not declared until resolution validates it\n                };\n            }\n\n            private collectUseStmt(useNode: AST.UseStmtNode, currentScope: Scope, moduleName: string): void {\n                this.log('symbols', 'Collecting use statement');\n\n                try {\n                    if (useNode.path) {\n                        this.processModuleImport(useNode, currentScope, moduleName);\n                    } else {\n                        this.processLocalUse(useNode, currentScope, moduleName);\n                    }\n                } catch (error) {\n                    this.reportError( DiagCode.ANALYSIS_ERROR, `Failed to process use statement: ${error}`, useNode.span );\n                }\n            }\n\n            private extractImportSymbolName(useNode: AST.UseStmtNode, allow_alias = true): string {\n                if (allow_alias && useNode.alias) {\n                    return useNode.alias.name;\n                }\n\n                // Handle wildcard import\n                if (!useNode.targetArr) {\n                    // Must have alias for wildcard\n                    if (!useNode.alias) {\n                        this.reportError(\n                            DiagCode.ANALYSIS_ERROR,\n                            `Wildcard import requires an alias (use * as <name> from \"...\")`,\n                            useNode.span\n                        );\n                        return '<invalid>';\n                    }\n                    return useNode.alias.name;\n                }\n\n                const isJustIdent = useNode.targetArr.length === 1;\n\n                if(isJustIdent) {\n                    return useNode.targetArr[0].name;\n                } else {\n                    return useNode.targetArr[useNode.targetArr.length - 1].name;\n                }\n            }\n\n            private processModuleImport(useNode: AST.UseStmtNode, currentScope: Scope, moduleName: string): void {\n                if (!this.config.program! || !useNode.path) {\n                    this.reportError(DiagCode.MODULE_NOT_FOUND, 'Invalid import: missing path', useNode.span);\n                    return;\n                }\n\n                const currentModule = this.config.program!.modules.get(moduleName);\n                const currentModulePath = currentModule?.metadata?.path as string | undefined;\n\n                if (!PathUtils.validatePath(this.config.program!, useNode.path, currentModulePath)) {\n                    this.reportError(DiagCode.MODULE_NOT_FOUND, `Module not found in path '${useNode.path}'`, useNode.pathSpan);\n                    this.stats.importResolutionFailures++;\n                    return;\n                }\n\n                const resolvedPath = PathUtils.resolveModulePath(this.config.program!, useNode.path, currentModulePath);\n                const targetModuleName = PathUtils.findModuleNameByPath(this.config.program!, resolvedPath);\n\n                if (!targetModuleName) {\n                    this.reportError(DiagCode.MODULE_NOT_FOUND, `Could not resolve module name for path: ${useNode.path}`, useNode.span);\n                    this.stats.importResolutionFailures++;\n                    return;\n                }\n\n                const targetModule = this.config.program!.modules.get(targetModuleName);\n                if (!targetModule) {\n                    this.reportError(DiagCode.MODULE_NOT_FOUND, `Target module '${targetModuleName}' not found`, useNode.span);\n                    this.stats.importResolutionFailures++;\n                    return;\n                }\n\n                // Handle wildcard import\n                if (!useNode.targetArr) {\n                    this.processWildcardImport(useNode, targetModule, targetModuleName, currentScope, moduleName);\n                    return;\n                }\n\n                // Existing validation for specific imports\n                if (!this.validateMemberPathInModule(targetModule, useNode.targetArr, useNode)) {\n                    this.reportError(DiagCode.SYMBOL_NOT_FOUND, `Symbol '${useNode.targetArr[0].name}' not found in module '${targetModuleName}'`, useNode.targetArr[0].span);\n                    this.stats.importResolutionFailures++;\n                    return;\n                }\n\n                const symbolName = this.extractImportSymbolName(useNode);\n\n                // Check for duplicate imports\n                const existingImport = currentScope.symbols.get(symbolName);\n                if (existingImport && existingImport.kind === SymbolKind.Use && existingImport.importSource === targetModuleName) {\n                    this.reportWarning(\n                        DiagCode.DUPLICATE_SYMBOL,\n                        `Symbol '${symbolName}' already imported from module '${targetModuleName}'`,\n                        useNode.alias?.span ?? useNode.targetArr[useNode.targetArr.length - 1].span\n                    );\n                }\n\n                if(this.checkForShadowing(symbolName, currentScope, SymbolKind.Use, useNode.alias?.span ?? useNode.targetArr[useNode.targetArr.length - 1].span)) {\n                    return;\n                }\n\n                const rootSymbolName = useNode.targetArr[0].name;\n                if (!this.canImportSymbol(targetModuleName, rootSymbolName)) {\n                    this.reportError(\n                        DiagCode.SYMBOL_NOT_EXPORTED,\n                        `Symbol '${rootSymbolName}' is private in module '${targetModuleName}'`,\n                        useNode.targetArr[0].span\n                    );\n                    this.stats.importResolutionFailures++;\n                    return;\n                }\n\n                const useSymbol = this.createUseSymbol(useNode, currentScope, moduleName, targetModuleName);\n                this.config.services.scopeManager.addSymbolToScope(useSymbol, currentScope.id);\n                this.incrementSymbolsCollected();\n\n                this.log('verbose', `Resolved import ${useNode.path} -> ${targetModuleName}.${useNode.targetArr.map(t => t.name).join('.')}`);\n            }\n\n            private processWildcardImport(\n                useNode: AST.UseStmtNode,\n                targetModule: AST.Module,\n                targetModuleName: string,\n                currentScope: Scope,\n                moduleName: string\n            ): void {\n                if (!useNode.alias) {\n                    this.reportError(\n                        DiagCode.ANALYSIS_ERROR,\n                        `Wildcard import requires an alias (use * as <name> from \"...\")`,\n                        useNode.span\n                    );\n                    return;\n                }\n\n                const aliasName = useNode.alias.name;\n\n                // Check for shadowing\n                if(this.checkForShadowing(aliasName, currentScope, SymbolKind.Use, useNode.alias.span)) {\n                    return;\n                }\n\n                // Get all exported symbols from target module\n                const exports = this.getModuleExports(targetModuleName);\n                if (!exports || exports.size === 0) {\n                    this.reportWarning(\n                        DiagCode.ANALYSIS_ERROR,\n                        `Module '${targetModuleName}' has no exported symbols`,\n                        useNode.span\n                    );\n                }\n\n                // Create a special symbol for the wildcard import\n                const symbol = this.createBaseSymbol(\n                    aliasName,\n                    SymbolKind.Use,\n                    currentScope,\n                    moduleName,\n                    useNode.span,\n                    useNode.alias.span\n                );\n\n                const isModuleScope = currentScope.kind === ScopeKind.Module;\n                const isPublic = useNode.visibility.kind === 'Public';\n\n                const wildcardSymbol: Symbol = {\n                    ...symbol,\n                    initialized     : true,\n                    visibility      : useNode.visibility,\n                    isExported      : isModuleScope && isPublic,\n                    importSource    : targetModuleName,\n                    importPath      : useNode.path,\n                    importAlias     : aliasName,\n                    metadata        : {\n                        isWildcardImport: true,\n                        exportedSymbols: exports ? Array.from(exports) : []\n                    },\n                    declared        : false, // Will be resolved later\n                };\n\n                this.config.services.scopeManager.addSymbolToScope(wildcardSymbol, currentScope.id);\n                this.incrementSymbolsCollected();\n\n                this.log('verbose', `Collected wildcard import from '${targetModuleName}' as '${aliasName}'`);\n            }\n\n            private processLocalUse(useNode: AST.UseStmtNode, currentScope: Scope, moduleName: string): void {\n                // Wildcard not supported for local use\n                if (!useNode.targetArr) {\n                    this.reportError(\n                        DiagCode.ANALYSIS_ERROR,\n                        `Wildcard import not supported for local use. Use 'use * as x from \"path\"' for module imports`,\n                        useNode.span\n                    );\n                    return;\n                }\n\n                const symbolName = this.extractImportSymbolName(useNode);\n\n                if(this.checkForShadowing(symbolName, currentScope, SymbolKind.Use, useNode.alias?.span ?? useNode.targetArr[0].span)) {\n                    return;\n                }\n\n                const useSymbol = this.createUseSymbol(useNode, currentScope, moduleName);\n                this.config.services.scopeManager.addSymbolToScope(useSymbol, currentScope.id);\n                this.incrementSymbolsCollected();\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌───────────────────────────── [3.3] DEF ──────────────────────────────┐\n\n            private handleDefStmt(defNode: AST.DefStmtNode, scope: Scope, moduleName: string): void {\n                this.collectDefStmt(defNode, scope, moduleName);\n            }\n\n            private createDefSymbol(defNode: AST.DefStmtNode, scope: Scope, moduleName: string): Symbol {\n                const symbol = this.createBaseSymbol(\n                    defNode.ident.name,\n                    SymbolKind.Definition,\n                    scope,\n                    moduleName,\n                    defNode.span,\n                    defNode.ident.span\n                );\n\n                const isModuleScope = scope.kind === ScopeKind.Module;\n                const isPublic = defNode.visibility.kind === 'Public';\n\n                return {\n                    ...symbol,\n                    type: defNode.type ?? null,\n                    initialized: true,\n                    visibility: defNode.visibility,\n                    isExported: isModuleScope && isPublic  // Set export flag\n                };\n            }\n\n            private collectDefStmt(defNode: AST.DefStmtNode, scope: Scope, moduleName: string): void {\n                this.log('symbols', `Collecting definition '${defNode.ident.name}'`);\n\n                if(this.checkForShadowing(defNode.ident.name, scope, SymbolKind.Definition, defNode.ident.span)) {\n                    return;\n                }\n\n\n                const symbol = this.createDefSymbol(defNode, scope, moduleName);\n                this.config.services.scopeManager.addSymbolToScope(symbol, scope.id);\n                this.incrementSymbolsCollected();\n\n                this.trackModuleExport(moduleName, defNode.ident.name, symbol.isExported);\n\n                // Register type name for resolution\n                this.typeRegistry.set(defNode.ident.name, symbol);\n\n                this.collectType(defNode.type, scope, moduleName, defNode.ident.name);\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌───────────────────────────── [3.4] LET ──────────────────────────────┐\n\n            private handleLetStmt(letNode: AST.LetStmtNode, scope: Scope, moduleName: string): void {\n                this.collectLetStmt(letNode, scope, moduleName);\n            }\n\n            private createLetSymbol(varNode: AST.LetStmtNode, scope: Scope, moduleName: string): Symbol {\n                const symbol = this.createBaseSymbol(\n                    varNode.field.ident.name,\n                    SymbolKind.Variable,\n                    scope,\n                    moduleName,\n                    varNode.field.span,\n                    varNode.field.ident.span\n                );\n\n                const isModuleScope = scope.kind === ScopeKind.Module;\n                const isPublic = varNode.field.visibility.kind === 'Public'\n\n                return {\n                    ...symbol,\n                    type            : varNode.field.type ?? null,\n                    initialized     : !!varNode.field.initializer,\n                    visibility      : varNode.field.visibility,\n                    mutability      : varNode.field.mutability,\n                    isExported      : isModuleScope && isPublic,\n                    metadata: {\n                        initializer: varNode.field.initializer\n                    }\n                };\n            }\n\n            private collectLetStmt(letNode: AST.LetStmtNode, scope: Scope, moduleName: string): void {\n                this.log('symbols', `Collecting let '${letNode.field.ident.name}'`);\n\n                if(this.checkForShadowing(letNode.field.ident.name, scope, SymbolKind.Variable, letNode.field.ident.span, false)) {\n                    return;\n                }\n\n                this.checkForShadowing(letNode.field.ident.name, scope, SymbolKind.Variable, letNode.field.ident.span, true);\n\n                // Validate error type mutability BEFORE creating symbol\n                if (letNode.field.type) {\n                    if (letNode.field.type.isErr() && letNode.field.mutability.kind === 'Mutable') {\n                        this.reportError(\n                            DiagCode.MUTABILITY_MISMATCH,\n                            `Error values cannot be stored in mutable variables. Use 'let ${letNode.field.ident.name}: err = ...' instead of 'let mut'`,\n                            letNode.field.ident.span\n                        );\n                        return;\n                    }\n                }\n\n                const symbol: Symbol = this.createLetSymbol(letNode, scope, moduleName);\n                this.config.services.scopeManager.addSymbolToScope(symbol, scope.id);\n                this.incrementSymbolsCollected();\n\n                this.trackModuleExport(moduleName, letNode.field.ident.name, symbol.isExported)\n\n                // Handle constructor expressions during collection\n                if (letNode.field.initializer) {\n                    const initType = this.extractTypeFromInitializer(letNode.field.initializer);\n                    if (initType) {\n                        letNode.field.type = initType;\n                        symbol.type = initType;\n\n                        // If it's a struct, collect its type structure\n                        if (initType.isStruct() || initType.isEnum()) {\n                            this.collectType(initType, scope, moduleName, letNode.field.ident.name);\n                        }\n                    }\n                }\n\n                // Handle explicit type annotation\n                if (letNode.field.type) {\n                    this.collectType(letNode.field.type, scope, moduleName, letNode.field.ident.name);\n                }\n\n                // Collect initializer expression (for validation during resolution)\n                if (letNode.field.initializer && !letNode.field.type) {\n                    this.collectExpr(letNode.field.initializer, scope, moduleName);\n                }\n            }\n\n            private extractTypeFromInitializer(expr: AST.ExprNode): AST.TypeNode | null {\n                if (expr.kind !== 'Primary') return null;\n\n                const primary = expr.getPrimary();\n                if (!primary) return null;\n\n                // // Handle character literals\n                // if (primary.kind === 'Literal') {\n                //     const literal = primary.getLiteral();\n                //     if (literal && literal.kind === 'Character') {\n                //         const charValue = literal.value as string;\n\n                //         // Empty character literal - cannot infer without context\n                //         if (charValue.length === 0) {\n                //             return null; // Must be resolved with context in later phases\n                //         }\n\n                //         // Get Unicode code point\n                //         const codePoint = charValue.codePointAt(0) || 0;\n\n                //         // Non-ASCII = cpoint(u21), ASCII = char(u8)\n                //         if (codePoint > 255) {\n                //             return AST.TypeNode.asUnsigned(literal.span, 'u21', 21);\n                //         } else {\n                //             return AST.TypeNode.asUnsigned(literal.span, 'u8', 8);\n                //         }\n                //     }\n                // }\n\n                // Handle anonymous types: struct { x: i32 }, enum { A, B }\n                if (primary.kind === 'Type') {\n                    return primary.getType();\n                }\n\n                // Handle constructor syntax: Point { x: 10, y: 20 }\n                if (primary.kind === 'Object') {\n                    const obj = primary.getObject();\n                    if (!obj || !obj.ident) return null;\n\n                    // Look up the type symbol\n                    const typeSymbol = this.config.services.scopeManager.lookupSymbol(obj.ident.name);\n                    if (!typeSymbol || !typeSymbol.type) return null;\n\n                    // Return the type if it's a struct\n                    if (typeSymbol.type.isStruct()) {\n                        return typeSymbol.type;\n                    }\n                }\n\n                return null;\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌───────────────────────────── [3.5] FUNC ─────────────────────────────┐\n\n            private handleFuncStmt(funcNode: AST.FuncStmtNode, scope: Scope, moduleName: string): void {\n                this.collectFuncStmt(funcNode, scope, moduleName);\n            }\n\n            private determineErrorMode(errorType: AST.TypeNode): 'err-ident' | 'err-group' | 'any-error' | 'self-group' {\n                // CASE 1: Direct 'err' type -> any error\n                if (errorType.isErr()) {\n                    return 'any-error';\n                }\n\n                // CASE 2: Inline error set -> self-group\n                if (errorType.isErrset()) {\n                    return 'self-group';\n                }\n\n                // CASE 3: Identifier -> need to check what it refers to\n                if (errorType.isIdent()) {\n                    const ident = errorType.getIdent()!;\n\n                    // Skip builtin check\n                    if (ident.builtin) {\n                        return 'any-error';\n                    }\n\n                    // Try to find the symbol\n                    const symbol = this.config.services.scopeManager.lookupSymbol(ident.name);\n\n                    if (!symbol) {\n                        return 'any-error'; // Safe fallback - will be validated in resolver\n                    }\n\n                    // Check symbol kind and type\n                    if (symbol.kind === SymbolKind.Variable && symbol.type?.isErr()) {\n                        return 'err-ident'; // let MyErr: err = ...\n                    }\n\n                    if (symbol.kind === SymbolKind.Definition && symbol.type?.isErrset()) {\n                        return 'err-group'; // def ErrGroup = errset{...}\n                    }\n                }\n\n                return 'any-error'; // Safe default\n            }\n\n            private extractSelfGroupErrors(errorType: AST.TypeNode | undefined): string[] | undefined {\n                if (!errorType || !errorType.isErrset()) {\n                    return undefined;\n                }\n\n                const errset = errorType.getErrset()!;\n                // errset.members are IdentNode[], extract their names\n                return errset.members.map(m => m.name);\n            }\n\n            private createFuncSymbol(funcNode: AST.FuncStmtNode, scope: Scope, moduleName: string): Symbol {\n                const symbol = this.createBaseSymbol(\n                    funcNode.ident.name,\n                    SymbolKind.Function,\n                    scope,\n                    moduleName,\n                    funcNode.span,\n                    funcNode.ident.span\n                );\n\n                const isModuleScope = scope.kind === ScopeKind.Module;\n                const isPublic = funcNode.visibility.kind === 'Public';\n\n                // DETECT ERROR MODE\n                const errorMode = funcNode.errorType\n                    ? this.determineErrorMode(funcNode.errorType)\n                    : undefined;\n\n                const selfGroupErrors = errorMode === 'self-group'\n                    ? this.extractSelfGroupErrors(funcNode.errorType)\n                    : undefined;\n\n                return {\n                    ...symbol,\n                    initialized: true,\n                    visibility: funcNode.visibility,\n                    isExported: isModuleScope && isPublic,\n                    metadata: {\n                        callable: true,\n                        params: [] as Symbol[],\n                        returnType: funcNode.returnType || undefined,\n                        errorType: funcNode.errorType || undefined,\n                        errorMode,           // NEW\n                        selfGroupErrors      // NEW\n                    }\n                };\n            }\n\n            private createFuncScope(functionName: string, parentScope: Scope): Scope {\n                const funcScope = this.config.services.scopeManager.createScope(ScopeKind.Function, functionName, parentScope.id);\n                this.incrementScopesCreated();\n                return funcScope;\n            }\n\n            private collectFuncStmt(funcNode: AST.FuncStmtNode, scope: Scope, moduleName: string): void {\n                this.log('symbols', `Collecting function '${funcNode.ident.name}'`);\n\n                if(this.checkForShadowing(funcNode.ident.name, scope, SymbolKind.Function, funcNode.ident.span)) {\n                    return;\n                }\n\n                this.checkForShadowing(funcNode.ident.name, scope, SymbolKind.Function, funcNode.ident.span, true);\n\n                const funcScope = this.createFuncScope(funcNode.ident.name, scope);\n                const funcSymbol = this.createFuncSymbol(funcNode, scope, moduleName);\n\n                // COLLECTION PHASE: Mark function as comptime (metadata only)\n                const isComptimeFunc = funcNode.comptime.kind === 'Comptime';\n                if (!funcSymbol.metadata) {\n                    funcSymbol.metadata = {};\n                }\n                funcSymbol.metadata.isComptimeFunction = isComptimeFunc;\n\n                // Store the function BODY for later evaluation in type validation phase\n                if (isComptimeFunc) {\n                    funcSymbol.metadata.comptimeFunctionBody = funcNode.body;\n                    funcSymbol.metadata.comptimeParameters = funcNode.parameters;\n                }\n\n                this.config.services.scopeManager.addSymbolToScope(funcSymbol, scope.id);\n                this.incrementSymbolsCollected();\n                this.trackModuleExport(moduleName, funcNode.ident.name, funcSymbol.isExported);\n\n                const errorMode = funcNode.errorType\n                ? this.determineErrorMode(funcNode.errorType)\n                : undefined;\n\n                // MOVED: Check if struct method BEFORE processing\n                const parentScope = this.config.services.scopeManager.getScope(scope.id);\n                const isStructMethod = parentScope.kind === ScopeKind.Type &&\n                                    parentScope.metadata?.typeKind === 'Struct' &&\n                                    !(funcNode.visibility.kind === 'Static');\n\n                this.config.services.scopeManager.withScope(funcScope.id, () => {\n                    this.config.services.contextTracker.withSavedState(() => {\n                        // INJECT SELF FIRST (if struct method)\n                        if (isStructMethod) {\n                            this.injectSelfParameter(funcScope, parentScope, moduleName);\n                        }\n\n                        // INJECT selferr for self-group error mode\n                        if (errorMode === 'self-group' && funcNode.errorType) {\n                            this.injectSelfErrReference(funcScope, funcNode.errorType, moduleName);\n                        }\n\n                        this.collectType(funcNode.returnType, scope, moduleName, funcNode.ident.name);\n\n                        if (funcSymbol.metadata && funcSymbol.metadata.params) {\n                            funcSymbol.metadata.params = this.collectParams(funcNode.parameters, funcScope, moduleName);\n                        }\n\n                        if (funcNode.body) {\n                            this.collectStmt(funcNode.body, funcScope, moduleName);\n                        }\n                    });\n                });\n            }\n\n            // ───── PARAMS ─────\n\n            private createParamSymbol(paramNode: AST.FieldNode, scope: Scope, moduleName: string): Symbol {\n                const symbol = this.createBaseSymbol(\n                    paramNode.ident.name,\n                    SymbolKind.Parameter,\n                    scope,\n                    moduleName,\n                    paramNode.span,\n                    paramNode.ident.span\n                );\n\n                return {\n                    ...symbol,\n                    type            : paramNode.type ?? null,\n                    initialized     : true,\n                    visibility      : paramNode.visibility ?? 'Private',\n                    mutability      : paramNode.mutability,  // Added\n                };\n            }\n\n            private collectParams(parameters: AST.FieldNode[], funcScope: Scope, moduleName: string): Symbol[] {\n                const collectedParams: Symbol[] = [];\n                const seenParams = new Set<string>();\n\n                // Check if 'self' already exists (injected by struct method)\n                const hasSelfParam = funcScope.symbols.has('self');\n\n                for (const paramNode of parameters) {\n                    // Prevent explicit 'self' parameter if already injected\n                    if (paramNode.ident.name === 'self' && hasSelfParam) {\n                        this.reportError(\n                            DiagCode.PARAMETER_SHADOWING,\n                            `Duplicate parameter name 'self'`,\n                            paramNode.ident.span\n                        );\n                        continue;\n                    }\n\n                    if(this.checkForShadowing(paramNode.ident.name, funcScope, SymbolKind.Parameter, paramNode.ident.span)) {\n                        continue;\n                    }\n\n                    // Warn if parameter shadows outer scope (like variables in parent function)\n                    this.checkForShadowing(paramNode.ident.name, funcScope, SymbolKind.Parameter, paramNode.ident.span, true);\n\n                    seenParams.add(paramNode.ident.name);\n\n                    const paramSymbol = this.createParamSymbol(paramNode, funcScope, moduleName);\n                    this.config.services.scopeManager.addSymbolToScope(paramSymbol, funcScope.id);\n                    this.incrementSymbolsCollected();\n                    collectedParams.push(paramSymbol);\n\n                    if (paramNode.type) {\n                        if (paramNode.type.isStruct() || paramNode.type.isEnum()) {\n                            const typeScopeName = `${paramNode.ident.name}-type`;\n                            const typeScope = this.createTypeScope(typeScopeName, funcScope);\n\n                            if (paramNode.type.isStruct()) {\n                                const struct = paramNode.type.getStruct()!;\n                                struct.metadata = { ...struct.metadata, scopeId: typeScope.id };\n                            } else if (paramNode.type.isEnum()) {\n                                const enumType = paramNode.type.getEnum()!;\n                                enumType.metadata = { ...enumType.metadata, scopeId: typeScope.id };\n                            }\n\n                            this.collectType(paramNode.type, funcScope, moduleName, typeScopeName);\n                        } else {\n                            this.collectType(paramNode.type, funcScope, moduleName, paramNode.ident.name);\n                        }\n                    }\n                }\n\n                return collectedParams;\n            }\n\n            private injectSelfParameter(\n                funcScope: Scope,\n                structScope: Scope,\n                moduleName: string\n            ): void {\n                // Create a type reference to the parent struct\n                const structType = AST.TypeNode.asIdentifier(\n                    { start: 0, end: 0 },\n                    structScope.name\n                );\n\n                const selfSymbol: Symbol = {\n                    id              : this.config.services.scopeManager.symbolIdGenerator.next(),\n                    name            : 'self',\n                    kind            : SymbolKind.Parameter,\n                    type            : structType,\n                    scope           : funcScope.id,\n                    contextSpan     : { start: 0, end: 0 }, // Synthetic - no source location\n                    targetSpan      : { start: 0, end: 0 },\n                    declared        : true,\n                    initialized     : true,\n                    used            : true, // Mark as used by default since it's implicit\n                    visibility      : { kind: 'Private' },\n                    mutability      : { kind: 'Immutable' },\n                    isTypeChecked   : false,\n                    isExported      : false,\n                    module          : moduleName,\n                    metadata        : {\n                        isSynthetic : true,\n                        isSelf      : true\n                    }\n                };\n\n                this.config.services.scopeManager.addSymbolToScope(selfSymbol, funcScope.id);\n                this.stats.syntheticSymbolsInjected++; // Track synthetic symbols separately\n                this.incrementSymbolsCollected();\n\n                this.log('symbols', `Injected implicit 'self' parameter in struct method '${funcScope.name}'`);\n            }\n\n            private injectSelfErrReference(\n                funcScope: Scope,\n                errorType: AST.TypeNode,\n                moduleName: string\n            ): void {\n                const selfErrSymbol: Symbol = {\n                    id: this.config.services.scopeManager.symbolIdGenerator.next(),\n                    name: 'selferr',\n                    kind: SymbolKind.Definition,  // It's a type namespace\n                    type: errorType,  // Points to the error set\n                    scope: funcScope.id,\n                    contextSpan: { start: 0, end: 0 },  // Synthetic\n                    targetSpan: { start: 0, end: 0 },\n                    declared: true,\n                    initialized: true,\n                    used: false,  // Will be marked used when referenced\n                    visibility: { kind: 'Private' },\n                    mutability: { kind: 'Immutable' },\n                    isTypeChecked: false,\n                    isExported: false,\n                    module: moduleName,\n                    metadata: {\n                        isSynthetic: true,\n                        isSelfErr: true  // NEW FLAG to identify selferr\n                    }\n                };\n\n                this.config.services.scopeManager.addSymbolToScope(selfErrSymbol, funcScope.id);\n                this.stats.syntheticSymbolsInjected++;\n\n                this.log('symbols', `Injected 'selferr' reference in function with self-group errors`);\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌───────────────────────────── [3.6] LOOP ─────────────────────────────┐\n\n            private handleLoopStmt(stmt: AST.StmtNode, scope: Scope, moduleName: string): void {\n                if(stmt.getLoop === undefined) {\n                    const data = stmt;\n                    switch (stmt.kind) {\n                        case 'While' : {\n                            const src = data.source as AST.LoopStmtNode;\n                            const loop = AST.LoopStmtNode.createWhile(data.span, src.expr, src.stmt);\n                            this.collectLoopStmt(loop, scope, moduleName);\n                            break;\n                        }\n                        case 'Do' : {\n                            const src = data.source as AST.LoopStmtNode;\n                            const loop = AST.LoopStmtNode.createDo(data.span, src.expr, src.stmt);\n                            this.collectLoopStmt(loop, scope, moduleName);\n                            break;\n                        }\n                        case 'For' : {\n                            const src = data.source as AST.LoopStmtNode;\n                            const loop = AST.LoopStmtNode.createFor(data.span, src.expr, src.stmt);\n                            this.collectLoopStmt(loop, scope, moduleName);\n                            break;\n                        }\n                    }\n                } else {\n                    this.collectLoopStmt(stmt.getLoop()!, scope, moduleName);\n                }\n            }\n\n            private createLoopScope(parentScope: Scope): Scope {\n                const loopScope = this.config.services.scopeManager.createScope(ScopeKind.Loop, 'loop', parentScope.id);\n                this.incrementScopesCreated();\n                this.log('scopes', `Created loop scope ${loopScope.id} under parent ${parentScope.id}`);\n                return loopScope;\n            }\n\n            private collectLoopStmt(loopNode: AST.LoopStmtNode, parentScope: Scope, moduleName: string): void {\n                const loopScope = this.createLoopScope(parentScope);\n\n                this.config.services.scopeManager.withScope(loopScope.id, () => {\n                    this.config.services.contextTracker.withSavedState(() => {\n                        this.config.services.contextTracker.setScope(loopScope.id);\n\n                        switch (loopNode.kind) {\n                            case 'While':\n                                this.collectExpr(loopNode.expr, loopScope, moduleName);\n                                this.collectStmt(loopNode.stmt, loopScope, moduleName);\n                                break;\n                            case 'Do':\n                                this.collectStmt(loopNode.stmt, loopScope, moduleName);\n                                this.collectExpr(loopNode.expr, loopScope, moduleName);\n                                break;\n                            case 'For':\n                                this.collectExpr(loopNode.expr, loopScope, moduleName);\n                                this.collectStmt(loopNode.stmt, loopScope, moduleName);\n                                break;\n                        }\n                    });\n                });\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────── [3.7] CTRLFLOW ──────────────────────────┐\n\n            private handleControlflowStmt(stmt: AST.StmtNode, scope: Scope, moduleName: string): void {\n                if(stmt.getCtrlflow === undefined) {\n                    const data = stmt;\n                    switch (stmt.kind) {\n                        case 'Return' : {\n                            const src = data.source as AST.ControlFlowStmtNode;\n                            const res = AST.ControlFlowStmtNode.asReturn(data.span, src.value);\n                            this.collectReturnStmt(res, scope, moduleName);\n                            break;\n                        }\n                        case 'Defer' : {\n                            const src = data.source as AST.ControlFlowStmtNode;\n                            const res = AST.ControlFlowStmtNode.asDefer(data.span, src.value);\n                            this.collectDeferStmt(res, scope, moduleName);\n                            break;\n                        }\n                        case 'Throw' : {\n                            const src = data.source as AST.ControlFlowStmtNode;\n                            const res = AST.ControlFlowStmtNode.asThrow(data.span, src.value);\n                            this.collectThrowStmt(res, scope, moduleName);\n                            break;\n                        }\n                    }\n                } else {\n                    switch (stmt.getCtrlflow()!.kind) {\n                        case 'return' : {\n                            this.collectReturnStmt(stmt.getCtrlflow()!, scope, moduleName);\n                            break;\n                        }\n                        case 'defer' : {\n                            this.collectDeferStmt(stmt.getCtrlflow()!, scope, moduleName);\n                            break;\n                        }\n                        case 'throw' : {\n                            this.collectThrowStmt(stmt.getCtrlflow()!, scope, moduleName);\n                            break;\n                        }\n                    }\n                }\n            }\n\n            private collectReturnStmt(returnNode: AST.ControlFlowStmtNode, scope: Scope, moduleName: string): void {\n                if (returnNode.value) {\n                    this.collectExpr(returnNode.value, scope, moduleName);\n                }\n            }\n\n            private collectDeferStmt(deferNode: AST.ControlFlowStmtNode, scope: Scope, moduleName: string): void {\n                if (deferNode.value) {\n                    this.collectExpr(deferNode.value, scope, moduleName);\n                }\n            }\n\n            private collectThrowStmt(throwNode: AST.ControlFlowStmtNode, scope: Scope, moduleName: string): void {\n                if (throwNode.value) {\n                    this.collectExpr(throwNode.value, scope, moduleName);\n                }\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌─────────────────────────── [4] EXPR Level ───────────────────────────┐\n\n            private createExprScope(parentScope: Scope): Scope {\n                const exprScope = this.config.services.scopeManager.createScope(ScopeKind.Expression, 'expr', parentScope.id);\n                this.incrementScopesCreated();\n                return exprScope;\n            }\n\n            private collectExpr(expr: AST.ExprNode, currentScope: Scope, moduleName: string): void {\n                let needsScope = false;\n\n                switch (expr.kind) {\n                    case 'If':\n                    case 'Match':\n                    case 'Try':\n                    case 'Catch':\n                        needsScope = true;\n                        break;\n                }\n\n                if (needsScope) {\n                    const exprScope = this.createExprScope(currentScope);\n                    this.config.services.scopeManager.withScope(exprScope.id, () => {\n                        this.config.services.contextTracker.withSavedState(() => {\n                            this.config.services.contextTracker.setScope(exprScope.id);\n                            this.processExprKind(expr, exprScope, moduleName);\n                        });\n                    });\n                } else {\n                    this.processExprKind(expr, currentScope, moduleName);\n                }\n            }\n\n            private processExprKind(expr: AST.ExprNode, scope: Scope, moduleName: string): void {\n                switch (expr.kind) {\n                    case 'As':\n                        this.handleAsExpr(expr.getAs()!, scope, moduleName);\n                        break;\n                    case 'Typeof':\n                        return this.processExprKind(expr.getTypeof()!.expr, scope, moduleName);\n                    case 'Sizeof':\n                        return this.processExprKind(expr.getSizeof()!.expr, scope, moduleName);\n                    case 'Orelse':\n                        this.handleOrelseExpr(expr.getOrelse()!, scope, moduleName);\n                        break;\n                    case 'Range':\n                        this.handleRangeExpr(expr.getRange()!, scope, moduleName);\n                        break;\n                    case 'Try':\n                        this.handleTryExpr(expr.getTry()!, scope, moduleName);\n                        break;\n                    case 'Catch':\n                        this.handleCatchExpr(expr.getCatch()!, scope, moduleName);\n                        break;\n                    case 'If':\n                        this.handleIfExpr(expr.getIf()!, scope, moduleName);\n                        break;\n                    case 'Match':\n                        this.handleSwitchExpr(expr.getMatch()!, scope, moduleName);\n                        break;\n                    case 'Binary':\n                        this.handleBinaryExpr(expr.getBinary()!, scope, moduleName);\n                        break;\n                    case 'Postfix':\n                        this.handlePostfixExpr(expr.getPostfix()!, scope, moduleName);\n                        break;\n                    case 'Prefix':\n                        this.handlePrefixExpr(expr.getPrefix()!, scope, moduleName);\n                        break;\n                    case 'Primary':\n                        this.handlePrimaryExpr(expr.getPrimary()!, scope, moduleName);\n                        break;\n                }\n            }\n\n            private handleAsExpr(asExpr: AST.AsNode, scope: Scope, moduleName: string): void {\n                this.collectType(asExpr.type, scope, moduleName);\n                this.collectExpr(asExpr.base, scope, moduleName);\n            }\n\n            private handleOrelseExpr(orelseExpr: AST.OrelseNode, scope: Scope, moduleName: string): void {\n                this.collectExpr(orelseExpr.left, scope, moduleName);\n                this.collectExpr(orelseExpr.right, scope, moduleName);\n            }\n\n            private handleRangeExpr(rangeExpr: AST.RangeNode, scope: Scope, moduleName: string): void {\n                if(rangeExpr.leftExpr) this.collectExpr(rangeExpr.leftExpr, scope, moduleName);\n                if(rangeExpr.rightExpr) this.collectExpr(rangeExpr.rightExpr, scope, moduleName);\n            }\n\n            private handleTryExpr(tryExpr: AST.TryNode, scope: Scope, moduleName: string): void {\n                this.collectExpr(tryExpr.expr, scope, moduleName);\n            }\n\n            private handleCatchExpr(catchExpr: AST.CatchNode, scope: Scope, moduleName: string): void {\n                this.collectExpr(catchExpr.leftExpr, scope, moduleName);\n                this.collectStmt(catchExpr.rightStmt, scope, moduleName);\n            }\n\n            private handleIfExpr(ifExpr: AST.IfNode, scope: Scope, moduleName: string): void {\n                this.collectExpr(ifExpr.condExpr, scope, moduleName);\n                this.collectStmt(ifExpr.thenStmt, scope, moduleName);\n                if (ifExpr.elseStmt) {\n                    this.collectStmt(ifExpr.elseStmt, scope, moduleName);\n                }\n            }\n\n            private handleSwitchExpr(switchExpr: AST.MatchNode, scope: Scope, moduleName: string): void {\n                this.collectExpr(switchExpr.condExpr, scope, moduleName);\n                for (const switchCase of switchExpr.cases) {\n                    if (switchCase.expr) this.collectExpr(switchCase.expr, scope, moduleName);\n                    if (switchCase.stmt) this.collectStmt(switchCase.stmt, scope, moduleName);\n                }\n                if (switchExpr.defCase) {\n                    this.collectStmt(switchExpr.defCase.stmt, scope, moduleName);\n                }\n            }\n\n            private handleBinaryExpr(binaryExpr: AST.BinaryNode, scope: Scope, moduleName: string): void {\n                this.collectExpr(binaryExpr.left, scope, moduleName);\n                this.collectExpr(binaryExpr.right, scope, moduleName);\n            }\n\n            private handlePostfixExpr(postfixExpr: AST.PostfixNode, scope: Scope, moduleName: string): void {\n                switch(postfixExpr.kind) {\n                    case 'Increment':\n                    case 'Decrement':\n                    case 'Dereference':\n                        this.collectExpr(postfixExpr.getAsExprNode()!, scope, moduleName);\n                        break;\n                    case 'Call': {\n                        const callExpr = postfixExpr.getCall()!;\n                        this.collectExpr(callExpr.base, scope, moduleName);\n                        for (const arg of callExpr.args) {\n                            this.collectExpr(arg, scope, moduleName);\n                        }\n                        break;\n                    }\n                    case 'ArrayAccess': {\n                        const arrayAccess = postfixExpr.getArrayAccess()!;\n                        this.collectExpr(arrayAccess.base, scope, moduleName);\n                        this.collectExpr(arrayAccess.index, scope, moduleName);\n                        break;\n                    }\n                    case 'MemberAccess': {\n                        const memberAccess = postfixExpr.getMemberAccess()!;\n                        this.collectExpr(memberAccess.base, scope, moduleName);\n                        break;\n                    }\n                }\n            }\n\n            private handlePrefixExpr(prefixExpr: AST.PrefixNode, scope: Scope, moduleName: string): void {\n                this.collectExpr(prefixExpr.expr, scope, moduleName);\n            }\n\n            private handlePrimaryExpr(primaryExpr: AST.PrimaryNode, scope: Scope, moduleName: string): void {\n                switch(primaryExpr.kind) {\n                    case 'Ident': {\n                        const ident = primaryExpr.getIdent();\n                        if (ident && ident.name === 'self') {\n                            this.validateSelfUsage(scope, ident.span);\n                        }\n                        break;\n                    }\n                    case 'Literal':\n                        break;\n                    case 'Type': {\n                        const type = primaryExpr.getType()!;\n                        this.collectType(type, scope, moduleName);\n                        break;\n                    }\n                    case 'Paren': {\n                        const paren = primaryExpr.getParen()!;\n                        this.collectExpr(paren.source, scope, moduleName);\n                        break;\n                    }\n                    case 'Tuple': {\n                        const tuple = primaryExpr.getTuple()!;\n                        for (const expr of tuple.fields) {\n                            this.collectExpr(expr, scope, moduleName);\n                        }\n                        break;\n                    }\n                    case 'Object': {\n                        const object = primaryExpr.getObject()!;\n                        if(object.ident) {\n                            this.collectExpr(\n                                AST.ExprNode.asIdent(object.ident.span, object.ident.name),\n                                scope,\n                                moduleName\n                            );\n                        }\n                        for (const field of object.props) {\n                            if(field.val) this.collectExpr(field.val, scope, moduleName);\n                        }\n                        break;\n                    }\n                }\n            }\n\n            private validateSelfUsage(currentScope: Scope, span: AST.Span): void {\n                let checkScope: Scope | null = currentScope;\n                let isInStaticMethod = false;\n                let structScope: Scope | null = null;\n\n                while (checkScope) {\n                    if (checkScope.kind === ScopeKind.Function) {\n                        const parentScope = checkScope.parent !== null\n                            ? this.config.services.scopeManager.getScope(checkScope.parent)\n                            : null;\n\n                        if (parentScope?.kind === ScopeKind.Type &&\n                            parentScope.metadata?.typeKind === 'Struct') {\n                            structScope = parentScope;\n\n                            const funcSymbol = parentScope.symbols.get(checkScope.name);\n                            if (funcSymbol && funcSymbol.visibility.kind === 'Static') {\n                                isInStaticMethod = true;\n                            }\n                            break;\n                        }\n                    }\n\n                    checkScope = checkScope.parent !== null\n                        ? this.config.services.scopeManager.getScope(checkScope.parent)\n                        : null;\n                }\n\n                // ALLOW 'self' in static methods (validation happens in member access)\n                if (isInStaticMethod && structScope) {\n                    // Don't block here - let member access validation handle it\n                    return;\n                }\n\n                // For non-static contexts, validate as before\n                const selfSymbol = this.config.services.scopeManager.lookupSymbolInScopeChain('self', currentScope.id);\n\n                if (!selfSymbol || !selfSymbol.metadata?.isSelf) {\n                    this.reportError(\n                        DiagCode.UNDEFINED_IDENTIFIER,\n                        \"self can only be used in instance methods\",\n                        span\n                    );\n                    return;\n                }\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌─────────────────────────── [5] Type Level ───────────────────────────┐\n\n            private createTypeScope(typeName: string, parentScope: Scope, typeKind?: 'Struct' | 'Enum'): Scope {\n                const typeScope = this.config.services.scopeManager.createScope(ScopeKind.Type, typeName, parentScope.id);\n\n                // Set metadata immediately\n                if (typeKind) {\n                    typeScope.metadata = {\n                        ...typeScope.metadata,\n                        typeKind\n                    };\n                }\n\n                this.incrementScopesCreated();\n                return typeScope;\n            }\n\n            private collectType(\n                type: AST.TypeNode | undefined | null,\n                parentScope: Scope,\n                moduleName: string,\n                newScopeName?: string\n            ): void {\n                if (!type) return;\n\n                // Use withTypeContext for cycle detection\n                this.withTypeContext(type, newScopeName, () => {\n                    this.collectTypeInternal(type, parentScope, moduleName, newScopeName);\n                });\n            }\n\n            private collectTypeInternal(\n                type: AST.TypeNode,\n                parentScope: Scope,\n                moduleName: string,\n                newScopeName?: string\n            ): void {\n                let needsScope = false;\n                let typeName = 'Anonymous';\n                let typeScope: Scope = parentScope;\n\n                switch(type.kind) {\n                    case 'struct':\n                        needsScope = true;\n                        if (newScopeName) {\n                            typeName = newScopeName;\n                        } else {\n                            const anonId = this.config.services.scopeManager.symbolIdGenerator.next();\n                            typeName = `<anonymous-struct-${anonId}>`;\n                        }\n                        break;\n                    case 'enum':\n                        needsScope = true;\n                        if (newScopeName) {\n                            typeName = newScopeName;\n                        } else {\n                            const anonId = this.config.services.scopeManager.symbolIdGenerator.next();\n                            typeName = `<anonymous-enum-${anonId}>`;\n                        }\n                        break;\n                    case 'errset':\n                        needsScope = true;\n                        typeName = newScopeName || '<anonymous-error>';\n                        break;\n                }\n\n                if (needsScope) {\n                    typeScope = this.createTypeScope(typeName, parentScope);\n\n                    // Set metadata immediately after scope creation\n                    switch(type.kind) {\n                        case 'struct':\n                            typeScope.metadata = { ...typeScope.metadata, typeKind: 'Struct' };\n                            break;\n                        case 'enum':\n                            typeScope.metadata = { ...typeScope.metadata, typeKind: 'Enum' };\n                            break;\n                        case 'errset':\n                            typeScope.metadata = { ...typeScope.metadata, typeKind: 'Error' };\n                            break;\n                    }\n\n                    // Validate scope ID before use\n                    if (!this.config.services.scopeManager.getScope(typeScope.id)) {\n                        throw new Error(`Invalid scope ID ${typeScope.id} for type ${typeName}`);\n                    }\n                }\n\n                try {\n                    switch(type.kind) {\n                        case 'struct':\n                            this.handleStructType(type.getStruct()!, typeScope, moduleName);\n                            break;\n                        case 'enum':\n                            this.handleEnumType(type.getEnum()!, typeScope, moduleName);\n                            break;\n                        case 'errset':\n                            this.collectErrorType(type.getErrset()!, typeScope, moduleName);\n                            break;\n                        case 'tuple':\n                            this.handleTupleType(type.getTuple()!, parentScope, moduleName);\n                            break;\n                        case 'array':\n                            this.handleArrayType(type.getArray()!, parentScope, moduleName);\n                            break;\n                        case 'optional':\n                            this.handleOptionalType(type.getOptional()!, parentScope, moduleName);\n                            break;\n                        case 'pointer':\n                            this.handlePointerType(type.getPointer()!, parentScope, moduleName);\n                            break;\n                        case 'function':\n                            this.handleFunctionType(type.getFunction()!, parentScope, moduleName);\n                            break;\n                        case 'union':\n                            this.handleUnionType(type.getUnion()!, parentScope, moduleName);\n                            break;\n                        case 'paren':\n                            this.collectTypeInternal(type.getParen()!.type, parentScope, moduleName);\n                    }\n                } catch (error) {\n                    this.reportError(\n                        DiagCode.ANALYSIS_ERROR,\n                        `Failed to collect type ${type.kind}: ${error}`\n                    );\n                }\n            }\n\n            private handleStructType(structType: AST.StructTypeNode, typeScope: Scope, moduleName: string): void {\n                structType.metadata = { ...structType.metadata, scopeId: typeScope.id };\n\n                // Mark scope so we know this is a struct type scope\n                typeScope.metadata = {\n                    ...typeScope.metadata,\n                    typeKind: 'Struct'  // This line exists but might not be executing\n                };\n\n                for (const member of structType.members) {\n                    if(!member || !member.kind || !member.source) { continue; }\n\n                    if(member.isField()) {\n                        this.collectStructField(member.source as AST.FieldNode, typeScope, moduleName);\n                    } else {\n                        this.collectFuncStmt(member.source as AST.FuncStmtNode, typeScope, moduleName);\n                    }\n                }\n            }\n\n            private handleEnumType(enumType: AST.EnumTypeNode, typeScope: Scope, moduleName: string): void {\n                enumType.metadata = { ...enumType.metadata, scopeId: typeScope.id };\n\n                for (const variant of enumType.variants) {\n                    if (typeScope.symbols.has(variant.ident.name)) {\n                        this.reportError(\n                            DiagCode.ENUM_VARIANT_SHADOWING,\n                            `Duplicate enum variant '${variant.ident.name}'`,\n                            variant.ident.span\n                        );\n                        continue;\n                    }\n\n                    // ALWAYS collect the variant symbol in the enum scope\n                    this.collectEnumVariantIdent(variant.ident, typeScope, moduleName);\n\n                    // THEN handle the associated type if it exists\n                    if(variant.type) {\n                        const variantScope = this.createTypeScope(variant.ident.name, typeScope);\n                        if (variant.type.isStruct()) {\n                            const structType = variant.type.getStruct()!;\n                            structType.metadata = {\n                                ...structType.metadata,\n                                scopeId: variantScope.id\n                            };\n\n                            this.config.services.scopeManager.withScope(variantScope.id, () => {\n                                this.config.services.contextTracker.withSavedState(() => {\n                                    this.config.services.contextTracker.setScope(variantScope.id);\n                                    this.collectType(variant.type!, variantScope, moduleName, variant.ident.name);\n                                });\n                            });\n                        } else {\n                            this.collectType(variant.type, typeScope, moduleName);\n                        }\n                    }\n                }\n            }\n\n            private handleTupleType(tupleType: AST.TupleTypeNode, parentScope: Scope, moduleName: string): void {\n                for (const field of tupleType.fields) {\n                    this.collectType(field, parentScope, moduleName);\n                }\n            }\n\n            private handleArrayType(arrayType: AST.ArrayTypeNode, parentScope: Scope, moduleName: string): void {\n                this.collectType(arrayType.target, parentScope, moduleName);\n                if(arrayType.size) this.collectExpr(arrayType.size, parentScope, moduleName);\n            }\n\n            private handleOptionalType(optionalType: AST.OptionalTypeNode, parentScope: Scope, moduleName: string): void {\n                this.collectType(optionalType.target, parentScope, moduleName);\n            }\n\n            private handlePointerType(pointerType: AST.PointerTypeNode, parentScope: Scope, moduleName: string): void {\n                this.collectType(pointerType.target, parentScope, moduleName);\n            }\n\n            private handleFunctionType(funcType: AST.FunctionTypeNode, parentScope: Scope, moduleName: string): void {\n                for (const param of funcType.params) {\n                    if (param) {\n                        this.collectType(param, parentScope, moduleName);\n                    }\n                }\n\n                if (funcType.returnType) {\n                    this.collectType(funcType.returnType, parentScope, moduleName);\n                }\n\n                if (funcType.errorType) {\n                    this.collectType(funcType.errorType, parentScope, moduleName);\n                }\n            }\n\n            private handleUnionType(unionType: AST.UnionTypeNode, parentScope: Scope, moduleName: string): void {\n                for (const variant of unionType.types) {\n                    // CRITICAL FIX: Create isolated scope for each union member\n                    if (variant.isStruct()) {\n                        const anonId = this.config.services.scopeManager.symbolIdGenerator.next();\n                        const scopeName = `<union-struct-${anonId}>`;\n                        const structScope = this.createTypeScope(scopeName, parentScope, 'Struct');\n                        \n                        const struct = variant.getStruct()!;\n                        struct.metadata = { ...struct.metadata, scopeId: structScope.id };\n                        \n                        this.config.services.scopeManager.withScope(structScope.id, () => {\n                            this.config.services.contextTracker.withSavedState(() => {\n                                this.config.services.contextTracker.setScope(structScope.id);\n                                this.handleStructType(struct, structScope, moduleName);\n                            });\n                        });\n                    } else {\n                        // For non-struct types, collect normally BUT in isolation\n                        this.collectType(variant, parentScope, moduleName);\n                    }\n                }\n            }\n\n            private collectStructField(fieldNode: AST.FieldNode, scope: Scope, moduleName: string): void {\n                this.log('symbols', `Collecting structure field '${fieldNode.ident.name}'`);\n\n                // Validate static fields must be immutable\n                if (fieldNode.visibility.kind === 'Static') {\n                    if (fieldNode.mutability.kind === 'Mutable') {\n                        this.reportError(\n                            DiagCode.INVALID_VISIBILITY,\n                            `Static field '${fieldNode.ident.name}' cannot be mutable. Static fields must be immutable.`,\n                            fieldNode.span\n                        );\n                        // Force it to be immutable to prevent further errors\n                        fieldNode.mutability = { kind: 'Immutable' };\n                    }\n                }\n\n                // Only check for shadowing WITHIN the struct scope\n                if(this.checkForShadowing(fieldNode.ident.name, scope, SymbolKind.StructField, fieldNode.ident.span, false)) {\n                    return;\n                }\n\n                const symbol: Symbol = this.createStructFieldSymbol(fieldNode, scope, moduleName);\n                this.config.services.scopeManager.addSymbolToScope(symbol, scope.id);\n                this.incrementSymbolsCollected();\n\n                if(fieldNode.type) {\n                    this.collectType(fieldNode.type, scope, moduleName);\n                }\n\n                if(fieldNode.initializer) {\n                    this.collectExpr(fieldNode.initializer, scope, moduleName);\n                }\n            }\n\n            private createStructFieldSymbol(fieldNode: AST.FieldNode, scope: Scope, moduleName: string): Symbol {\n                const symbol = this.createBaseSymbol(\n                    fieldNode.ident.name,\n                    SymbolKind.StructField,\n                    scope,\n                    moduleName,\n                    fieldNode.span,\n                    fieldNode.ident.span\n                );\n\n                return {\n                    ...symbol,\n                    type            : fieldNode.type ?? null,\n                    initialized     : !!fieldNode.initializer,\n                    visibility      : fieldNode.visibility ?? 'Private',\n                    mutability      : fieldNode.mutability,  // Added\n                };\n            }\n\n            private collectEnumVariantIdent(identNode: AST.IdentNode, scope: Scope, moduleName: string): void {\n                const symbol = this.createEnumVariantSymbol(identNode, scope, moduleName);\n                this.config.services.scopeManager.addSymbolToScope(symbol, scope.id);\n                this.incrementSymbolsCollected();\n            }\n\n            private createEnumVariantSymbol(identNode: AST.IdentNode, scope: Scope, moduleName: string): Symbol {\n                return this.createBaseSymbol(\n                    identNode.name,\n                    SymbolKind.EnumVariant,\n                    scope,\n                    moduleName,\n                    identNode.span,\n                    identNode.span\n                );\n            }\n\n            private collectErrorType(errorType: AST.ErrsetTypeNode, scope: Scope, moduleName: string): void {\n                if(errorType.members.length === 0) return;\n\n                const seenErrors = new Set<string>();\n\n                // errorType.members are IdentNode[]\n                for (const error of errorType.members) {\n                    if (seenErrors.has(error.name)) {\n                        this.reportError(\n                            DiagCode.ERROR_SHADOWING,\n                            `Duplicate error member '${error.name}'`,\n                            error.span\n                        );\n                        continue;\n                    }\n\n                    seenErrors.add(error.name);\n\n                    const symbol = this.createErrorSymbol(error, scope, moduleName);\n                    this.config.services.scopeManager.addSymbolToScope(symbol, scope.id);\n                    this.incrementSymbolsCollected();\n                }\n            }\n\n            private createErrorSymbol(identNode: AST.IdentNode, scope: Scope, moduleName: string): Symbol {\n                return this.createBaseSymbol(\n                    identNode.name,\n                    SymbolKind.Error,\n                    scope,\n                    moduleName,\n                    identNode.span,\n                    identNode.span\n                );\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌─────────────────────────── [x] VALIDATION ───────────────────────────┐\n\n            private checkForShadowing(\n                newSymbolName: string,\n                currentScope: Scope,\n                newSymbolKind: SymbolKind,\n                span: AST.Span,\n                outer = false\n            ): boolean {\n                // Special handling for 'self' - ALWAYS check parent scopes too\n                if (newSymbolName === 'self') {\n                    // For 'self', check both current and parent scopes\n                    const existingSymbol = outer\n                        ? this.config.services.scopeManager.lookupSymbolInParentScopes('self', currentScope.id)\n                        : (currentScope.symbols.get('self') ||\n                        this.config.services.scopeManager.lookupSymbolInParentScopes('self', currentScope.id));\n\n                    if (existingSymbol && existingSymbol.metadata?.isSelf) {\n                        this.reportError(\n                            newSymbolKind === SymbolKind.Parameter\n                                ? DiagCode.PARAMETER_SHADOWING\n                                : DiagCode.VARIABLE_SHADOWING,\n                            newSymbolKind === SymbolKind.Parameter\n                                ? `Duplicate parameter name 'self'`\n                                : `Symbol 'self' shadows parameter 'self' in ${outer ? 'outer' : 'same'} scope`,\n                            span\n                        );\n                        return true; // Always error for 'self'\n                    }\n                }\n\n                // Prevent built-in shadowing\n                if (newSymbolName.startsWith('@')) {\n                    this.reportError(\n                        DiagCode.DUPLICATE_SYMBOL,\n                        `Cannot shadow built-in symbol '${newSymbolName}'`,\n                        span\n                    );\n                    return true;\n                }\n\n                const existingSymbol = outer\n                    ? this.config.services.scopeManager.lookupSymbolInParentScopes(newSymbolName, currentScope.id)\n                    : currentScope.symbols.get(newSymbolName);\n\n                if (existingSymbol) {\n\n                    // Check if we're in a type scope (struct/enum)\n                    const isInTypeScope = currentScope.kind === ScopeKind.Type;\n                    const existingIsInTypeScope = this.config.services.scopeManager.getScope(existingSymbol.scope).kind === ScopeKind.Type;\n\n                    // If one is in type scope and one isn't, they're in different namespaces\n                    if (isInTypeScope !== existingIsInTypeScope && outer) {\n                        this.log('verbose',\n                            `Symbol '${newSymbolName}' in type scope doesn't shadow module-level symbol (different namespaces)`\n                        );\n                        return false; // No shadowing - different namespaces\n                    }\n\n                    let diagnosticCode: DiagCode;\n                    let severity: DiagKind = DiagKind.ERROR;\n\n                    switch (newSymbolKind) {\n                        case SymbolKind.Use:\n                            diagnosticCode = DiagCode.USE_SHADOWING;\n                            break;\n                        case SymbolKind.Definition:\n                            diagnosticCode = DiagCode.DEFINITION_SHADOWING;\n                            break;\n                        case SymbolKind.Variable:\n                            diagnosticCode = DiagCode.VARIABLE_SHADOWING;\n                            if (outer) severity = DiagKind.WARNING;\n                            break;\n                        case SymbolKind.Function:\n                            diagnosticCode = DiagCode.FUNCTION_SHADOWING;\n                            if (outer) severity = DiagKind.WARNING;\n                            break;\n                        case SymbolKind.Parameter:\n                            diagnosticCode = DiagCode.PARAMETER_SHADOWING;\n                            if (outer) severity = DiagKind.WARNING;\n                            break;\n                        case SymbolKind.StructField:\n                            diagnosticCode = DiagCode.STRUCT_FIELD_SHADOWING;\n                            break;\n                        case SymbolKind.EnumVariant:\n                            diagnosticCode = DiagCode.ENUM_VARIANT_SHADOWING;\n                            break;\n                        case SymbolKind.Error:\n                            diagnosticCode = DiagCode.ERROR_SHADOWING;\n                            break;\n                        default:\n                            return false;\n                    }\n\n                    const message = `Symbol '${newSymbolName}' shadows ${(existingSymbol.kind as string).toLowerCase()} '${existingSymbol.name}' in ${outer ? 'outer' : 'same'} scope`;\n\n                    if (severity === DiagKind.WARNING) {\n                        this.reportWarning(diagnosticCode, message, span);\n                    } else {\n                        this.reportError(diagnosticCode, message, span);\n                    }\n\n                    return severity === DiagKind.ERROR ? !outer : false;\n                }\n                return false;\n            }\n\n            private checkTypeCycle(type: AST.TypeNode, scopeName?: string): boolean {\n                const typeKey = this.createTypeKey(type, scopeName);\n\n                if (this.typeContext.visitedTypes.has(typeKey)) {\n                    this.log('verbose', `Cycle detected in type: ${typeKey}`);\n                    this.log('verbose', `Type path: ${this.typeContext.currentTypePath.join(' -> ')}`);\n\n                    // Report as warning, not error - cycles via pointers are valid\n                    this.reportWarning(\n                        DiagCode.TYPE_CYCLE_DETECTED,\n                        `Circular type reference detected for ${type.kind} (this is OK for pointer types)`,\n                        type.span\n                    );\n\n                    // Pointer cycles are OK, just log and continue\n                    this.log('verbose', `Valid pointer cycle: ${typeKey}`);\n                    return false; // Continue processing\n                }\n\n                // Track max nesting for diagnostics\n                if (this.typeContext.nestingDepth > this.typeContext.maxNestingDepth) {\n                    this.typeContext.maxNestingDepth = this.typeContext.nestingDepth;\n                }\n\n                // Safety limit: 100 levels should handle any reasonable code\n                if (this.typeContext.nestingDepth > 100) {\n                    this.reportError(\n                        DiagCode.TYPE_NESTING_TOO_DEEP,\n                        // `Type nesting exceeds safety limit (${this.typeContext.nestingDepth} levels) - possible infinite recursion`,\n                        `Type nesting exceeds safety limit`,\n                        type.span\n                    );\n                    return true;\n                }\n\n                return false;\n            }\n\n            private withTypeContext(type: AST.TypeNode, scopeName: string | undefined, operation: () => void): void {\n                const typeKey = this.createTypeKey(type, scopeName);\n\n                // If cycle detected, stop processing\n                if (this.checkTypeCycle(type, scopeName)) {\n                    return;\n                }\n\n                // Add to visited set and path\n                this.typeContext.visitedTypes.add(typeKey);\n                this.typeContext.currentTypePath.push(typeKey);\n                this.typeContext.nestingDepth++;\n\n                try {\n                    operation();\n                } finally {\n                    // Always cleanup, even on error\n                    this.typeContext.visitedTypes.delete(typeKey);\n                    this.typeContext.currentTypePath.pop();\n                    this.typeContext.nestingDepth--;\n                }\n            }\n\n            private validateSymbolExistsInModule(module: AST.Module, symbolName: string): boolean {\n                for (const stmt of module.statements) {\n                    if (stmt.kind === 'Let') {\n                        const varNode = stmt.getLet();\n                        if (varNode && varNode.field.ident.name === symbolName) {\n                            return true;\n                        }\n                    } else if (stmt.kind === 'Func') {\n                        const funcNode = stmt.getFunc();\n                        if (funcNode && funcNode.ident.name === symbolName) {\n                            return true;\n                        }\n                    } else if (stmt.kind === 'Def') {\n                        const defNode = stmt.getDef();\n                        if (defNode && defNode.ident.name === symbolName) {\n                            return true;\n                        }\n                    }\n                }\n                return false;\n            }\n\n            private validateMemberPathInModule(\n                module: AST.Module,\n                memberPath: AST.IdentNode[] | undefined, // Now can be undefined\n                useNode: AST.UseStmtNode\n            ): boolean {\n                // Wildcard imports don't need validation here\n                if (!memberPath) {\n                    // Wildcard - always valid if module exists\n                    return true;\n                }\n\n                if (memberPath.length === 0) return false;\n                if (memberPath.length === 1) {\n                    return this.validateSymbolExistsInModule(module, memberPath[0].name);\n                }\n\n                // Start with the first identifier in the module\n                let currentSymbolName = memberPath[0].name;\n                if (!this.validateSymbolExistsInModule(module, currentSymbolName)) {\n                    this.reportError(\n                        DiagCode.SYMBOL_NOT_FOUND,\n                        `Symbol '${currentSymbolName}' not found in module`,\n                        memberPath[0].span\n                    );\n                    return false;\n                }\n\n                this.log('verbose',\n                    `Member path ${memberPath.map(m => m.name).join('.')} found in module (full validation deferred to type checking)`\n                );\n\n                return true;\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── ---- ────────────────────────────────┐\n\n            private init(): boolean {\n                this.pathContext.rootPath   = this.config.program!.metadata?.path as string | undefined;\n\n                this.config.services.contextTracker.reset();\n                this.config.services.contextTracker.setPhase(AnalysisPhase.Collection);\n\n                if (!this.config.program) {\n                    this.reportError(DiagCode.ANALYSIS_ERROR, 'No program provided for analysis');\n                    return false;\n                }\n\n                try {\n                    this.config.services.scopeManager.reset();\n                    const globalScope = this.config.services.scopeManager.getCurrentScope();\n                    if (globalScope.kind !== ScopeKind.Global) {\n                        this.reportError( DiagCode.INTERNAL_ERROR, 'Current scope is not global at the start of symbol collection' );\n                        return false;\n                    }\n                    this.incrementScopesCreated();\n                } catch (error) {\n                    this.reportError( DiagCode.INTERNAL_ERROR, `Failed to initialize scope manager: ${error}` );\n                    return false;\n                }\n\n                return true;\n            }\n\n            private initStats(): CollectionStats {\n                return {\n                    modulesProcessed            : 0,\n                    symbolsCollected            : 0,\n                    importResolutionFailures    : 0,\n                    scopesCreated               : 0,\n                    syntheticSymbolsInjected    : 0,\n                    startTime                   : Date.now()\n                };\n            }\n\n            private initTypeContext(): TypeCollectionContext {\n                return {\n                    visitedTypes        : new Set<string>(),\n                    currentTypePath     : [],\n                    nestingDepth        : 0,\n                    maxNestingDepth     : 0\n                };\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── ---- ────────────────────────────────┐\n\n            private createTypeKey(type: AST.TypeNode, scopeName?: string): string {\n                // Use span for uniqueness, kind for readability\n                const baseKey = `${type.kind}:${type.span.start}:${type.span.end}`;\n                return scopeName ? `${baseKey}:${scopeName}` : baseKey;\n            }\n\n            private createBaseSymbol(\n                name: string,\n                kind: SymbolKind,\n                scope: Scope,\n                moduleName: string,\n                contextSpan: AST.Span,\n                targetSpan: AST.Span\n            ): Symbol {\n                return {\n                    id              : this.config.services.scopeManager.symbolIdGenerator.next(),\n                    name,\n                    kind,\n                    module          : moduleName,\n                    scope           : scope.id,\n                    contextSpan,\n                    targetSpan,\n                    type            : null,\n                    declared        : true,\n                    initialized     : false,\n                    used            : false,\n                    visibility      : { kind: 'Private' },\n                    mutability      : { kind: 'Immutable' },\n                    isTypeChecked   : false,\n                    isExported      : false\n                };\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── ---- ────────────────────────────────┐\n\n            private incrementSymbolsCollected(): void {\n                this.stats.symbolsCollected++;\n            }\n\n            private incrementScopesCreated(): void {\n                this.stats.scopesCreated++;\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── ---- ────────────────────────────────┐\n\n            private trackModuleExport(moduleName: string, symbolName: string, isExported: boolean): void {\n                if (!isExported) return;\n\n                if (!this.moduleExports.has(moduleName)) {\n                    this.moduleExports.set(moduleName, new Set());\n                }\n                this.moduleExports.get(moduleName)!.add(symbolName);\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── ---- ────────────────────────────────┐\n\n            logStatistics(): void {\n                const duration = Date.now() - this.stats.startTime;\n                const stats = [\n                    `Collection Statistics:`,\n                    `  Duration             : ${duration}ms`,\n                    `  Modules processed    : ${this.stats.modulesProcessed}`,\n                    `  Symbols collected    : ${this.stats.symbolsCollected}`,\n                    `  Scopes created       : ${this.stats.scopesCreated}`,\n                    `  Import failures      : ${this.stats.importResolutionFailures}`,\n                    `  Max type nesting     : ${this.typeContext.maxNestingDepth}`\n                ];\n                this.log('verbose', stats.join('\\n'));\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── ---- ────────────────────────────────┐\n\n            getTypeRegistry(): Map<string, Symbol> {\n                return new Map(this.typeRegistry); // Return copy for safety\n            }\n\n            getModuleExports(moduleName: string): Set<string> | undefined {\n                return this.moduleExports.get(moduleName);\n            }\n\n            canImportSymbol(moduleName: string, symbolName: string): boolean {\n                const exports = this.moduleExports.get(moduleName);\n                return exports ? exports.has(symbolName) : false;\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// PathUtils.ts - Enhanced path resolution utilities\r\n//\r\n// Developed with ❤️ by Maysara.\r\n\r\nimport * as path from 'path';\r\nimport type { Program, Module } from '@je-es/ast';\r\n\r\nexport class PathUtils {\r\n    /**\r\n     * Resolves a module import path against the program's root path\r\n     */\r\n    static resolveModulePath(program: Program, importPath: string, currentModulePath?: string): string {\r\n        const programRoot = program.metadata?.path as string || './';\r\n\r\n        // If import path starts with '.' or '..', resolve relative to current module\r\n        if (importPath.startsWith('.') && currentModulePath) {\r\n            const currentDir = path.dirname(currentModulePath);\r\n            const resolved = path.resolve(currentDir, importPath);\r\n            // Normalize to relative path from program root\r\n            return path.relative(programRoot, resolved);\r\n        }\r\n\r\n        // For absolute imports, resolve from program root\r\n        if (path.isAbsolute(importPath)) {\r\n            return path.relative(programRoot, importPath);\r\n        }\r\n\r\n        // Otherwise resolve relative to program root\r\n        return path.normalize(importPath);\r\n    }\r\n\r\n    /**\r\n     * Finds a module by its resolved path\r\n     */\r\n    static findModuleByPath(program: Program, targetPath: string): Module | undefined {\r\n        const programRoot = program.metadata?.path as string || './';\r\n        const normalizedTarget = path.normalize(targetPath);\r\n\r\n        for (const [_, module] of program.modules) {\r\n            const modulePath = module.metadata?.path as string | undefined;\r\n            if (!modulePath) continue;\r\n\r\n            // Compare both absolute and relative paths\r\n            const relativeModulePath = path.relative(programRoot, modulePath);\r\n            const normalizedModulePath = path.normalize(modulePath);\r\n            const normalizedRelativePath = path.normalize(relativeModulePath);\r\n\r\n            if (normalizedModulePath === normalizedTarget ||\r\n                normalizedRelativePath === normalizedTarget ||\r\n                modulePath === targetPath ||\r\n                relativeModulePath === targetPath) {\r\n                return module;\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    /**\r\n     * Validates if a path exists in the program structure\r\n     */\r\n    static validatePath(program: Program, importPath: string, currentModulePath?: string): boolean {\r\n        try {\r\n            const resolvedPath = this.resolveModulePath(program, importPath, currentModulePath);\r\n            return this.findModuleByPath(program, resolvedPath) !== undefined;\r\n        } catch (e) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the relative path between two modules\r\n     */\r\n    static getRelativePath(fromPath: string, toPath: string): string {\r\n        const relativePath = path.relative(path.dirname(fromPath), toPath);\r\n        return relativePath.startsWith('.') ? relativePath : './' + relativePath;\r\n    }\r\n\r\n    /**\r\n     * Finds the module name by its path\r\n     */\r\n    static findModuleNameByPath(program: Program, targetPath: string): string | undefined {\r\n        const module = this.findModuleByPath(program, targetPath);\r\n        if (!module) return undefined;\r\n\r\n        // Try to get name from metadata first, then fallback to path-based name\r\n        const metadataName = module.metadata?.name as string | undefined;\r\n        if (metadataName) return metadataName;\r\n\r\n        // Extract name from path (remove extension and path separators)\r\n        const baseName = path.basename(targetPath, path.extname(targetPath));\r\n        return baseName === 'index' ? path.basename(path.dirname(targetPath)) : baseName;\r\n    }\r\n\r\n    /**\r\n     * Normalizes a path for consistent comparison\r\n     */\r\n    static normalizePath(filePath: string): string {\r\n        return path.normalize(filePath).replace(/\\\\/g, '/');\r\n    }\r\n}","// PhaseBase.ts — Base validator interface and types for all validators\r\n//\r\n// Developed with ❤️ by Maysara.\r\n\r\n\r\n\r\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\r\n\r\n    import * as AST                             from '@je-es/ast';\r\n    import { DiagCode }                         from '../components/DiagnosticManager';\r\n    import { AnalysisPhase }                    from '../components/ContextTracker';\r\n    import { AnalysisConfig }                   from '../ast-analyzer';\r\n\r\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\r\n\r\n\r\n\r\n// ╔════════════════════════════════════════ TYPE ════════════════════════════════════════╗\r\n\r\n    /** Abstract phase base class */\r\n    export abstract class PhaseBase {\r\n        protected constructor(\r\n            protected readonly phase    : AnalysisPhase,\r\n            protected readonly config   : AnalysisConfig,\r\n        ) {\r\n        }\r\n\r\n        abstract reset(): void;\r\n\r\n        abstract handle(): boolean;\r\n\r\n        abstract logStatistics(): void;\r\n\r\n        protected reportError(code: DiagCode, message: string, span?: AST.Span): void {\r\n            this.config.services.diagnosticManager.reportError(code, message, span);\r\n        }\r\n\r\n        protected reportWarning(code: DiagCode, message: string, span?: AST.Span): void {\r\n            this.config.services.diagnosticManager.reportWarning(code, message, span);\r\n        }\r\n\r\n        protected reportInfo(code: DiagCode, message: string, span?: AST.Span): void {\r\n            this.config.services.diagnosticManager.reportInfo(code, message, span);\r\n        }\r\n\r\n        protected log(kind: 'verbose' | 'symbols' | 'scopes' | 'errors' = 'verbose', message: string): void {\r\n            if (this.config.services.debugManager) {\r\n                this.config.services.debugManager.log(kind, message);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Extract getter function for statement node based on its kind.\r\n         * Returns null if the statement kind is invalid or unsupported.\r\n         */\r\n        protected getNodeGetter(stmt: AST.StmtNode): (() => any) | null {\r\n            switch (stmt.kind) {\r\n                case 'Def'          : return () => stmt.getDef();\r\n                case 'Use'          : return () => stmt.getUse();\r\n                case 'Let'          : return () => stmt.getLet();\r\n                case 'Func'         : return () => stmt.getFunc();\r\n                case 'Block'        : return () => stmt.getBlock();\r\n                case 'Return'       :\r\n                case 'Defer'        :\r\n                case 'Throw'        : return () => stmt.getCtrlflow();\r\n                case 'Expression'   : return () => stmt.getExpr();\r\n                case 'While'        :\r\n                case 'Do'           :\r\n                case 'For'          : return () => stmt.getLoop();\r\n                case 'Break'        : return () => stmt.getBreak();\r\n                case 'Continue'     : return () => stmt.getContinue();\r\n                case 'Test'         : return () => stmt.getTest();\r\n                default             : return null;\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Process a statement by delegating to kind-specific handlers.\r\n         * Returns the result of the handler or null if kind is unsupported.\r\n        */\r\n        protected processStmtByKind<T>(\r\n            stmt: AST.StmtNode,\r\n            handlers: Partial<Record<AST.StmtNode['kind'], (node: any) => T>>\r\n        ): T | null {\r\n            const getter = this.getNodeGetter(stmt);\r\n            if (!getter) {\r\n                this.reportError(\r\n                    DiagCode.INTERNAL_ERROR,\r\n                    `Invalid AST: ${stmt.kind} node getter not found`\r\n                );\r\n                return null;\r\n            }\r\n\r\n            const handler = handlers[stmt.kind];\r\n            if (!handler) {\r\n                // No handler registered for this statement kind\r\n                return null;\r\n            }\r\n\r\n            const node = getter();\r\n            if (!node) {\r\n                this.reportError(\r\n                    DiagCode.INTERNAL_ERROR,\r\n                    `Invalid AST: ${stmt.kind} node is null`\r\n                );\r\n                return null;\r\n            }\r\n\r\n            return handler(node);\r\n        }\r\n    }\r\n\r\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// SymbolResolver.ts – Symbol resolution phase.\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import * as AST                 from '@je-es/ast';\n    import { AnalysisPhase, ExpressionContext }\n                                    from '../components/ContextTracker';\n    import { DiagCode }             from '../components/DiagnosticManager';\n    import { Scope, Symbol, SymbolKind, ScopeKind }\n                                    from '../components/ScopeManager';\n    import { PathUtils }            from '../utils/PathUtils';\n    import { PhaseBase }            from '../interfaces/PhaseBase';\n    import { AnalysisConfig }       from '../ast-analyzer';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ TYPE ════════════════════════════════════════╗\n\n    interface ResolutionContext {\n        currentModule               : string;\n        moduleStack                 : string[];\n        cache             : Map<string, Symbol | null>;\n    }\n\n    interface FieldContext {\n        currentFieldIndex           : number;\n        parameters                  : Array<{ name: string; index: number }>;\n    }\n\n    interface ResolutionStats {\n        modulesProcessed            : number;\n        totalSymbols                : number;\n        resolvedSymbols             : number;\n        cachedResolutions           : number;\n        forwardReferences           : number;\n        selfReferences              : number;\n        importResolutions           : number;\n        structMethodsResolved       : number;\n        enumVariantsResolved        : number;\n        memberAccessResolved        : number;\n        anonymousTypesResolved      : number;\n        visibilityChecks            : number;\n        errors                      : number;\n        startTime                   : number;\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class SymbolResolver extends PhaseBase {\n\n        // ┌──────────────────────────────── INIT ────────────────────────────────┐\n\n            private stats                   : ResolutionStats           = this.initStats();\n            private resolutionCtx           : ResolutionContext         = this.initResolutionContext();\n            private currentIsStaticMethod   : boolean               = false;\n            private currentStructScope      : Scope | null          = null;\n\n            constructor( config : AnalysisConfig ) {\n                super(AnalysisPhase.Resolution, config);\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ────────────────────────────────┐\n\n            handle(): boolean {\n                try {\n                    this.log('verbose', 'Starting symbol resolution phase...');\n                    this.stats.startTime = Date.now();\n\n                    if (!this.init()) return false;\n                    if (!this.resolveAllModules()) return false;\n\n                    this.logStatistics();\n                    return !this.config.services.diagnosticManager.hasErrors();\n\n                } catch (error) {\n                    this.log('errors', `Fatal error during symbol resolution: ${error}`);\n                    this.reportError(DiagCode.INTERNAL_ERROR, `Fatal error during symbol resolution: ${error}`);\n                    return false;\n                }\n            }\n\n            reset(): void {\n                this.stats          = this.initStats();\n                this.resolutionCtx  = this.initResolutionContext();\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌────────────────────────── [1] Program Level ─────────────────────────┐\n\n            private resolveAllModules(): boolean {\n                this.log('verbose', 'Resolving symbols from all modules...');\n                const globalScope = this.config.services.scopeManager.getCurrentScope();\n\n                for (const [moduleName, module] of this.config.program!.modules) {\n                    this.config.services.contextTracker.pushContextSpan({ start: 0, end: 0 });\n                    try {\n                        if (!this.resolveModule(moduleName, module, globalScope)) {\n                            this.log('errors', `Failed to resolve module ${moduleName}, continuing...`);\n                        }\n                        this.stats.modulesProcessed++;\n                    } finally {\n                        this.config.services.contextTracker.popContextSpan();\n                    }\n                }\n\n                return true;\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌────────────────────────── [2] Module Level ──────────────────────────┐\n\n            private resolveModule(moduleName: string, module: AST.Module, parentScope: Scope): boolean {\n                this.log('symbols', `Resolving module '${moduleName}'`);\n\n                try {\n                    this.config.services.contextTracker.setModuleName(moduleName);\n\n                    if (typeof module.metadata?.path === 'string') {\n                        this.config.services.contextTracker.setModulePath(module.metadata.path);\n                    }\n\n                    this.enterModuleContext(moduleName, module);\n\n                    const moduleScope = this.findModuleScope(moduleName);\n                    if (!moduleScope) {\n                        this.reportError(DiagCode.MODULE_SCOPE_NOT_FOUND, `Module scope for '${moduleName}' not found`);\n                        return false;\n                    }\n\n                    this.config.services.scopeManager.setCurrentScope(moduleScope.id);\n                    this.config.services.contextTracker.setScope(moduleScope.id);;\n\n                    this.resetDeclaredFlags(moduleScope);\n\n                    for (const statement of module.statements) {\n                        this.resolveStmt(statement, moduleScope, moduleName);\n                    }\n\n                    this.exitModuleContext();\n                    return true;\n                } catch (error) {\n                    this.reportError(DiagCode.INTERNAL_ERROR, `Failed to resolve module '${moduleName}': ${error}`);\n                    return false;\n                }\n            }\n\n            private resetDeclaredFlags(scope: Scope): void {\n                for (const [_, symbol] of scope.symbols) {\n                    if (symbol.kind !== SymbolKind.Use && symbol.kind !== SymbolKind.Parameter) {\n                        symbol.declared = false;\n                    }\n                }\n\n                const childScopes = this.config.services.scopeManager.getAllScopes().filter(s => s.parent === scope.id);\n                for (const childScope of childScopes) {\n                    this.resetDeclaredFlags(childScope);\n                }\n            }\n\n            private enterModuleContext(moduleName: string, module: AST.Module): void {\n                this.resolutionCtx.moduleStack.push(this.resolutionCtx.currentModule);\n                this.resolutionCtx.currentModule = moduleName;\n                this.config.services.contextTracker.setModuleName(moduleName);\n                if (typeof module.metadata?.path === 'string') {\n                    this.config.services.contextTracker.setModulePath(module.metadata.path);\n                }\n            }\n\n            private exitModuleContext(): void {\n                const previousModule = this.resolutionCtx.moduleStack.pop();\n                this.resolutionCtx.currentModule = previousModule || '';\n            }\n\n            private findModuleScope(moduleName: string): Scope | null {\n                const moduleScope = this.config.services.scopeManager.findScopeByName(moduleName, ScopeKind.Module);\n                if (!moduleScope) {\n                    this.reportError(DiagCode.MODULE_SCOPE_NOT_FOUND, `Module scope for '${moduleName}' not found`);\n                }\n                return moduleScope;\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌─────────────────────────── [3] Stmt Level ───────────────────────────┐\n\n            private resolveStmt(stmt: AST.StmtNode, currentScope: Scope, moduleName?: string): void {\n                if (!stmt) {\n                    this.reportError(DiagCode.ANALYSIS_ERROR, 'Found null statement during resolution');\n                    return;\n                }\n\n                this.log('verbose', `Resolving ${stmt.kind} statement`);\n                this.config.services.contextTracker.pushContextSpan(stmt.span);\n\n                try {\n                    this.config.services.scopeManager.withScope(currentScope.id, () => {\n                        this.config.services.contextTracker.withSavedState(() => {\n                            this.config.services.contextTracker.setScope(currentScope.id);\n                            this.processStmtByKind(stmt, {\n                                'Block'     : (blockNode) => this.handleBlockStmt(blockNode, currentScope, moduleName),\n                                'Test'      : (testNode)  => this.handleTestStmt(testNode, currentScope, moduleName),\n                                'Use'       : (useNode)   => this.handleUseStmt(useNode, currentScope, moduleName),\n                                'Def'       : (defNode)   => this.handleDefStmt(defNode, currentScope, moduleName),\n                                'Let'       : (letNode)   => this.handleLetStmt(letNode, currentScope, moduleName),\n                                'Func'      : (funcNode)  => this.handleFuncStmt(funcNode, currentScope, moduleName),\n                                'Expression': (exprNode)  => this.resolveExprStmt(exprNode),\n\n                                // special cases\n                                'While'     : () => this.handleLoopStmt(stmt, currentScope, moduleName),\n                                'Do'        : () => this.handleLoopStmt(stmt, currentScope, moduleName),\n                                'For'       : () => this.handleLoopStmt(stmt, currentScope, moduleName),\n\n                                'Return'    : () => this.handleControlflowStmt(stmt, currentScope, moduleName),\n                                'Defer'     : () => this.handleControlflowStmt(stmt, currentScope, moduleName),\n                                'Throw'     : () => this.handleControlflowStmt(stmt, currentScope, moduleName),\n                            });\n                        });\n                    });\n                } catch (error) {\n                    this.reportError(\n                        DiagCode.ANALYSIS_ERROR,\n                        `Failed to resolve ${stmt.kind} statement: ${error}`,\n                        stmt.span\n                    );\n                } finally {\n                    this.config.services.contextTracker.popContextSpan();\n                }\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────── [3.1] BLOCK ─────────────────────────────┐\n\n            private handleBlockStmt(blockNode: AST.BlockStmtNode, scope?: Scope, moduleName?: string): void {\n                this.resolveBlockStmt(blockNode);\n            }\n\n            private resolveBlockStmt(block: AST.BlockStmtNode): void {\n                this.log('symbols', 'Resolving block');\n\n                const blockScope = this.config.services.scopeManager.findChildScopeByName('block', ScopeKind.Block);\n                if (blockScope) {\n                    this.config.services.contextTracker.withSavedState(() => {\n                        this.config.services.contextTracker.setScope(blockScope.id);\n\n                        this.config.services.scopeManager.withScope(blockScope.id, () => {\n                            for (const stmt of block.stmts) {\n                                this.resolveStmt(stmt, blockScope);\n                            }\n                        });\n                    });\n                }\n            }\n\n            private handleTestStmt(testNode: AST.TestStmtNode, scope?: Scope, moduleName?: string): void {\n                this.resolveBlockStmt(testNode.block);\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌───────────────────────────── [3.2] USE ──────────────────────────────┐\n\n            private handleUseStmt(useNode: AST.UseStmtNode, scope?: Scope, moduleName?: string): void {\n                this.resolveUseStmt(useNode);\n            }\n\n            private resolveUseStmt(useNode: AST.UseStmtNode): void {\n                this.log('symbols', 'Resolving use statement');\n                this.config.services.contextTracker.pushContextSpan(useNode.span);\n\n                try {\n                    if (useNode.path) {\n                        this.resolveModuleImport(useNode);\n                    } else {\n                        this.resolveLocalUse(useNode);\n                    }\n                    this.stats.importResolutions++;\n                } catch (error) {\n                    this.reportError(DiagCode.ANALYSIS_ERROR, `Failed to resolve use statement: ${error}`, useNode.span);\n                } finally {\n                    this.config.services.contextTracker.popContextSpan();\n                }\n            }\n\n            private resolveModuleImport(useNode: AST.UseStmtNode): void {\n                if (!this.config.program || !useNode.path) {\n                    this.reportError(DiagCode.MODULE_NOT_FOUND, 'Invalid import: missing path', useNode.span);\n                    return;\n                }\n\n                const currentModule = this.config.program.modules.get(this.resolutionCtx.currentModule);\n                const currentModulePath = currentModule?.metadata?.path as string | undefined;\n\n                // Handle wildcard import\n                if (!useNode.targetArr) {\n                    if (!useNode.alias) {\n                        this.reportError(\n                            DiagCode.ANALYSIS_ERROR,\n                            `Wildcard import requires an alias`,\n                            useNode.span\n                        );\n                        return;\n                    }\n\n                    const symbolName = useNode.alias.name;\n                    const existingSymbol = this.config.services.scopeManager.getSymbolInCurrentScope(symbolName);\n\n                    if (!existingSymbol || existingSymbol.kind !== SymbolKind.Use) {\n                        return;\n                    }\n\n                    if (!PathUtils.validatePath(this.config.program, useNode.path, currentModulePath)) {\n                        return;\n                    }\n\n                    const resolvedPath = PathUtils.resolveModulePath(this.config.program, useNode.path, currentModulePath);\n                    const targetModuleName = PathUtils.findModuleNameByPath(this.config.program, resolvedPath);\n\n                    if (!targetModuleName) {\n                        this.reportError(DiagCode.MODULE_NOT_FOUND, `Could not resolve module name for path: ${useNode.path}`, useNode.span);\n                        return;\n                    }\n\n                    const targetModuleScope = this.findModuleScope(targetModuleName);\n                    if (!targetModuleScope) {\n                        this.reportError(DiagCode.MODULE_SCOPE_NOT_FOUND, `Could not find scope for module: ${targetModuleName}`, useNode.span);\n                        return;\n                    }\n\n                    // Mark as declared and resolved\n                    existingSymbol.declared = true;\n                    existingSymbol.type = AST.TypeNode.asIdentifier(useNode.span, targetModuleName);\n\n                    this.log('verbose', `Resolved wildcard import from '${targetModuleName}' as '${symbolName}'`);\n                    return;\n                }\n\n                // Only report MODULE_NOT_FOUND if it wasn't already reported in collection phase\n                const symbolName = useNode.alias ? useNode.alias.name : useNode.targetArr[useNode.targetArr.length - 1].name;\n                const existingSymbol = this.config.services.scopeManager.getSymbolInCurrentScope(symbolName);\n\n                if (!existingSymbol || existingSymbol.kind !== SymbolKind.Use) {\n                    // Symbol wasn't collected, so module wasn't found in collection phase\n                    // Don't report duplicate error\n                    return;\n                }\n\n                if (!PathUtils.validatePath(this.config.program, useNode.path, currentModulePath)) {\n                    // Only report if this is a new error case\n                    if (!existingSymbol.importSource) {\n                        this.reportError(DiagCode.MODULE_NOT_FOUND, `Module not found: ${useNode.path}`, useNode.span);\n                    }\n                    return;\n                }\n\n                const resolvedPath = PathUtils.resolveModulePath(this.config.program, useNode.path, currentModulePath);\n                const targetModuleName = PathUtils.findModuleNameByPath(this.config.program, resolvedPath);\n\n                if (!targetModuleName) {\n                    this.reportError(DiagCode.MODULE_NOT_FOUND, `Could not resolve module name for path: ${useNode.path}`, useNode.span);\n                    return;\n                }\n\n                const targetModuleScope = this.findModuleScope(targetModuleName);\n                if (!targetModuleScope) {\n                    this.reportError(DiagCode.MODULE_SCOPE_NOT_FOUND, `Could not find scope for module: ${targetModuleName}`, useNode.span);\n                    return;\n                }\n\n                this.resolveModuleWithScope(useNode, targetModuleName, targetModuleScope);\n            }\n\n            private resolveModuleWithScope(useNode: AST.UseStmtNode, targetModuleName: string, targetModuleScope: Scope): void {\n                const originalScope = this.config.services.scopeManager.getCurrentScope();\n                const originalContext = this.saveModuleContext();\n\n                try {\n                    this.switchToTargetModule(targetModuleName, targetModuleScope);\n                    const targetSymbol = this.resolveImportTarget(useNode);\n                    if (targetSymbol) {\n                        this.propagateImportType(useNode, targetSymbol, originalScope);\n                    }\n                } finally {\n                    this.restoreModuleContext(originalContext, originalScope);\n                }\n            }\n\n            private resolveLocalUse(useNode: AST.UseStmtNode): void {\n                // Wildcard local use doesn't make sense\n                if (!useNode.targetArr) {\n                    this.reportError(\n                        DiagCode.ANALYSIS_ERROR,\n                        `Wildcard import only supported for module imports (use * as x from \"...\")`,\n                        useNode.span\n                    );\n                    return;\n                }\n\n                const targetName = useNode.targetArr[0].name;\n                const targetSymbol = this.config.services.scopeManager.lookupSymbol(targetName);\n\n                if (targetSymbol && !targetSymbol.declared) {\n                    this.reportError(\n                        DiagCode.USED_BEFORE_DECLARED,\n                        `Symbol '${targetName}' used before declaration`,\n                        useNode.targetArr[0].span\n                    );\n                    return;\n                }\n\n                this.resolveExprStmt(this.identOrMemberAccess(useNode.targetArr));\n                if (useNode.alias) {\n                    this.markAliasAsDeclared(useNode.alias);\n                }\n            }\n\n            private identOrMemberAccess(nodes: AST.IdentNode[]): AST.ExprNode {\n                // Safety check for empty array\n                if (nodes.length === 0) {\n                    throw new Error('Cannot create identifier expression from empty array');\n                }\n\n                const base = AST.ExprNode.asIdent(nodes[0].span, nodes[0].name, nodes[0].builtin);\n                if (nodes.length === 1) return base;\n                return AST.ExprNode.asMemberAccess(nodes[0].span, base, this.identOrMemberAccess(nodes.slice(1)));\n            }\n\n            private saveModuleContext() {\n                return {\n                    moduleName: this.config.services.contextTracker.getModuleName(),\n                    modulePath: this.config.services.contextTracker.getModulePath()\n                };\n            }\n\n            private switchToTargetModule(targetModule: string, targetModuleScope: Scope): void {\n                this.config.services.scopeManager.setCurrentScope(targetModuleScope.id);\n                this.config.services.contextTracker.setModuleName(targetModule);\n                const targetModulePath = this.config.program!.modules.get(targetModule)?.metadata?.path;\n                if (targetModulePath) {\n                    this.config.services.contextTracker.setModulePath(targetModulePath as string);\n                }\n            }\n\n            private restoreModuleContext(originalContext: any, originalScope: Scope): void {\n                this.config.services.contextTracker.setModuleName(originalContext.moduleName);\n                this.config.services.contextTracker.setModulePath(originalContext.modulePath);\n                this.config.services.scopeManager.setCurrentScope(originalScope.id);\n            }\n\n            private resolveImportTarget(useNode: AST.UseStmtNode): Symbol | null {\n                // Handle wildcard import\n                if (!useNode.targetArr) {\n                    // For wildcard, just check module exists (already validated in resolveModuleImport)\n                    if (!useNode.alias) {\n                        this.reportError(\n                            DiagCode.ANALYSIS_ERROR,\n                            'Wildcard import requires an alias',\n                            useNode.span\n                        );\n                        return null;\n                    }\n\n                    // Return a synthetic \"module namespace\" symbol\n                    // The actual exported symbols are validated during member access\n                    const moduleSymbol = this.config.services.scopeManager.getSymbolInCurrentScope(useNode.alias.name);\n                    if (moduleSymbol) {\n                        moduleSymbol.declared = true;\n                    }\n                    return moduleSymbol;\n                }\n\n                const targetName = useNode.targetArr[0].name;\n                if (!targetName) return null;\n\n                const targetSymbol = this.config.services.scopeManager.getSymbolInCurrentScope(targetName);\n                if (targetSymbol) {\n                    targetSymbol.declared = true;\n\n                    if (useNode.targetArr.length > 1) {\n                        let currentSymbol: Symbol | null = targetSymbol;\n\n                        for (let i = 1; i < useNode.targetArr.length; i++) {\n                            const memberName = useNode.targetArr[i].name;\n\n                            if (!currentSymbol || !currentSymbol.type) {\n                                this.reportError(\n                                    DiagCode.SYMBOL_NOT_FOUND,\n                                    `Cannot resolve member path: ${useNode.targetArr.slice(0, i + 1).map((t:AST.IdentNode) => t.name).join('.')}`,\n                                    useNode.targetArr[i].span\n                                );\n                                return null;\n                            }\n\n                            const memberSymbol = this.resolveMemberInType(currentSymbol.type, memberName);\n                            if (!memberSymbol) {\n                                this.reportError(\n                                    DiagCode.SYMBOL_NOT_FOUND,\n                                    `Member '${memberName}' not found in type`,\n                                    useNode.targetArr[i].span\n                                );\n                                return null;\n                            }\n\n                            currentSymbol = memberSymbol;\n                            currentSymbol.used = true;\n                        }\n\n                        return currentSymbol;\n                    }\n\n                    return targetSymbol;\n                }\n                return null;\n            }\n\n            private resolveMemberInType(type: AST.TypeNode, memberName: string): Symbol | null {\n                // Unwrap optional types first\n                if (type.kind === 'optional') {\n                    const optional = type.getOptional()!;\n                    return this.resolveMemberInType(optional.target, memberName);\n                }\n\n                // Handle struct types - IMPROVED\n                if (type.kind === 'struct') {\n                    const struct = type.getStruct()!;\n                    const scopeId = struct.metadata?.scopeId as number | undefined;\n                    if (scopeId !== undefined) {\n                        const typeScope = this.config.services.scopeManager.getScope(scopeId);\n                        // First check for fields\n                        const fieldSymbol = typeScope.symbols.get(memberName);\n                        if (fieldSymbol && fieldSymbol.kind === SymbolKind.StructField) {\n                            return fieldSymbol;\n                        }\n\n                        // Then check for methods\n                        const methodSymbol = typeScope.symbols.get(memberName);\n                        if (methodSymbol && methodSymbol.kind === SymbolKind.Function) {\n                            return methodSymbol;\n                        }\n                    }\n                    return null;\n                }\n\n                // Handle enum types\n                if (type.kind === 'enum') {\n                    const enumType = type.getEnum()!;\n                    const scopeId = enumType.metadata?.scopeId as number | undefined;\n                    if (scopeId !== undefined) {\n                        const typeScope = this.config.services.scopeManager.getScope(scopeId);\n                        const variantSymbol = typeScope.symbols.get(memberName);\n                        if (variantSymbol && variantSymbol.kind === SymbolKind.EnumVariant) {\n                            return variantSymbol;\n                        }\n                    }\n                    return null;\n                }\n\n                // Handle identifier types (type aliases)\n                if (type.kind === 'ident') {\n                    const ident = type.getIdent()!;\n                    const typeSymbol = this.config.services.scopeManager.lookupSymbol(ident.name);\n                    if (typeSymbol?.type) {\n                        return this.resolveMemberInType(typeSymbol.type, memberName);\n                    }\n                }\n\n                return null;\n            }\n\n            private propagateImportType(useNode: AST.UseStmtNode, targetSymbol: Symbol, originalScope: Scope): void {\n                // Handle both wildcard and specific imports\n                const importName = useNode.alias\n                    ? useNode.alias.name\n                    : useNode.targetArr\n                        ? useNode.targetArr[useNode.targetArr.length - 1].name\n                        : '<invalid>';\n\n                if (!importName || importName === '<invalid>') return;\n\n                const importSymbol = originalScope.symbols.get(importName);\n                if (importSymbol) {\n                    // For wildcard, type points to the module itself (as identifier)\n                    // For specific imports, type is the actual symbol type\n                    importSymbol.type = targetSymbol.type;\n                    importSymbol.declared = true;\n                }\n            }\n\n            private markAliasAsDeclared(alias: AST.IdentNode): void {\n                const aliasSymbol = this.config.services.scopeManager.getSymbolInCurrentScope(alias.name);\n                if (aliasSymbol) {\n                    aliasSymbol.declared = true;\n                    this.config.services.contextTracker.startDeclaration(alias.name, aliasSymbol.id, 'let', alias.span, this.config.services.scopeManager.getCurrentScope().id);\n                }\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌───────────────────────────── [3.3] DEF ──────────────────────────────┐\n\n            private handleDefStmt(defNode: AST.DefStmtNode, scope?: Scope, moduleName?: string): void {\n                this.resolveDefStmt(defNode);\n            }\n\n            private resolveDefStmt(defNode: AST.DefStmtNode): void {\n                this.log('symbols', `Resolving definition '${defNode.ident.name}'`);\n\n                const symbol = this.config.services.scopeManager.getSymbolInCurrentScope(defNode.ident.name);\n                if (!symbol) {\n                    this.reportError(DiagCode.INTERNAL_ERROR, `Definition symbol '${defNode.ident.name}' not found in current scope`, defNode.ident.span);\n                    return;\n                }\n\n                this.config.services.contextTracker.startDeclaration(defNode.ident.name, symbol.id, 'def', defNode.span, this.config.services.scopeManager.getCurrentScope().id);\n                symbol.declared = true;\n                this.resolveType(defNode.type, symbol);\n                this.config.services.contextTracker.completeDeclaration(symbol.id);\n                this.stats.resolvedSymbols++;\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌───────────────────────────── [3.4] LET ──────────────────────────────┐\n\n            private handleLetStmt(letNode: AST.LetStmtNode, scope?: Scope, moduleName?: string): void {\n                this.resolveLetStmt(letNode);\n            }\n\n            private resolveLetStmt(letNode: AST.LetStmtNode): void {\n                this.log('symbols', `Resolving let '${letNode.field.ident.name}'`);\n\n                const symbol = this.config.services.scopeManager.getSymbolInCurrentScope(letNode.field.ident.name);\n                if (!symbol) {\n                    this.reportError(DiagCode.INTERNAL_ERROR, `Variable symbol '${letNode.field.ident.name}' not found in current scope`, letNode.field.ident.span);\n                    return;\n                }\n\n                this.config.services.contextTracker.startDeclaration(letNode.field.ident.name, symbol.id, 'let', letNode.field.span, this.config.services.scopeManager.getCurrentScope().id);\n\n                if (letNode.field.initializer) {\n                    if (this.isConstructorExpression(letNode.field.initializer)) {\n                        const primary = letNode.field.initializer.getPrimary()!;\n                        const obj = primary.getObject()!;\n                        const constructorName = obj.ident!.name;\n\n                        const constructorSymbol = this.config.services.scopeManager.lookupSymbol(constructorName);\n                        if (constructorSymbol && constructorSymbol.type) {\n                            // Validate constructor fields\n                            const isValid = this.validateConstructorFields(obj, constructorSymbol.type);\n\n                            if (isValid) {\n                                // Set type only if validation passed\n                                symbol.type = constructorSymbol.type;\n                                letNode.field.type = constructorSymbol.type;\n                            } else {\n                                // Validation failed - abort\n                                this.config.services.contextTracker.completeDeclaration(symbol.id);\n                                return;\n                            }\n                        }\n                    } else if (letNode.field.initializer.kind === 'Primary') {\n                        const primary = letNode.field.initializer.getPrimary();\n                        if (primary && primary.kind === 'Type') {\n                            const anonType = primary.getType()!;\n                            this.resolveType(anonType, symbol);\n                            symbol.type = anonType;\n                            letNode.field.type = anonType;\n                            this.stats.anonymousTypesResolved++;\n                        }\n                    }\n\n                    // Resolve initializer expressions\n                    this.resolveVariableInitializer(letNode, symbol);\n                }\n\n                symbol.declared = true;\n\n                if (letNode.field.type && !this.resolveType(letNode.field.type, symbol, letNode.field.span)) {\n                    return;\n                }\n\n                this.config.services.contextTracker.completeDeclaration(symbol.id);\n                this.stats.resolvedSymbols++;\n            }\n\n            private isConstructorExpression(expr: AST.ExprNode): boolean {\n                if (expr.kind !== 'Primary') {\n                    return false;\n                }\n\n                const primary = expr.getPrimary();\n                if (!primary || primary.kind !== 'Object') {\n                    return false;\n                }\n\n                const obj = primary.getObject();\n                if (!obj) {\n                    return false;\n                }\n\n                // An Object is a constructor if it has an ident (the type name)\n                // Example: Point { x: 10, y: 20 }\n                //          ^^^^^              ← This is obj.ident\n                const hasConstructorName =\n                    obj.ident !== null &&\n                    obj.ident !== undefined &&\n                    typeof obj.ident.name === 'string' &&\n                    obj.ident.name.length > 0;\n\n                return hasConstructorName;\n            }\n\n            private validateConstructorFields(obj: AST.ObjectNode, type: AST.TypeNode): boolean {\n                if (type.kind !== 'struct') return true;\n\n                const struct = type.getStruct()!;\n                const scopeId = struct.metadata?.scopeId as number | undefined;\n\n                if (scopeId === undefined) {\n                    this.log('verbose', 'Cannot validate constructor: struct has no scope');\n                    return true; // Can't validate without scope\n                }\n\n                const typeScope = this.config.services.scopeManager.getScope(scopeId);\n                const providedFields = new Set<string>();\n                let hasError = false;\n\n                // ============================================================================\n                // STEP 1: Check for INVALID fields (fields that don't exist in struct)\n                // ============================================================================\n                for (const prop of obj.props) {\n                    const fieldName = prop.key.name;\n                    providedFields.add(fieldName);\n\n                    const fieldSymbol = typeScope.symbols.get(fieldName);\n\n                    if (!fieldSymbol || fieldSymbol.kind !== SymbolKind.StructField) {\n                        this.reportError(\n                            DiagCode.SYMBOL_NOT_FOUND,\n                            `Member '${fieldName}' not found in struct`,\n                            prop.key.span\n                        );\n                        hasError = true; // Mark error\n                        // Continue checking other fields to report all errors\n                    } else {\n                        // Field exists - resolve its value expression\n                        if (prop.val) {\n                            this.resolveExprStmt(prop.val);\n                        }\n                    }\n                }\n\n                // ============================================================================\n                // STEP 2: Check for MISSING required fields\n                // ============================================================================\n                for (const [fieldName, fieldSymbol] of typeScope.symbols) {\n                    // Only check struct fields (not methods)\n                    if (fieldSymbol.kind === SymbolKind.StructField) {\n                        // Field is required if: not provided AND has no default value\n                        const isRequired = !providedFields.has(fieldName) && !fieldSymbol.initialized;\n\n                        if (isRequired) {\n                            this.reportError(\n                                DiagCode.SYMBOL_NOT_FOUND,\n                                `Required field '${fieldName}' not provided in constructor`,\n                                obj.span\n                            );\n                            hasError = true; // Mark error\n                        }\n                    }\n                }\n\n                // Return false if ANY error was found\n                return !hasError;\n            }\n\n            private resolveVariableInitializer(varNode: AST.LetStmtNode, symbol: Symbol): boolean {\n                this.config.services.contextTracker.startInitialization(symbol.id);\n                this.config.services.contextTracker.enterExpression(ExpressionContext.VariableInitializer, varNode.field.initializer!.span, symbol.id);\n                this.resolveExprStmt(varNode.field.initializer!, undefined, undefined, symbol!);\n                this.config.services.contextTracker.exitExpression();\n                return true;\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌───────────────────────────── [3.5] FUNC ─────────────────────────────┐\n\n            private handleFuncStmt(funcNode: AST.FuncStmtNode, scope?: Scope, moduleName?: string): void {\n                this.resolveFuncStmt(funcNode);\n            }\n\n            private resolveFuncStmt(funcNode: AST.FuncStmtNode): void {\n                this.log('symbols', `Resolving function '${funcNode.ident.name}'`);\n\n                const funcSymbol = this.config.services.scopeManager.getSymbolInCurrentScope(funcNode.ident.name);\n                if (!funcSymbol) {\n                    this.reportError(\n                        DiagCode.CANNOT_INFER_TYPE,\n                        `Function '${funcNode.ident.name}' symbol not found`,\n                        funcNode.span\n                    );\n                    return;\n                }\n\n                const funcScope = this.config.services.scopeManager.findChildScopeByName(funcNode.ident.name, ScopeKind.Function);\n                if (!funcScope) {\n                    this.reportError(\n                        DiagCode.CANNOT_INFER_TYPE,\n                        `Function scope for '${funcNode.ident.name}' not found`,\n                        funcNode.span\n                    );\n                    return;\n                }\n\n                this.config.services.contextTracker.startDeclaration(\n                    funcNode.ident.name,\n                    funcSymbol.id,\n                    'fn',\n                    funcNode.span,\n                    this.config.services.scopeManager.getCurrentScope().id\n                );\n                funcSymbol.declared = true;\n\n                // Get the scope where the function is defined to check if it's in a struct\n                const funcSymbolScope = this.config.services.scopeManager.getScope(funcSymbol.scope);\n                const parentScope = funcSymbolScope.parent !== null\n                    ? this.config.services.scopeManager.getScope(funcSymbolScope.parent)\n                    : null;\n\n                const isStaticMethod = parentScope?.kind === ScopeKind.Type &&\n                                    parentScope.metadata?.typeKind === 'Struct' &&\n                                    funcNode.visibility.kind === 'Static';\n\n                // Store context for validation\n                const previousIsStaticMethod = this.currentIsStaticMethod;\n                const previousStructScope = this.currentStructScope;\n\n                this.currentIsStaticMethod = isStaticMethod;\n                this.currentStructScope = isStaticMethod ? parentScope : null;\n\n                const isStructMethod = parentScope?.kind === ScopeKind.Type &&\n                                    parentScope.metadata?.typeKind === 'Struct' &&\n                                    !(funcNode.visibility.kind === 'Static');\n\n                try {\n                    this.config.services.contextTracker.withSavedState(() => {\n                        this.config.services.scopeManager.withScope(funcScope.id, () => {\n                            // Resolve self parameter if struct method\n                            if (isStructMethod) {\n                                this.resolveSelfParameter(funcScope, parentScope!);\n                            }\n\n                            // Validate parameters\n                            this.resolveParameters(funcNode.parameters);\n\n                            // Build parameter types INCLUDING self for struct methods\n                            const paramTypes: AST.TypeNode[] = [];\n\n                            // Add self parameter type FIRST for struct methods\n                            if (isStructMethod) {\n                                const selfSymbol = funcScope.symbols.get('self');\n                                if (selfSymbol?.type) {\n                                    paramTypes.push(selfSymbol.type);\n                                } else {\n                                    // Self should always exist for struct methods\n                                    this.reportError(\n                                        DiagCode.INTERNAL_ERROR,\n                                        `Struct method '${funcNode.ident.name}' missing 'self' parameter`,\n                                        funcNode.span\n                                    );\n                                }\n                            }\n\n                            // Then add explicit parameters\n                            for (const param of funcNode.parameters) {\n                                if (param.type) {\n                                    paramTypes.push(param.type);\n                                } else {\n                                    const paramSymbol = funcScope.symbols.get(param.ident.name);\n                                    if (paramSymbol?.type) {\n                                        paramTypes.push(paramSymbol.type);\n                                    } else {\n                                        this.reportError(\n                                            DiagCode.CANNOT_INFER_TYPE,\n                                            `Cannot infer type for parameter '${param.ident.name}'`,\n                                            param.span\n                                        );\n                                        paramTypes.push(AST.TypeNode.asUndefined(param.span));\n                                    }\n                                }\n                            }\n\n                            // Resolve return type\n                            let returnType: AST.TypeNode | null = null;\n                            if (funcNode.returnType) {\n                                const tempReturnSymbol: Symbol = {\n                                    id: -1,\n                                    name: '<return-type>',\n                                    kind: SymbolKind.Variable,\n                                    type: null,\n                                    scope: funcScope.id,\n                                    contextSpan: funcNode.returnType.span,\n                                    declared: true,\n                                    initialized: true,\n                                    used: false,\n                                    isTypeChecked: false,\n                                    visibility: { kind: 'Private' },\n                                    mutability: { kind: 'Immutable' },\n                                    isExported: false\n                                };\n                                this.resolveType(funcNode.returnType, tempReturnSymbol);\n                                returnType = funcNode.returnType;\n                            }\n\n                            // Resolve and validate error type\n                            if (funcNode.errorType) {\n                                const tempErrorSymbol: Symbol = {\n                                    id: -1,\n                                    name: '<func-error-type>',\n                                    kind: SymbolKind.Variable,\n                                    type: null,\n                                    scope: funcScope.id,\n                                    contextSpan: funcNode.errorType.span,\n                                    declared: true,\n                                    initialized: true,\n                                    used: false,\n                                    isTypeChecked: false,\n                                    visibility: { kind: 'Private' },\n                                    mutability: { kind: 'Immutable' },\n                                    isExported: false\n                                };\n\n                                if (!this.resolveType(funcNode.errorType, tempErrorSymbol, funcNode.span)) {\n                                    funcSymbol.isTypeChecked = true;\n                                    return;\n                                }\n\n                                // REFINE ERROR MODE after resolution\n                                const refinedMode = this.refineErrorMode(funcNode.errorType, funcSymbol);\n                                if (funcSymbol.metadata) {\n                                    funcSymbol.metadata.errorMode = refinedMode;\n\n                                    // Update self-group errors if needed\n                                    if (refinedMode === 'self-group') {\n                                        funcSymbol.metadata.selfGroupErrors = this.extractSelfGroupErrors(funcNode.errorType);\n                                    }\n                                }\n\n                                // Validate identifier error types\n                                if (funcNode.errorType.isIdent()) {\n                                    const errorIdent = funcNode.errorType.getIdent()!;\n\n                                    if (!errorIdent.builtin) {\n                                        const errorSymbol = this.config.services.scopeManager.lookupSymbol(errorIdent.name);\n\n                                        if (!errorSymbol) {\n                                            this.reportError(\n                                                DiagCode.UNDEFINED_IDENTIFIER,\n                                                `Error type '${errorIdent.name}' is not defined`,\n                                                funcNode.errorType.span\n                                            );\n                                            funcSymbol.isTypeChecked = true;\n                                            return;\n                                        }\n\n                                        // Validate it's actually an error type\n                                        if (errorSymbol.type && !errorSymbol.type.isErrset() && !errorSymbol.type.isErr()) {\n                                            this.reportError(\n                                                DiagCode.TYPE_MISMATCH,\n                                                `'${errorIdent.name}' is not an error type`,\n                                                funcNode.errorType.span\n                                            );\n                                            funcSymbol.isTypeChecked = true;\n                                            return;\n                                        }\n                                    }\n                                }\n                            }\n\n                            // Build complete function type\n                            funcSymbol.type = AST.TypeNode.asFunction(\n                                funcNode.span,\n                                paramTypes,\n                                returnType || AST.TypeNode.asVoid(funcNode.span),\n                                funcNode.errorType\n                            );\n\n                            // Resolve function body\n                            if (funcNode.body) {\n                                this.config.services.contextTracker.enterExpression(\n                                    ExpressionContext.FunctionBody,\n                                    funcNode.body.span\n                                );\n                                this.resolveStmt(funcNode.body, funcScope);\n                                this.config.services.contextTracker.exitExpression();\n                            }\n                        });\n                    });\n\n                    if (isStructMethod) {\n                        this.stats.structMethodsResolved++;\n                    }\n                } finally {\n                    this.config.services.contextTracker.completeDeclaration(funcSymbol.id);\n                    // Restore context\n                    this.currentIsStaticMethod = previousIsStaticMethod;\n                    this.currentStructScope = previousStructScope;\n                }\n\n                funcSymbol.isTypeChecked = true;\n                this.stats.resolvedSymbols++;\n            }\n\n            private refineErrorMode(\n                errorType: AST.TypeNode,\n                funcSymbol: Symbol\n            ): 'err-ident' | 'err-group' | 'any-error' | 'self-group' {\n                if (errorType.isErr()) {\n                    return 'any-error';\n                }\n\n                if (errorType.isErrset()) {\n                    return 'self-group';\n                }\n\n                if (errorType.isIdent()) {\n                    const ident = errorType.getIdent()!;\n                    const symbol = this.config.services.scopeManager.lookupSymbol(ident.name);\n\n                    if (symbol?.kind === SymbolKind.Variable && symbol.type?.isErr()) {\n                        return 'err-ident';\n                    }\n\n                    if (symbol?.kind === SymbolKind.Definition && symbol.type?.isErrset()) {\n                        return 'err-group';\n                    }\n                }\n\n                return 'any-error';\n            }\n\n            private extractSelfGroupErrors(errorType: AST.TypeNode): string[] {\n                if (!errorType.isErrset()) return [];\n                const errset = errorType.getErrset()!;\n                return errset.members.map(m => m.name);\n            }\n\n            private resolveSelfParameter(funcScope: Scope, structScope: Scope): void {\n                const selfSymbol = funcScope.symbols.get('self');\n                if (!selfSymbol) {\n                    this.log('verbose', `Warning: Expected 'self' parameter in struct method but not found`);\n                    return;\n                }\n\n                // Mark self as declared and used in resolution phase\n                selfSymbol.declared = true;\n\n                // Resolve self's type (should point to parent struct)\n                if (selfSymbol.type) {\n                    // Validate that the type references the correct struct\n                    if (selfSymbol.type.kind === 'ident') {\n                        const typeIdent = selfSymbol.type.getIdent()!;\n                        if (typeIdent.name !== structScope.name) {\n                            this.reportError(\n                                DiagCode.TYPE_MISMATCH,\n                                `Self type mismatch: expected '${structScope.name}', got '${typeIdent.name}'`,\n                                selfSymbol.contextSpan\n                            );\n                        }\n                    }\n                }\n\n                this.log('symbols', `Resolved 'self' parameter in struct method`);\n            }\n\n            // ───── PARAMS ─────\n\n            private resolveParameters(parameters: AST.FieldNode[]): void {\n                const fieldInfo = parameters.map((param, index) => ({ name: param.ident.name, index }));\n                for (let i = 0; i < parameters.length; i++) {\n                    this.resolveParameter(parameters[i], i, fieldInfo);\n                }\n            }\n\n            private resolveParameter(param: AST.FieldNode, index: number, fieldInfo: Array<{ name: string; index: number }>): void {\n                const paramSymbol = this.config.services.scopeManager.getSymbolInCurrentScope(param.ident.name);\n                if (!paramSymbol) return;\n\n                this.config.services.contextTracker.startDeclaration(param.ident.name, paramSymbol.id, 'Param', param.span, this.config.services.scopeManager.getCurrentScope().id);\n                paramSymbol.declared = true;\n\n                if (param.type) {\n                    this.resolveType(param.type, paramSymbol);\n                }\n\n                if (param.initializer) {\n                    this.resolveParameterInitializer(param, index, fieldInfo);\n                }\n\n                this.config.services.contextTracker.completeDeclaration(paramSymbol.id);\n                this.stats.resolvedSymbols++;\n            }\n\n            private resolveParameterInitializer(param: AST.FieldNode, currentFieldIndex: number, fieldInfo: Array<{ name: string; index: number }>): void {\n                const paramSymbol = this.config.services.scopeManager.getSymbolInCurrentScope(param.ident.name)!;\n                this.config.services.contextTracker.startInitialization(paramSymbol.id);\n                this.config.services.contextTracker.enterExpression(ExpressionContext.ParameterInitializer, param.initializer!.span, paramSymbol.id);\n\n                const parameterContext: FieldContext = { currentFieldIndex, parameters: fieldInfo };\n                this.resolveExprStmt(param.initializer!, param.span, parameterContext, paramSymbol);\n                this.config.services.contextTracker.exitExpression();\n            }\n\n            // ───── FIELDS ─────\n\n            private resolveFields(fields: AST.FieldNode[]): void {\n                const fieldInfo = fields.map((field, index) => ({ name: field.ident.name, index }));\n                for (let i = 0; i < fields.length; i++) {\n                    this.resolveField(fields[i], i, fieldInfo);\n                }\n            }\n\n            private resolveField(field: AST.FieldNode, index: number, fieldInfo: Array<{ name: string; index: number }>): void {\n                const fieldSymbol = this.config.services.scopeManager.getSymbolInCurrentScope(field.ident.name);\n                if (!fieldSymbol) return;\n\n                this.config.services.contextTracker.startDeclaration(field.ident.name, fieldSymbol.id, 'Param', field.span, this.config.services.scopeManager.getCurrentScope().id);\n                fieldSymbol.declared = true;\n\n                if (field.type) {\n                    this.resolveType(field.type, fieldSymbol);\n                }\n\n                if (field.initializer) {\n                    this.resolveFieldInitializer(field, index, fieldInfo);\n                }\n\n                this.config.services.contextTracker.completeDeclaration(fieldSymbol.id);\n                this.stats.resolvedSymbols++;\n            }\n\n            private resolveFieldInitializer(field: AST.FieldNode, currentFieldIndex: number, fieldInfo: Array<{ name: string; index: number }>): void {\n                const fieldSymbol = this.config.services.scopeManager.getSymbolInCurrentScope(field.ident.name)!;\n                this.config.services.contextTracker.startInitialization(fieldSymbol.id);\n                this.config.services.contextTracker.enterExpression(ExpressionContext.ParameterInitializer, field.initializer!.span, fieldSymbol.id);\n\n                const fieldContext: FieldContext = { currentFieldIndex, parameters: fieldInfo };\n                this.resolveExprStmt(field.initializer!, field.span, fieldContext, fieldSymbol);\n                this.config.services.contextTracker.exitExpression();\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌───────────────────────────── [3.6] LOOP ─────────────────────────────┐\n\n            private handleLoopStmt(stmt: AST.StmtNode, scope?: Scope, moduleName?: string): void {\n                if(stmt.getLoop === undefined) {\n                    const data = stmt;\n                    switch (stmt.kind) {\n                        case 'While' : {\n                            const src = data.source as AST.LoopStmtNode;\n                            const loop = AST.LoopStmtNode.createWhile(data.span, src.expr, src.stmt);\n                            this.resolveLoopStmt(loop);\n                            break;\n                        }\n                        case 'Do' : {\n                            const src = data.source as AST.LoopStmtNode;\n                            const loop = AST.LoopStmtNode.createDo(data.span, src.expr, src.stmt);\n                            this.resolveLoopStmt(loop);\n                            break;\n                        }\n                        case 'For' : {\n                            const src = data.source as AST.LoopStmtNode;\n                            const loop = AST.LoopStmtNode.createFor(data.span, src.expr, src.stmt);\n                            this.resolveLoopStmt(loop);\n                            break;\n                        }\n                    }\n                } else {\n                    this.resolveLoopStmt(stmt.getLoop()!);\n                }\n            }\n\n            private resolveLoopStmt(loopStmt: AST.LoopStmtNode): void {\n                this.log('symbols', 'Resolving loop statement');\n\n                const loopScope = this.config.services.scopeManager.findChildScopeByName('loop', ScopeKind.Loop);\n                if (loopScope) {\n                    this.config.services.contextTracker.withSavedState(() => {\n                        this.config.services.contextTracker.setScope(loopScope.id);\n\n                        this.config.services.scopeManager.withScope(loopScope.id, () => {\n                            if (loopStmt.kind === 'While') {\n                                if (loopStmt.expr) this.resolveExprStmt(loopStmt.expr);\n                                if (loopStmt.stmt) this.resolveStmt(loopStmt.stmt, loopScope);\n                            } else if (loopStmt.kind === 'Do') {\n                                if (loopStmt.stmt) this.resolveStmt(loopStmt.stmt, loopScope);\n                                if (loopStmt.expr) this.resolveExprStmt(loopStmt.expr);\n                            } else if (loopStmt.kind === 'For') {\n                                if (loopStmt.expr) this.resolveExprStmt(loopStmt.expr);\n                                if (loopStmt.stmt) this.resolveStmt(loopStmt.stmt, loopScope);\n                            }\n                        });\n                    });\n                }\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────── [3.7] CTRLFLOW ──────────────────────────┐\n\n            private handleControlflowStmt(stmt: AST.StmtNode, scope?: Scope, moduleName?: string): void {\n                if(stmt.getCtrlflow === undefined) {\n                    const data = stmt;\n                    switch (stmt.kind) {\n                        case 'Return' : {\n                            const src = data.source as AST.ControlFlowStmtNode;\n                            const res = AST.ControlFlowStmtNode.asReturn(data.span, src.value);\n                            this.resolveReturnStmt(res);\n                            break;\n                        }\n                        case 'Defer' : {\n                            const src = data.source as AST.ControlFlowStmtNode;\n                            const res = AST.ControlFlowStmtNode.asDefer(data.span, src.value);\n                            this.resolveDeferStmt(res);\n                            break;\n                        }\n                        case 'Throw' : {\n                            const src = data.source as AST.ControlFlowStmtNode;\n                            const res = AST.ControlFlowStmtNode.asThrow(data.span, src.value);\n                            this.resolveThrowStmt(res);\n                            break;\n                        }\n                    }\n                } else {\n                    switch (stmt.getCtrlflow()!.kind) {\n                        case 'return' : {\n                            this.resolveReturnStmt(stmt.getCtrlflow()!);\n                            break;\n                        }\n                        case 'defer' : {\n                            this.resolveDeferStmt(stmt.getCtrlflow()!);\n                            break;\n                        }\n                        case 'throw' : {\n                            this.resolveThrowStmt(stmt.getCtrlflow()!);\n                            break;\n                        }\n                    }\n                }\n            }\n\n            private resolveReturnStmt(returnNode: AST.ControlFlowStmtNode): void {\n                this.log('symbols', 'Resolving return statement');\n                if (returnNode.value) {\n                    this.config.services.contextTracker.enterExpression(ExpressionContext.ReturnExpression, returnNode.value.span);\n                    this.resolveExprStmt(returnNode.value);\n                    this.config.services.contextTracker.exitExpression();\n                }\n            }\n\n            private resolveDeferStmt(deferNode: AST.ControlFlowStmtNode): void {\n                this.log('symbols', 'Resolving defer statement');\n                if (deferNode.value) {\n                    this.config.services.contextTracker.enterExpression(ExpressionContext.DeferExpression, deferNode.value.span);\n                    this.resolveExprStmt(deferNode.value);\n                    this.config.services.contextTracker.exitExpression();\n                }\n            }\n\n            private resolveThrowStmt(throwNode: AST.ControlFlowStmtNode): void {\n                this.log('symbols', 'Resolving throw statement');\n                if (throwNode.value) {\n                    this.config.services.contextTracker.enterExpression(ExpressionContext.ThrowExpression, throwNode.value.span);\n                    this.resolveExprStmt(throwNode.value);\n                    this.config.services.contextTracker.exitExpression();\n                }\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌─────────────────────────── [4] EXPR Level ───────────────────────────┐\n\n            private resolveExprStmt(expr: AST.ExprNode, contextSpan?: AST.Span, parameterContext?: FieldContext, symbol?: Symbol): void {\n                if (!expr) return;\n\n                this.log('symbols', `Resolving expression of type ${expr.kind}`);\n                this.config.services.contextTracker.pushContextSpan(expr.span);\n\n                try {\n                    switch (expr.kind) {\n                        case 'Primary':\n                            this.resolvePrimary(expr.getPrimary()!, contextSpan, parameterContext, symbol);\n                            break;\n                        case 'Binary':\n                            this.resolveBinary(expr.getBinary()!, contextSpan, parameterContext);\n                            break;\n                        case 'Prefix':\n                            this.resolvePrefix(expr.getPrefix()!, contextSpan, parameterContext);\n                            break;\n                        case 'Postfix':\n                            this.resolvePostfix(expr.getPostfix()!, contextSpan, parameterContext);\n                            break;\n                        case 'As':\n                            this.resolveAs(expr.getAs()!, contextSpan, parameterContext);\n                            break;\n                        case 'Typeof':\n                            return this.resolveExprStmt(expr.getTypeof()!.expr, contextSpan, parameterContext);\n                        case 'Sizeof':\n                            return this.resolveExprStmt(expr.getSizeof()!.expr, contextSpan, parameterContext);\n                        case 'Orelse':\n                            this.resolveOrelse(expr.getOrelse()!, contextSpan, parameterContext);\n                            break;\n                        case 'Range':\n                            this.resolveRange(expr.getRange()!, contextSpan, parameterContext);\n                            break;\n                        case 'Try':\n                            this.resolveTry(expr.getTry()!, contextSpan, parameterContext);\n                            break;\n                        case 'Catch':\n                            this.resolveCatch(expr.getCatch()!, contextSpan, parameterContext);\n                            break;\n                        case 'If':\n                            this.resolveIf(expr.getIf()!, contextSpan, parameterContext);\n                            break;\n                        case 'Match':\n                            this.resolveSwitch(expr.getMatch()!, contextSpan, parameterContext);\n                            break;\n                        default:\n                            this.log('verbose', `Unhandled expression type: ${expr.kind}`);\n                            break;\n                    }\n                } finally {\n                    this.config.services.contextTracker.popContextSpan();\n                }\n            }\n\n            private resolvePrimary(primary: AST.PrimaryNode, contextSpan?: AST.Span, fieldContext?: FieldContext, symbol?: Symbol): void {\n                switch (primary.kind) {\n                    case 'Ident':\n                        this.resolveIdentifier(primary.getIdent()!, contextSpan, fieldContext);\n                        break;\n                    case 'Paren': {\n                        const paren = primary.getParen()!;\n                        if (paren.source) {\n                            this.resolveExprStmt(paren.source, contextSpan, fieldContext, symbol);\n                        }\n                        break;\n                    }\n                    case 'Literal':\n                        break;\n                    case 'Tuple':\n                        this.resolveTuple(primary.getTuple()!, contextSpan, fieldContext);\n                        break;\n                    case 'Object':\n                        this.resolveObject(primary.getObject()!, contextSpan, fieldContext);\n                        break;\n                    case 'Type': {\n                        const type = primary.getType()!;\n                        const tempSymbol: Symbol = {\n                            id: -1,\n                            name: symbol?.name ?? fieldContext?.parameters[fieldContext?.currentFieldIndex].name ?? type.getIdent()?.name ?? '<type-expr>',\n                            kind: SymbolKind.Variable,\n                            type: null,\n                            scope: this.config.services.scopeManager.getCurrentScope().id,\n                            contextSpan: type.span,\n                            declared: true,\n                            initialized: true,\n                            used: false,\n                            isTypeChecked: false,\n                            visibility: { kind: 'Private' },\n                            mutability: { kind: 'Immutable' },\n                            isExported: false\n                        };\n                        this.resolveType(type, tempSymbol, contextSpan);\n                        break;\n                    }\n                    default:\n                        this.log('verbose', `Unhandled primary type: ${primary.kind}`);\n                        break;\n                }\n            }\n\n            private resolveTuple(tuple: AST.ExprTupleNode, contextSpan?: AST.Span, parameterContext?: FieldContext): void {\n                for (const field of tuple.fields) {\n                    this.resolveExprStmt(field, contextSpan, parameterContext);\n                }\n            }\n\n            private resolveObject(obj: AST.ObjectNode, contextSpan?: AST.Span, parameterContext?: FieldContext): void {\n                if(obj.ident) this.resolveIdentifier(obj.ident, contextSpan, parameterContext);\n\n                for (const prop of obj.props) {\n                    if (prop.val) {\n                        this.resolveExprStmt(prop.val, contextSpan, parameterContext);\n                    }\n                }\n            }\n\n            private resolveBinary(binary: AST.BinaryNode, contextSpan?: AST.Span, parameterContext?: FieldContext): void {\n                if (binary.left) {\n                    this.resolveExprStmt(binary.left, contextSpan, parameterContext);\n                }\n                if (binary.right) {\n                    this.resolveExprStmt(binary.right, contextSpan, parameterContext);\n                }\n            }\n\n            private resolvePrefix(prefix: AST.PrefixNode, contextSpan?: AST.Span, parameterContext?: FieldContext): void {\n                if (prefix.expr) {\n                    this.resolveExprStmt(prefix.expr, contextSpan, parameterContext);\n                }\n            }\n\n            private resolvePostfix(postfix: AST.PostfixNode, contextSpan?: AST.Span, parameterContext?: FieldContext): void {\n                switch (postfix.kind) {\n                    case 'Call':\n                        this.resolvePostfixCall(postfix.getCall()!, contextSpan, parameterContext);\n                        break;\n                    case 'ArrayAccess':\n                        this.resolvePostfixArrayAccess(postfix.getArrayAccess()!, contextSpan, parameterContext);\n                        break;\n                    case 'MemberAccess':\n                        this.resolvePostfixMemberAccess(postfix.getMemberAccess()!, contextSpan, parameterContext);\n                        break;\n                    case 'Increment':\n                    case 'Decrement':\n                    case 'Dereference':\n                        this.resolveExprStmt(postfix.getAsExprNode()!, contextSpan, parameterContext);\n                        break;\n                    default:\n                        this.log('verbose', `Unhandled postfix type: ${postfix.kind}`);\n                        break;\n                }\n            }\n\n            private resolvePostfixCall(call: AST.CallNode, contextSpan?: AST.Span, parameterContext?: FieldContext): void {\n                this.log('symbols', 'Resolving call expression');\n                this.config.services.contextTracker.enterExpression(ExpressionContext.FunctionCall, call.span);\n\n                try {\n                    this.resolveExprStmt(call.base, call.span, parameterContext);\n\n                    const baseSymbol = this.findCallTargetSymbol(call.base);\n                    if (baseSymbol) {\n                        this.validateCallableSymbol(baseSymbol, call.base.span);\n                        baseSymbol.used = true;\n                        this.log('symbols', `Marked function '${baseSymbol.name}' as used`);\n                    }\n\n                    for (let i = 0; i < call.args.length; i++) {\n                        const arg = call.args[i];\n                        this.config.services.contextTracker.enterExpression(ExpressionContext.CallArgument, arg.span);\n                        try {\n                            this.resolveExprStmt(arg, arg.span, parameterContext);\n                        } finally {\n                            this.config.services.contextTracker.exitExpression();\n                        }\n                    }\n                } finally {\n                    this.config.services.contextTracker.exitExpression();\n                }\n            }\n\n            private resolvePostfixArrayAccess(arrayAccess: AST.ArrayAccessNode, contextSpan?: AST.Span, parameterContext?: FieldContext): void {\n                this.log('symbols', 'Resolving array access');\n                this.resolveExprStmt(arrayAccess.base, contextSpan, parameterContext);\n                this.resolveExprStmt(arrayAccess.index, contextSpan, parameterContext);\n            }\n\n            private resolvePostfixMemberAccess(memberAccess: AST.MemberAccessNode, contextSpan?: AST.Span, parameterContext?: FieldContext): void {\n                this.log('symbols', 'Resolving member access');\n\n                // CHECK FOR selferr.Member access\n                if (memberAccess.base.is('Primary')) {\n                    const primary = memberAccess.base.getPrimary();\n                    if (primary?.is('Ident')) {\n                        const ident = primary.getIdent();\n                        if (ident?.name === 'selferr') {\n                            this.resolveSelfErrMemberAccess(memberAccess);\n                            return;\n                        }\n                    }\n                }\n\n                // SPECIAL CASE: 'self.member' in static method\n                if (memberAccess.base.is('Primary')) {\n                    const primary = memberAccess.base.getPrimary();\n                    if (primary?.is('Ident')) {\n                        const ident = primary.getIdent();\n                        if (ident?.name === 'self') {\n                            // In static methods, 'self' refers to the TYPE\n                            // Resolve the target member in the struct scope\n                            // The actual validation (static vs instance) happens in TypeValidator\n                            this.resolveExprStmt(memberAccess.target, contextSpan, parameterContext);\n\n                            // Mark the member as resolved for statistics\n                            this.stats.memberAccessResolved++;\n                            return;\n                        }\n                    }\n                }\n\n                // Resolve base first\n                this.resolveExprStmt(memberAccess.base, contextSpan, parameterContext);\n\n                // Get base symbol\n                const baseSymbol = this.findMemberAccessBaseSymbol(memberAccess.base);\n\n                if (!baseSymbol) {\n                    // Special check: if base is 'self' in static method, allow it\n                    // The error will be reported in TypeValidator with proper context\n                    if (memberAccess.base.is('Primary')) {\n                        const primary = memberAccess.base.getPrimary();\n                        if (primary?.is('Ident')) {\n                            const ident = primary.getIdent();\n                            if (ident?.name === 'self' && this.currentIsStaticMethod) {\n                                // Don't report error here - let TypeValidator handle it\n                                this.stats.memberAccessResolved++;\n                                return;\n                            }\n                        }\n                    }\n\n                    this.reportError(\n                        DiagCode.TYPE_INFERENCE_FAILED,\n                        `Cannot resolve base for member access`,\n                        memberAccess.base.span\n                    );\n                    return;\n                }\n\n                this.stats.memberAccessResolved++;\n            }\n\n            private resolveSelfErrMemberAccess(memberAccess: AST.MemberAccessNode): void {\n                const selfErrSymbol = this.config.services.scopeManager.lookupSymbol('selferr');\n\n                if (!selfErrSymbol || !selfErrSymbol.metadata?.isSelfErr) {\n                    this.reportError(\n                        DiagCode.UNDEFINED_IDENTIFIER,\n                        \"selferr can only be used in functions with self-group error type\",\n                        memberAccess.base.span\n                    );\n                    return;\n                }\n\n                // Extract member name (the error variant)\n                if (!memberAccess.target.is('Primary')) {\n                    this.reportError(\n                        DiagCode.SYMBOL_NOT_FOUND,\n                        'Expected error member name after selferr',\n                        memberAccess.target.span\n                    );\n                    return;\n                }\n\n                const targetPrimary = memberAccess.target.getPrimary();\n                if (!targetPrimary?.is('Ident')) {\n                    this.reportError(\n                        DiagCode.SYMBOL_NOT_FOUND,\n                        'Expected error member name after selferr',\n                        memberAccess.target.span\n                    );\n                    return;\n                }\n\n                const errorMemberName = targetPrimary.getIdent()!.name;\n\n                // Validate the member exists in the error set\n                const errorType = selfErrSymbol.type;\n                if (!errorType || !errorType.isErrset()) {\n                    this.reportError(\n                        DiagCode.INTERNAL_ERROR,\n                        'selferr does not reference a valid error set',\n                        memberAccess.span\n                    );\n                    return;\n                }\n\n                const errset = errorType.getErrset()!;\n                const memberExists = errset.members.some(m => m.name === errorMemberName);\n\n                if (!memberExists) {\n                    this.reportError(\n                        DiagCode.ERROR_MEMBER_NOT_FOUND,\n                        `Error member '${errorMemberName}' not found in function's error set`,\n                        memberAccess.target.span\n                    );\n                    return;\n                }\n\n                // Mark as resolved and used\n                selfErrSymbol.used = true;\n                this.stats.memberAccessResolved++;\n\n                this.log('symbols', `Resolved selferr.${errorMemberName}`);\n            }\n\n            private findMemberAccessBaseSymbol(baseExpr: AST.ExprNode): Symbol | null {\n                // Handle identifier base\n                if (baseExpr.kind === 'Primary') {\n                    const primary = baseExpr.getPrimary();\n                    if (primary && primary.kind === 'Ident') {\n                        const ident = primary.getIdent();\n                        if (ident) {\n                            return this.config.services.scopeManager.lookupSymbol(ident.name);\n                        }\n                    }\n                }\n\n                // Handle postfix expressions (member access, dereference, etc.)\n                if (baseExpr.kind === 'Postfix') {\n                    const postfix = baseExpr.getPostfix();\n                    if (!postfix) return null;\n\n                    // Handle dereference - recurse on the dereferenced expression\n                    if (postfix.kind === 'Dereference') {\n                        const derefExpr = postfix.getAsExprNode();\n                        if (derefExpr) {\n                            return this.findMemberAccessBaseSymbol(derefExpr);\n                        }\n                    }\n\n                    // Handle nested member access\n                    if (postfix.kind === 'MemberAccess') {\n                        const member = postfix.getMemberAccess()!;\n                        return this.findMemberAccessBaseSymbol(member.base);\n                    }\n                }\n\n                return null;\n            }\n\n            private resolveSelfMemberAccess(memberAccess: AST.MemberAccessNode, selfSymbol: Symbol): void {\n                // Get the FUNCTION scope (where self lives)\n                let currentScope = this.config.services.scopeManager.getCurrentScope();\n\n                // Walk up to find the function scope\n                while (currentScope && currentScope.kind !== ScopeKind.Function) {\n                    const parent = this.config.services.scopeManager.getScopeParent(currentScope.id);\n                    if (!parent) break;\n                    currentScope = parent;\n                }\n\n                if (!currentScope || currentScope.kind !== ScopeKind.Function) {\n                    this.reportError(DiagCode.UNDEFINED_IDENTIFIER, \"Cannot use 'self' outside of method context\", memberAccess.span);\n                    return;\n                }\n\n                // Get parent struct scope\n                const parentScope = this.config.services.scopeManager.getScopeParent(currentScope.id);\n                if (!parentScope || parentScope.kind !== ScopeKind.Type) {\n                    this.reportError(DiagCode.UNDEFINED_IDENTIFIER, \"Cannot use 'self' outside of struct method\", memberAccess.span);\n                    return;\n                }\n\n                // Resolve member in struct scope\n                if (memberAccess.target.isIdent()) {\n                    const memberIdent = memberAccess.target.getIdent()!;\n                    const memberSymbol = parentScope.symbols.get(memberIdent.name);\n\n                    if (!memberSymbol) {\n                        this.reportError(\n                            DiagCode.SYMBOL_NOT_FOUND,\n                            `Member '${memberIdent.name}' not found in struct '${parentScope.name}'`,\n                            memberIdent.span\n                        );\n                        return;\n                    }\n\n                    if (memberSymbol.kind !== SymbolKind.StructField) {\n                        this.reportError(\n                            DiagCode.SYMBOL_NOT_FOUND,\n                            `'${memberIdent.name}' is not a field`,\n                            memberIdent.span\n                        );\n                        return;\n                    }\n\n                    memberSymbol.used = true;\n                    this.log('symbols', `Resolved self.${memberIdent.name} in struct method`);\n                }\n            }\n\n            private resolveAs(asNode: AST.AsNode, contextSpan?: AST.Span, parameterContext?: FieldContext): void {\n                this.resolveExprStmt(asNode.base, contextSpan, parameterContext);\n                const tempSymbol: Symbol = {\n                    id: -1,\n                    name: '<as-expr>',\n                    kind: SymbolKind.Variable,\n                    type: null,\n                    scope: this.config.services.scopeManager.getCurrentScope().id,\n                    contextSpan: asNode.span,\n                    declared: true,\n                    initialized: true,\n                    used: false,\n                    isTypeChecked: false,\n                    visibility: { kind: 'Private' },\n                    mutability: { kind: 'Immutable' },\n                    isExported: false\n                };\n                this.resolveType(asNode.type, tempSymbol, contextSpan);\n            }\n\n            private resolveOrelse(orelse: AST.OrelseNode, contextSpan?: AST.Span, parameterContext?: FieldContext): void {\n                this.resolveExprStmt(orelse.left, contextSpan, parameterContext);\n                this.resolveExprStmt(orelse.right, contextSpan, parameterContext);\n            }\n\n            private resolveRange(range: AST.RangeNode, contextSpan?: AST.Span, parameterContext?: FieldContext): void {\n                if (range.leftExpr) this.resolveExprStmt(range.leftExpr, contextSpan, parameterContext);\n                if (range.rightExpr) this.resolveExprStmt(range.rightExpr, contextSpan, parameterContext);\n            }\n\n            private resolveTry(tryNode: AST.TryNode, contextSpan?: AST.Span, parameterContext?: FieldContext): void {\n                this.resolveExprStmt(tryNode.expr, contextSpan, parameterContext);\n            }\n\n            private resolveCatch(catchNode: AST.CatchNode, contextSpan?: AST.Span, parameterContext?: FieldContext): void {\n                this.resolveExprStmt(catchNode.leftExpr, contextSpan, parameterContext);\n\n                const exprScope = this.config.services.scopeManager.findChildScopeByName('expr', ScopeKind.Expression);\n                if (exprScope) {\n                    this.config.services.contextTracker.withSavedState(() => {\n                        this.config.services.contextTracker.setScope(exprScope.id);\n\n                        this.config.services.scopeManager.withScope(exprScope.id, () => {\n                            this.resolveStmt(catchNode.rightStmt, exprScope);\n                        });\n                    });\n                } else {\n                    this.resolveStmt(catchNode.rightStmt, this.config.services.scopeManager.getCurrentScope());\n                }\n            }\n\n            private resolveIf(ifNode: AST.IfNode, contextSpan?: AST.Span, parameterContext?: FieldContext): void {\n                this.config.services.contextTracker.enterExpression(ExpressionContext.ConditionExpression, ifNode.condExpr.span);\n                this.resolveExprStmt(ifNode.condExpr, contextSpan, parameterContext);\n                this.config.services.contextTracker.exitExpression();\n\n                const currentScope = this.config.services.scopeManager.getCurrentScope();\n                this.resolveStmt(ifNode.thenStmt, currentScope);\n                if (ifNode.elseStmt) {\n                    this.resolveStmt(ifNode.elseStmt, currentScope);\n                }\n            }\n\n            private resolveSwitch(MatchNode: AST.MatchNode, contextSpan?: AST.Span, parameterContext?: FieldContext): void {\n                this.config.services.contextTracker.enterExpression(ExpressionContext.ConditionExpression, MatchNode.condExpr.span);\n                this.resolveExprStmt(MatchNode.condExpr, contextSpan, parameterContext);\n                this.config.services.contextTracker.exitExpression();\n\n                const currentScope = this.config.services.scopeManager.getCurrentScope();\n                for (const switchCase of MatchNode.cases) {\n                    if (switchCase.expr) {\n                        this.resolveExprStmt(switchCase.expr, contextSpan, parameterContext);\n                    }\n                    if (switchCase.stmt) {\n                        this.resolveStmt(switchCase.stmt, currentScope);\n                    }\n                }\n\n                if (MatchNode.defCase) {\n                    this.resolveStmt(MatchNode.defCase.stmt, currentScope);\n                }\n            }\n\n            private findCallTargetSymbol(baseExpr: AST.ExprNode): Symbol | null {\n                if (baseExpr.kind === 'Primary') {\n                    const primary = baseExpr.getPrimary();\n                    if (primary && primary.kind === 'Ident') {\n                        const ident = primary.getIdent();\n                        if (ident) {\n                            return this.config.services.scopeManager.lookupSymbol(ident.name);\n                        }\n                    }\n                }\n                return null;\n            }\n\n            private validateCallableSymbol(symbol: Symbol, span?: AST.Span): void {\n                // Quick check: Functions and callable metadata\n                if (symbol.kind === SymbolKind.Function || (symbol.metadata as any)?.callable === true) {\n                    return;\n                }\n\n                // Resolve identifier types (BinaryOp -> fn(...))\n                if (symbol.type) {\n                    const resolvedType = this.resolveIdentifierType(symbol.type);\n                    if (resolvedType.kind === 'function') {\n                        return;\n                    }\n                }\n\n                // Check for imported functions\n                if (symbol.kind === SymbolKind.Use && symbol.importSource) {\n                    const sourceModuleScope = this.config.services.scopeManager.findScopeByName(symbol.importSource, ScopeKind.Module);\n                    if (sourceModuleScope) {\n                        let sourceSymbol = sourceModuleScope.symbols.get(symbol.name);\n\n                        if (!sourceSymbol) {\n                            for (const [_, potentialSource] of sourceModuleScope.symbols) {\n                                if (potentialSource.kind === SymbolKind.Function ||\n                                    (potentialSource.metadata as any)?.callable === true) {\n                                    sourceSymbol = potentialSource;\n                                    break;\n                                }\n                            }\n                        }\n\n                        if (sourceSymbol) {\n                            if (sourceSymbol.kind === SymbolKind.Function ||\n                                (sourceSymbol.metadata as any)?.callable === true ||\n                                sourceSymbol.type?.kind === 'function') {\n                                return;\n                            }\n                        }\n                    }\n                }\n\n                this.reportError(\n                    DiagCode.NOT_A_FUNCTION,\n                    `Cannot call value of non-function type. '${symbol.name}' is a ${symbol.kind.toLowerCase()}`,\n                    span\n                );\n            }\n\n            // Add this helper method if it doesn't exist:\n            private resolveIdentifierType(type: AST.TypeNode): AST.TypeNode {\n                if (!type.isIdent()) return type;\n\n                const ident = type.getIdent()!;\n                if (ident.builtin) return type;\n\n                const symbol = this.config.services.scopeManager.lookupSymbol(ident.name);\n                if (symbol && symbol.type) {\n                    // Recursively resolve\n                    return this.resolveIdentifierType(symbol.type);\n                }\n\n                return type;\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌─────────────────────────── [5] Ident Level ──────────────────────────┐\n\n            private resolveIdentifier(ident: AST.IdentNode, contextSpan?: AST.Span, parameterContext?: FieldContext): void {\n                this.log('symbols', `Resolving identifier '${ident.name}'`);\n                this.config.services.contextTracker.pushContextSpan(ident.span);\n\n                try {\n                    if (parameterContext) {\n                        if (this.checkParameterForwardReference(ident, parameterContext)) {\n                            return;\n                        }\n                    }\n\n                    if (this.checkSelfReference(ident)) {\n                        return;\n                    }\n\n                    if (ident.builtin) {\n                        this.resolveBuiltinFunction(ident);\n                        return;\n                    }\n\n                    // Handle 'self' FIRST\n                    if (ident.name === 'self') {\n                        // ALLOW in static methods (refers to the type)\n                        if (this.currentIsStaticMethod && this.currentStructScope) {\n                            // Don't lookup symbol - it doesn't exist for static methods\n                            // Just mark as resolved, member access validation happens in TypeValidator\n                            this.stats.resolvedSymbols++;\n                            this.config.services.contextTracker.popContextSpan();\n                            return;\n                        }\n\n                        // In instance methods, lookup the injected 'self' parameter\n                        const selfSymbol = this.config.services.scopeManager.lookupSymbol('self');\n                        if (selfSymbol && selfSymbol.metadata?.isSelf) {\n                            selfSymbol.used = true;\n                            this.stats.resolvedSymbols++;\n                            this.config.services.contextTracker.popContextSpan();\n                            return;\n                        }\n\n                        // If neither, it's an error\n                        this.reportError(\n                            DiagCode.UNDEFINED_IDENTIFIER,\n                            \"self can only be used in instance methods\",\n                            ident.span\n                        );\n                        this.config.services.contextTracker.popContextSpan();\n                        return;\n                    }\n\n                    // Check direct field access in static methods (without self)\n                    if (this.currentIsStaticMethod && this.currentStructScope) {\n                        const fieldSymbol = this.currentStructScope.symbols.get(ident.name);\n\n                        if (fieldSymbol && fieldSymbol.kind === SymbolKind.StructField) {\n                            const isStaticField = fieldSymbol.visibility.kind === 'Static';\n\n                            if (!isStaticField) {\n                                this.reportError(\n                                    DiagCode.INVALID_STATIC_ACCESS,\n                                    `Cannot access instance field '${ident.name}' in static method. Static methods can only access static fields.`,\n                                    ident.span\n                                );\n                                return;  // Stop processing and don't mark as used/resolved\n                            }\n                        }\n                    }\n\n                    // Check if we're in a struct method and identifier is a struct field\n                    const currentScope = this.config.services.scopeManager.getCurrentScope();\n                    if (currentScope.kind === ScopeKind.Function) {\n                        const parentScope = this.config.services.scopeManager.getScopeParent(currentScope.id);\n                        if (parentScope && parentScope.kind === ScopeKind.Type) {\n                            const fieldSymbol = parentScope.symbols.get(ident.name);\n                            if (fieldSymbol && fieldSymbol.kind === SymbolKind.StructField) {\n                                fieldSymbol.used = true;\n                                this.stats.resolvedSymbols++;\n                                this.log('symbols', `Resolved struct field '${fieldSymbol.name}' as used`);\n                                this.config.services.contextTracker.popContextSpan();\n                                return;\n                            }\n                        }\n                    }\n\n                    this.resolveStandardIdentifier(ident, contextSpan);\n                } finally {\n                    this.config.services.contextTracker.popContextSpan();\n                }\n            }\n\n            private resolveBuiltinFunction(ident: AST.IdentNode): void {\n                const globalScope = this.config.services.scopeManager.getAllScopes().find(s => s.kind === ScopeKind.Global);\n                if (!globalScope) {\n                    throw new Error('Global scope not found');\n                }\n\n                const builtinName = `@${ident.name}`;\n                const builtinSymbol = globalScope.symbols.get(builtinName);\n\n                if (!builtinSymbol) {\n                    this.reportError(\n                        DiagCode.UNDEFINED_BUILTIN,\n                        `Undefined builtin function '${builtinName}'`,\n                        ident.span\n                    );\n                    return;\n                }\n\n                builtinSymbol.used = true;\n                this.stats.resolvedSymbols++;\n            }\n\n            private resolveStandardIdentifier(ident: AST.IdentNode, contextSpan?: AST.Span): void {\n                this.log('symbols', `Resolving standard identifier '${ident.name}'`);\n                const cacheKey = this.createCacheKey(ident);\n\n                let symbol = this.resolutionCtx.cache.get(cacheKey);\n                if (symbol !== undefined) {\n                    this.stats.cachedResolutions++;\n                    if (symbol) {\n                        symbol.used = true;\n                        this.log('symbols', `Used cached symbol '${symbol.name}'`);\n                    }\n                    return;\n                }\n\n                symbol = this.config.services.scopeManager.lookupSymbol(ident.name);\n                this.resolutionCtx.cache.set(cacheKey, symbol || null);\n\n                if (!symbol) {\n                    this.config.services.contextTracker.recordPendingReference(ident.name, ident.span);\n                    this.reportError(\n                        DiagCode.UNDEFINED_IDENTIFIER,\n                        `Undefined identifier '${ident.name}'`,\n                        ident.span\n                    );\n                    return;\n                }\n\n                this.validateSymbolUsage(symbol, ident, contextSpan);\n                symbol.used = true;\n                this.config.services.contextTracker.resolvePendingReferences(ident.name);\n                this.stats.resolvedSymbols++;\n                this.log('symbols', `Resolved and marked '${symbol.name}' as used`);\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌─────────────────────────── [6] Type Level ───────────────────────────┐\n\n            private resolveType(typeNode: AST.TypeNode, symbol: Symbol, contextSpan?: AST.Span): boolean {\n                this.log('symbols', `Resolving type for symbol '${symbol.name}', typeNode: ${typeNode.toString()}`);\n\n                switch (typeNode.kind) {\n                    case 'ident': {\n                        const identNode = typeNode.getIdent()!;\n\n                        if (!identNode.builtin) {\n                            const typeSymbol = this.config.services.scopeManager.lookupSymbol(identNode.name);\n\n                            if (!typeSymbol) {\n                                this.reportError(\n                                    DiagCode.UNDEFINED_IDENTIFIER,\n                                    `Undefined type '${identNode.name}'`,\n                                    identNode.span\n                                );\n                                return false;\n                            }\n\n                            if (!typeSymbol.declared) {\n                                this.reportError(\n                                    DiagCode.USED_BEFORE_DECLARED,\n                                    `Symbol '${identNode.name}' used before declaration`,\n                                    identNode.span\n                                );\n                                return false;\n                            }\n\n                            typeSymbol.used = true;\n                        }\n\n                        symbol.type = typeNode;\n                        return true;\n                    }\n\n                    case 'optional': {\n                        const optional = typeNode.getOptional()!;\n                        if (!this.resolveType(optional.target, symbol, contextSpan)) return false;\n                        symbol.type = typeNode;\n                        return true;\n                    }\n\n                    case 'pointer': {\n                        const pointer = typeNode.getPointer()!;\n\n                        // Normalize the target to remove parens before validation\n                        let targetType = pointer.target;\n                        while (targetType.isParen()) {\n                            targetType = targetType.getParen()!.type;\n                        }\n\n                        // Validate pointer target is a type identifier, not a variable\n                        if (targetType.isIdent()) {\n                            const targetIdent = targetType.getIdent()!;\n\n                            if (!targetIdent.builtin) {\n                                const targetSymbol = this.config.services.scopeManager.lookupSymbol(targetIdent.name);\n\n                                if (targetSymbol &&\n                                    (targetSymbol.kind === SymbolKind.Variable ||\n                                    targetSymbol.kind === SymbolKind.Parameter)) {\n                                    this.reportError(\n                                        DiagCode.TYPE_MISMATCH,\n                                        `Cannot use pointer syntax with variable '${targetIdent.name}'. Did you mean to dereference using '.*' postfix operator?`,\n                                        typeNode.span\n                                    );\n                                    return false;\n                                }\n                            }\n                        }\n\n                        if (!this.resolveType(pointer.target, symbol, contextSpan)) return false;\n                        symbol.type = typeNode;\n                        return true;\n                    }\n\n                    case 'array': {\n                        const array = typeNode.getArray()!;\n                        if (!this.resolveType(array.target, symbol, contextSpan)) return false;\n                        if (array.size) this.resolveExprStmt(array.size, contextSpan, undefined, symbol);\n                        symbol.type = typeNode;\n                        return true;\n                    }\n\n                    case 'tuple': {\n                        const tuple = typeNode.getTuple()!;\n                        for (const field of tuple.fields) {\n                            if (!this.resolveType(field, symbol, contextSpan)) return false;\n                        }\n                        symbol.type = typeNode;\n                        return true;\n                    }\n\n                    case 'struct': {\n                        const struct = typeNode.getStruct()!;\n\n                        let typeScope: Scope | null = null;\n\n                        if (struct.metadata?.scopeId !== undefined) {\n                            try {\n                                typeScope = this.config.services.scopeManager.getScope(struct.metadata.scopeId as number);\n                            } catch {\n                                typeScope = null;\n                            }\n                        }\n\n                        if (!typeScope && struct.name && struct.name !== 'Anonymous') {\n                            typeScope = this.config.services.scopeManager.findChildScopeByName(struct.name, ScopeKind.Type);\n                        }\n\n                        if (!typeScope) {\n                            typeScope = this.config.services.scopeManager.findChildScopeByNameFromId(\n                                symbol.name,\n                                symbol.scope,\n                                ScopeKind.Type\n                            );\n                        }\n\n                        if (!typeScope) {\n                            const parentScope = this.config.services.scopeManager.getScope(symbol.scope);\n                            for (const childId of parentScope.children) {\n                                const child = this.config.services.scopeManager.getScope(childId);\n                                if (child.kind === ScopeKind.Type) {\n                                    if (this.scopeMatchesStruct(child, struct)) {\n                                        typeScope = child;\n                                        break;\n                                    }\n                                }\n                            }\n                        }\n\n                        if (typeScope) {\n                            this.config.services.contextTracker.withSavedState(() => {\n                                this.config.services.contextTracker.setScope(typeScope!.id);\n\n                                this.config.services.scopeManager.withScope(typeScope!.id, () => {\n                                    const fields: AST.FieldNode[] = [];\n                                    const methods: AST.FuncStmtNode[] = [];\n\n                                    for (const member of struct.members) {\n                                        if (member.isField()) {\n                                            fields.push(member.getField()!);\n                                        } else if (member.isMethod()) {\n                                            methods.push(member.getMethod()!);\n                                        }\n                                    }\n\n                                    this.resolveFields(fields);\n\n                                    for (const m of methods) {\n                                        this.resolveFuncStmt(m);\n                                    }\n                                });\n                            });\n                        } else {\n                            this.reportError(\n                                DiagCode.INTERNAL_ERROR,\n                                `Cannot find type scope for struct '${struct.name || '<anonymous>'}'`,\n                                typeNode.span\n                            );\n                            return false;\n                        }\n\n                        symbol.type = typeNode;\n                        return true;\n                    }\n\n                    case 'enum': {\n                        const enumType = typeNode.getEnum()!;\n\n                        let typeScope: Scope | null = null;\n\n                        if (enumType.metadata?.scopeId !== undefined) {\n                            try {\n                                typeScope = this.config.services.scopeManager.getScope(enumType.metadata.scopeId as number);\n                            } catch {\n                                typeScope = null;\n                            }\n                        }\n\n                        if (!typeScope && symbol.name) {\n                            typeScope = this.config.services.scopeManager.findChildScopeByName(symbol.name, ScopeKind.Type);\n                        }\n\n                        if (typeScope) {\n                            enumType.metadata = { ...enumType.metadata, scopeId: typeScope.id };\n\n                            this.config.services.contextTracker.withSavedState(() => {\n                                this.config.services.contextTracker.setScope(typeScope!.id);\n                                this.config.services.scopeManager.withScope(typeScope!.id, () => {\n                                    for (const variant of enumType.variants) {\n                                        // Mark variant as resolved\n                                        const variantSymbol = typeScope!.symbols.get(variant.ident.name);\n                                        if (variantSymbol) {\n                                            variantSymbol.declared = true;\n                                            variantSymbol.used = true;\n                                            this.stats.enumVariantsResolved++;\n                                        }\n\n                                        if (variant.type) {\n                                            if (variant.type.isStruct()) {\n                                                const structType = variant.type.getStruct()!;\n\n                                                let variantScope: Scope | null = null;\n\n                                                if (structType.metadata?.scopeId !== undefined) {\n                                                    try {\n                                                        variantScope = this.config.services.scopeManager.getScope(structType.metadata.scopeId as number);\n                                                    } catch {\n                                                        variantScope = null;\n                                                    }\n                                                }\n\n                                                if (!variantScope) {\n                                                    variantScope = this.config.services.scopeManager.findChildScopeByNameFromId(\n                                                        variant.ident.name,\n                                                        typeScope!.id,\n                                                        ScopeKind.Type\n                                                    );\n                                                }\n\n                                                if (variantScope) {\n                                                    this.config.services.contextTracker.withSavedState(() => {\n                                                        this.config.services.scopeManager.withScope(variantScope!.id, () => {\n                                                            const tempSymbol: Symbol = {\n                                                                id: -1,\n                                                                name: variant.ident.name,\n                                                                kind: SymbolKind.EnumVariant,\n                                                                type: variant.type!,\n                                                                scope: variantScope!.id,\n                                                                contextSpan: variant.type!.span,\n                                                                declared: true,\n                                                                initialized: true,\n                                                                used: false,\n                                                                isTypeChecked: false,\n                                                                visibility: { kind: 'Public'},\n                                                                mutability: { kind: 'Immutable' },\n                                                                isExported: false\n                                                            };\n\n                                                            this.resolveType(variant.type!, tempSymbol, contextSpan);\n                                                        });\n                                                    });\n                                                }\n                                            } else {\n                                                this.resolveType(variant.type, symbol, contextSpan);\n                                            }\n                                        }\n                                    }\n                                });\n                            });\n                        }\n\n                        symbol.type = typeNode;\n                        return true;\n                    }\n\n                    case 'errset':\n                        // Resolve error members\n                        const errorType = typeNode.getErrset()!;\n                        for (const errorMember of errorType.members) {\n                            // Error members are just identifiers - mark them as resolved\n                            const errorSymbol = this.config.services.scopeManager.lookupSymbol(errorMember.name);\n                            if (errorSymbol) {\n                                errorSymbol.used = true;\n                                errorSymbol.declared = true;\n                            }\n                            this.log('symbols', `Resolved error member '${errorMember.name}'`);\n                        }\n                        symbol.type = typeNode;\n                        return true;\n\n                    case 'function': {\n                        const func = typeNode.getFunction()!;\n\n                        // Resolve parameters\n                        for (const param of func.params) {\n                            const tempParamSymbol: Symbol = {\n                                id: -1,\n                                name: '<func-param-type>',\n                                kind: SymbolKind.Variable,\n                                type: null,\n                                scope: this.config.services.scopeManager.getCurrentScope().id,\n                                contextSpan: param.span,\n                                declared: true,\n                                initialized: true,\n                                used: false,\n                                isTypeChecked: false,\n                                visibility: { kind: 'Private' },\n                                mutability: { kind: 'Immutable' },\n                                isExported: false\n                            };\n                            if (!this.resolveType(param, tempParamSymbol, contextSpan)) return false;\n                        }\n\n                        // Resolve return type\n                        if (func.returnType) {\n                            const tempReturnSymbol: Symbol = {\n                                id: -1,\n                                name: '<func-return-type>',\n                                kind: SymbolKind.Variable,\n                                type: null,\n                                scope: this.config.services.scopeManager.getCurrentScope().id,\n                                contextSpan: func.returnType.span,\n                                declared: true,\n                                initialized: true,\n                                used: false,\n                                isTypeChecked: false,\n                                visibility: { kind: 'Private' },\n                                mutability: { kind: 'Immutable' },\n                                isExported: false\n                            };\n                            if (!this.resolveType(func.returnType, tempReturnSymbol, contextSpan)) return false;\n                        }\n\n                        // Resolve and validate error type\n                        if (func.errorType) {\n                            // First, recursively resolve the error type structure\n                            const tempErrorSymbol: Symbol = {\n                                id: -1,\n                                name: '<func-error-type>',\n                                kind: SymbolKind.Variable,\n                                type: null,\n                                scope: this.config.services.scopeManager.getCurrentScope().id,\n                                contextSpan: func.errorType.span,\n                                declared: true,\n                                initialized: true,\n                                used: false,\n                                isTypeChecked: false,\n                                visibility: { kind: 'Private' },\n                                mutability: { kind: 'Immutable' },\n                                isExported: false\n                            };\n                            if (!this.resolveType(func.errorType, tempErrorSymbol, contextSpan)) return false;\n\n                            // Then validate the error type identifier exists and is an error type\n                            if (func.errorType.isIdent()) {\n                                const errorIdent = func.errorType.getIdent()!;\n\n                                if (!errorIdent.builtin) {\n                                    const errorSymbol = this.config.services.scopeManager.lookupSymbol(errorIdent.name);\n\n                                    if (!errorSymbol) {\n                                        this.reportError(\n                                            DiagCode.UNDEFINED_IDENTIFIER,\n                                            `Error type '${errorIdent.name}' is not defined`,\n                                            func.errorType.span\n                                        );\n                                        return false;\n                                    }\n\n                                    // Validate it's actually an error type\n                                    if (errorSymbol.type && !errorSymbol.type.isErrset() && !errorSymbol.type.isErr()) {\n                                        this.reportError(\n                                            DiagCode.TYPE_MISMATCH,\n                                            `'${errorIdent.name}' is not an error type`,\n                                            func.errorType.span\n                                        );\n                                        return false;\n                                    }\n                                }\n                            }\n                        }\n\n                        symbol.type = typeNode;\n                        return true;\n                    }\n\n                    case 'union': {\n                        const union = typeNode.getUnion()!;\n\n                        for (const variantType of union.types) {\n                            const tempVariantSymbol: Symbol = {\n                                id: -1,\n                                name: '<union-variant>',\n                                kind: SymbolKind.Variable,\n                                type: null,\n                                scope: this.config.services.scopeManager.getCurrentScope().id,\n                                contextSpan: variantType.span,\n                                declared: true,\n                                initialized: true,\n                                used: false,\n                                isTypeChecked: false,\n                                visibility: { kind: 'Private' },\n                                mutability: { kind: 'Immutable' },\n                                isExported: false\n                            };\n                            if (!this.resolveType(variantType, tempVariantSymbol, contextSpan)) return false;\n                        }\n\n                        symbol.type = typeNode;\n                        return true;\n                    }\n\n                    case 'paren': {\n                        return this.resolveType(typeNode.getParen()!.type, symbol, contextSpan);\n                    }\n\n                    case 'primitive':\n                        symbol.type = typeNode;\n                        return true;\n\n                    default:\n                        this.config.services.diagnosticManager.reportError(DiagCode.UNSUPPORTED_TYPE, `Unsupported type kind: ${typeNode.kind}`, typeNode.span);\n                        return false;\n                }\n            }\n\n            private scopeMatchesStruct(scope: Scope, struct: AST.StructTypeNode): boolean {\n                const structFields = struct.members.filter((m: AST.StructMemberNode) => m.isField());\n                const scopeFields = Array.from(scope.symbols.values())\n                    .filter(s => s.kind === SymbolKind.StructField);\n\n                if (scopeFields.length !== structFields.length) {\n                    return false;\n                }\n\n                for (const member of structFields) {\n                    const field = member.source as AST.FieldNode;\n                    const fieldName = field.ident.name;\n\n                    if (!scope.symbols.has(fieldName)) {\n                        return false;\n                    }\n\n                    const scopeSymbol = scope.symbols.get(fieldName)!;\n                    if (scopeSymbol.kind !== SymbolKind.StructField) {\n                        return false;\n                    }\n                }\n\n                return true;\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌─────────────────────────── [x] VALIDATION ───────────────────────────┐\n\n            private checkParameterForwardReference(ident: AST.IdentNode, parameterContext: FieldContext): boolean {\n                const forwardRefResult = this.config.services.contextTracker.checkParameterForwardReference(\n                    ident.name,\n                    parameterContext.currentFieldIndex,\n                    parameterContext.parameters\n                );\n\n                if (forwardRefResult.isForwardReference) {\n                    this.reportError(\n                        DiagCode.PARAMETER_FORWARD_REFERENCE,\n                        `Parameter '${parameterContext.parameters[parameterContext.currentFieldIndex].name}' default value refers to parameter '${ident.name}' which is not yet declared`,\n                        ident.span\n                    );\n                    this.stats.forwardReferences++;\n                    return true;\n                }\n                return false;\n            }\n\n            private checkSelfReference(ident: AST.IdentNode): boolean {\n                const selfRefResult = this.config.services.contextTracker.checkSelfReference(ident.name, ident.span);\n\n                if (selfRefResult.isSelfReference) {\n                    const errorCode = selfRefResult.errorType === 'VARIABLE_SELF_INIT' ?\n                        DiagCode.VARIABLE_SELF_INIT : DiagCode.PARAMETER_SELF_INIT;\n\n                    const symbolType = selfRefResult.declarationContext?.symbolKind;\n                    this.reportError(\n                        errorCode,\n                        `${symbolType} '${ident.name}' cannot be initialized using itself`,\n                        ident.span\n                    );\n                    this.stats.selfReferences++;\n                    return true;\n                }\n                return false;\n            }\n\n            private validateSymbolUsage(symbol: Symbol, ident: AST.IdentNode, contextSpan?: AST.Span): void {\n                this.log('symbols', `Validating usage of symbol '${symbol.name}'`);\n\n                if (contextSpan) {\n                    this.config.services.contextTracker.pushContextSpan(contextSpan);\n                }\n\n                if (!symbol.declared) {\n                    this.reportError(\n                        DiagCode.USED_BEFORE_DECLARED,\n                        `Symbol '${ident.name}' used before declaration`,\n                        ident.span\n                    );\n                }\n\n                if (symbol.kind === SymbolKind.Variable && !symbol.initialized) {\n                    this.reportError(\n                        DiagCode.USED_BEFORE_INITIALIZED,\n                        `Variable '${ident.name}' used before initialization`,\n                        ident.span\n                    );\n                }\n\n                if (contextSpan) {\n                    this.config.services.contextTracker.popContextSpan();\n                }\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── ---- ────────────────────────────────┐\n\n            private init(): boolean {\n                this.config.services.contextTracker.reset();\n                this.config.services.contextTracker.setPhase(AnalysisPhase.Resolution);\n                this.stats.totalSymbols = Array.from(this.config.services.scopeManager.getAllSymbols()).length;\n\n                const globalScope = this.config.services.scopeManager.getGlobalScope();\n                this.config.services.scopeManager.setCurrentScope(globalScope.id);\n                this.config.services.contextTracker.setScope(globalScope.id);\n\n                this.log('verbose', `Resolution initialized: ${this.stats.totalSymbols} symbols to resolve`);\n                return true;\n            }\n\n            private initStats(): ResolutionStats {\n                return {\n                    totalSymbols            : 0,\n                    resolvedSymbols         : 0,\n                    cachedResolutions       : 0,\n                    forwardReferences       : 0,\n                    selfReferences          : 0,\n                    importResolutions       : 0,\n                    structMethodsResolved   : 0,\n                    enumVariantsResolved    : 0,\n                    memberAccessResolved    : 0,\n                    anonymousTypesResolved  : 0,\n                    visibilityChecks        : 0,\n                    errors                  : 0,\n                    modulesProcessed        : 0,\n                    startTime               : Date.now()\n                };\n            }\n\n            private initResolutionContext(): ResolutionContext {\n                return {\n                    currentModule: '',\n                    moduleStack: [],\n                    cache: new Map(),\n                };\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── ---- ────────────────────────────────┐\n\n            private createCacheKey(ident: AST.IdentNode): string {\n                    const scope = this.config.services.scopeManager.getCurrentScope();\n                    const moduleName = this.resolutionCtx.currentModule;\n                    return `${moduleName}:${ident.name}:${ident.span.start}:${ident.span.end}`;\n                }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── ---- ────────────────────────────────┐\n\n            logStatistics(): void {\n                const duration = Date.now() - this.stats.startTime;\n                this.log('verbose',\n                    `Resolution Statistics      :\\n` +\n                    `  Duration                 : ${duration}ms\\n` +\n                    `  Total symbols            : ${this.stats.totalSymbols}\\n` +\n                    `  Resolved symbols         : ${this.stats.resolvedSymbols}\\n` +\n                    `  Cached resolutions       : ${this.stats.cachedResolutions}\\n` +\n                    `  Forward references       : ${this.stats.forwardReferences}\\n` +\n                    `  Self references          : ${this.stats.selfReferences}\\n` +\n                    `  Import resolutions       : ${this.stats.importResolutions}\\n` +\n                    `  Struct methods resolved  : ${this.stats.structMethodsResolved}\\n` +\n                    `  Enum variants resolved   : ${this.stats.enumVariantsResolved}\\n` +\n                    `  Member access resolved   : ${this.stats.memberAccessResolved}\\n` +\n                    `  Anonymous types resolved : ${this.stats.anonymousTypesResolved}\\n` +\n                    `  Visibility checks        : ${this.stats.visibilityChecks}\\n` +\n                    `  Errors                   : ${this.stats.errors}`\n                );\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// TypeValidator.ts — Type validation Phase.\r\n//\r\n// Developed with ❤️ by Maysara.\r\n\r\n\r\n\r\n// ╔═══════════════════════════════════════ PACK ════════════════════════════════════════╗\r\n\r\n    import * as AST                     from '@je-es/ast';\r\n    import { AnalysisPhase }            from '../components/ContextTracker';\r\n    import { DiagCode }                 from '../components/DiagnosticManager';\r\n    import { PhaseBase }                from '../interfaces/PhaseBase';\r\n    import { AnalysisConfig }           from '../ast-analyzer';\r\n    import { Scope, Symbol, SymbolKind, ScopeKind }\r\n                                        from '../components/ScopeManager';\r\n    import { ExpressionEvaluator }      from '../components/ExpressionEvaluator';\r\n\r\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\r\n\r\n\r\n\r\n// ╔═══════════════════════════════════════ TYPES ═══════════════════════════════════════╗\r\n\r\n    interface TypeValidatorContext {\r\n        currentModule               : string;\r\n        moduleStack                 : string[];\r\n        typeCache                   : Map<string, AST.TypeNode | null>;\r\n    }\r\n\r\n    interface TypeValidationStats {\r\n        modulesProcessed            : number;\r\n        typesInferred               : number;\r\n        typesCached                 : number;\r\n        compatibilityChecks         : number;\r\n        callsValidated              : number;\r\n        memberAccessValidated       : number;\r\n        assignmentsValidated        : number;\r\n        returnsValidated            : number;\r\n        errors                      : number;\r\n        startTime                   : number;\r\n    }\r\n\r\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\r\n\r\n\r\n\r\n// ╔═══════════════════════════════════════ CORE ════════════════════════════════════════╗\r\n\r\n    export class TypeValidator extends PhaseBase {\r\n\r\n        // ┌──────────────────────────────── INIT ─────────────────────────────────┐\r\n\r\n            private stats                       : TypeValidationStats   = this.initStats();\r\n\r\n            private typeCtx                     : TypeValidatorContext  = this.initTypeValidatorContext();\r\n            private ExpressionEvaluator         : ExpressionEvaluator;\r\n\r\n            private inferenceStack              : Set<string>           = new Set();\r\n            private circularTypeDetectionStack  : Set<string>           = new Set();\r\n\r\n            private currentFunctionReturnType   : AST.TypeNode | null   = null;\r\n            private hasReturnStatement          : boolean               = false;\r\n\r\n            private currentFunctionErrorType    : AST.TypeNode | null   = null;\r\n            private hasThrowStatement           : boolean               = false;\r\n            private currentIsStaticMethod       : boolean               = false;\r\n            private currentStructScope          : Scope | null          = null;\r\n\r\n\r\n            private readonly CACHE_MAX_SIZE     = 10000;\r\n\r\n            constructor( config : AnalysisConfig ) {\r\n                super(AnalysisPhase.TypeValidation, config);\r\n\r\n                this.ExpressionEvaluator = new ExpressionEvaluator(this.config);\r\n            }\r\n\r\n        // └──────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌──────────────────────────────── MAIN ─────────────────────────────────┐\r\n\r\n            handle(): boolean {\r\n                try {\r\n                    this.log('verbose', 'Starting symbol validation phase...');\r\n                    this.stats.startTime = Date.now();\r\n\r\n                    if (!this.init()) return false;\r\n                    if (!this.validateAllModules()) return false;\r\n\r\n                    this.logStatistics();\r\n                    return !this.config.services.diagnosticManager.hasErrors();\r\n\r\n                } catch (error) {\r\n                    this.log('errors', `Fatal error during type validation: ${error}`);\r\n                    this.reportError(DiagCode.INTERNAL_ERROR, `Fatal error during type validation: ${error}`);\r\n                    return false;\r\n                }\r\n            }\r\n\r\n            reset(): void {\r\n                this.inferenceStack.clear();\r\n                this.circularTypeDetectionStack.clear();\r\n                this.stats          = this.initStats();\r\n                this.typeCtx        = this.initTypeValidatorContext();\r\n            }\r\n\r\n        // └──────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌────────────────────────── [1] Program Level ─────────────────────────┐\r\n\r\n            private validateAllModules(): boolean {\r\n                this.log('verbose', 'Validating types from all modules...');\r\n                const globalScope = this.config.services.scopeManager.getCurrentScope();\r\n\r\n                for (const [moduleName, module] of this.config.program!.modules) {\r\n                    this.config.services.contextTracker.pushContextSpan({ start: 0, end: 0 });\r\n                    try {\r\n                        if (!this.validateModule(moduleName, module, globalScope)) {\r\n                            this.log('errors', `Failed to validate module ${moduleName}, continuing...`);\r\n                        }\r\n                        this.stats.modulesProcessed++;\r\n                    } finally {\r\n                        this.config.services.contextTracker.popContextSpan();\r\n                    }\r\n                }\r\n\r\n                return true;\r\n            }\r\n\r\n        // └──────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌────────────────────────── [2] Module Level ──────────────────────────┐\r\n\r\n            private validateModule(moduleName: string, module: AST.Module, parentScope: Scope): boolean {\r\n                this.log('symbols', `Validating module '${moduleName}'`);\r\n\r\n                try {\r\n                    this.config.services.contextTracker.setModuleName(moduleName);\r\n\r\n                    if (typeof module.metadata?.path === 'string') {\r\n                        this.config.services.contextTracker.setModulePath(module.metadata.path);\r\n                    }\r\n\r\n                    this.enterModuleContext(moduleName, module);\r\n\r\n                    const moduleScope = this.findModuleScope(moduleName);\r\n                    if (!moduleScope) {\r\n                        this.reportError(DiagCode.MODULE_SCOPE_NOT_FOUND, `Module scope for '${moduleName}' not found`);\r\n                        return false;\r\n                    }\r\n\r\n                    this.config.services.scopeManager.setCurrentScope(moduleScope.id);\r\n                    this.config.services.contextTracker.setScope(moduleScope.id);\r\n\r\n                    for (const statement of module.statements) {\r\n                        this.validateStmt(statement, moduleScope, moduleName);\r\n                    }\r\n\r\n                    this.exitModuleContext();\r\n                    return true;\r\n                } catch (error) {\r\n                    this.reportError(DiagCode.INTERNAL_ERROR, `Failed to validate module '${moduleName}': ${error}`);\r\n                    return false;\r\n                }\r\n            }\r\n\r\n             private enterModuleContext(moduleName: string, module: AST.Module): void {\r\n                this.typeCtx.moduleStack.push(this.typeCtx.currentModule);\r\n                this.typeCtx.currentModule = moduleName;\r\n                this.config.services.contextTracker.setModuleName(moduleName);\r\n                if (typeof module.metadata?.path === 'string') {\r\n                    this.config.services.contextTracker.setModulePath(module.metadata.path);\r\n                }\r\n            }\r\n\r\n            private exitModuleContext(): void {\r\n                const previousModule = this.typeCtx.moduleStack.pop();\r\n                this.typeCtx.currentModule = previousModule || '';\r\n            }\r\n\r\n        // └──────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌─────────────────────────── [3] Stmt Level ───────────────────────────┐\r\n\r\n            private validateStmt(stmt: AST.StmtNode, currentScope?: Scope, moduleName?: string): void {\r\n                if(!currentScope) { currentScope = this.config.services.scopeManager.getCurrentScope(); }\r\n                if (!stmt) {\r\n                    this.reportError(DiagCode.ANALYSIS_ERROR, 'Found null statement during validation');\r\n                    return;\r\n                }\r\n\r\n                this.log('verbose', `Validating ${stmt.kind} statement`);\r\n                this.config.services.contextTracker.pushContextSpan(stmt.span);\r\n\r\n                try {\r\n                    this.config.services.scopeManager.withScope(currentScope.id, () => {\r\n                        this.config.services.contextTracker.withSavedState(() => {\r\n                            this.config.services.contextTracker.setScope(currentScope.id);\r\n                            this.processStmtByKind(stmt, {\r\n                                'Block'     : (blockNode) => this.handleBlockStmt(blockNode, currentScope, moduleName),\r\n                                'Test'      : (testNode)  => this.handleTestStmt(testNode, currentScope, moduleName),\r\n                                // 'Use'       : (useNode)   => this.handleUseStmt(useNode, currentScope, moduleName),\r\n                                'Def'       : (defNode)   => this.handleDefStmt(defNode, currentScope, moduleName),\r\n                                'Let'       : (letNode)   => this.handleLetStmt(letNode, currentScope, moduleName),\r\n                                'Func'      : (funcNode)  => this.handleFuncStmt(funcNode, currentScope, moduleName),\r\n                                'Expression': (exprNode)  => {\r\n                                    const expr = stmt.getExpr()!;\r\n                                    if (expr.kind === 'Binary') {\r\n                                        const binary = expr.getBinary();\r\n\r\n                                        if (binary && binary.kind === 'Assignment') {\r\n                                            this.validateAssignment(binary);\r\n                                        }\r\n                                    }\r\n\r\n                                    this.inferExpressionType(expr);\r\n                                },\r\n\r\n                                // special cases\r\n                                'While'     : () => this.handleLoopStmt(stmt, currentScope, moduleName),\r\n                                'Do'        : () => this.handleLoopStmt(stmt, currentScope, moduleName),\r\n                                'For'       : () => this.handleLoopStmt(stmt, currentScope, moduleName),\r\n\r\n                                'Return'    : () => this.handleControlflowStmt(stmt, currentScope, moduleName),\r\n                                'Defer'     : () => this.handleControlflowStmt(stmt, currentScope, moduleName),\r\n                                'Throw'     : () => this.handleControlflowStmt(stmt, currentScope, moduleName),\r\n                            });\r\n                        });\r\n                    });\r\n                } catch (error) {\r\n                    this.reportError(\r\n                        DiagCode.ANALYSIS_ERROR,\r\n                        `Failed to validate ${stmt.kind} statement: ${error}`,\r\n                        stmt.span\r\n                    );\r\n                } finally {\r\n                    this.config.services.contextTracker.popContextSpan();\r\n                }\r\n            }\r\n\r\n        // └──────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌──────────────────────────── [3.1] BLOCK ─────────────────────────────┐\r\n\r\n            private handleBlockStmt(blockNode: AST.BlockStmtNode, scope?: Scope, moduleName?: string): void {\r\n                this.validateBlockStmt(blockNode);\r\n            }\r\n\r\n            private validateBlockStmt(block: AST.BlockStmtNode, scope?: Scope, moduleName?: string): void {\r\n                this.log('symbols', 'Validating block');\r\n\r\n                const blockScope = this.config.services.scopeManager.findChildScopeByName('block', ScopeKind.Block);\r\n                if (blockScope) {\r\n                    this.config.services.contextTracker.withSavedState(() => {\r\n                        this.config.services.contextTracker.setScope(blockScope.id);\r\n\r\n                        this.config.services.scopeManager.withScope(blockScope.id, () => {\r\n                            for (const stmt of block.stmts) {\r\n                                this.validateStmt(stmt, blockScope);\r\n                            }\r\n                        });\r\n                    });\r\n                }\r\n            }\r\n\r\n            private handleTestStmt(testNode: AST.TestStmtNode, scope: Scope, moduleName?: string): void {\r\n                this.validateBlockStmt(testNode.block, scope, moduleName);\r\n            }\r\n\r\n        // └──────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌───────────────────────────── [3.2] USE ──────────────────────────────┐\r\n\r\n            // Skipped for now.\r\n\r\n        // └──────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌───────────────────────────── [3.3] DEF ──────────────────────────────┐\r\n\r\n            private handleDefStmt(defNode: AST.DefStmtNode, scope?: Scope, moduleName?: string): void {\r\n                this.validateDefStmt(defNode);\r\n            }\r\n\r\n            private validateDefStmt(defNode: AST.DefStmtNode): void {\r\n                this.log('symbols', `Type checking definition '${defNode.ident.name}'`);\r\n\r\n                const symbol = this.config.services.scopeManager.getSymbolInCurrentScope(defNode.ident.name);\r\n                if (!symbol) return;\r\n\r\n                if (defNode.type) {\r\n                    if (!this.checkCircularTypeDependency(defNode.type, defNode.ident.name, true)) {\r\n                        this.resolveTypeNode(defNode.type);\r\n                    }\r\n                }\r\n\r\n                symbol.isTypeChecked = true;\r\n                symbol.type = defNode.type;\r\n            }\r\n\r\n        // └──────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌───────────────────────────── [3.4] LET ──────────────────────────────┐\r\n\r\n            private handleLetStmt(letNode: AST.LetStmtNode, scope?: Scope, moduleName?: string): void {\r\n                this.validateLetStmt(letNode);\r\n            }\r\n\r\n            private validateArrayLiteralWithTargetType(\r\n                initExpr: AST.ExprNode,\r\n                targetType: AST.TypeNode,\r\n                contextName: string\r\n            ): boolean {\r\n                // Only handle array literals\r\n                if (!initExpr.is('Primary')) return true;\r\n                const primary = initExpr.getPrimary();\r\n                if (!primary?.is('Literal')) return true;\r\n                const literal = primary.getLiteral();\r\n                if (literal?.kind !== 'Array') return true;\r\n\r\n                const elements = literal.value as AST.ExprNode[];\r\n\r\n                // Extract target array info\r\n                if (!targetType.isArray()) return true;\r\n                const targetArray = targetType.getArray()!;\r\n                const targetElementType = targetArray.target;\r\n\r\n                // CHECK ARRAY SIZE MISMATCH\r\n                if (targetArray.size) {\r\n                    const targetSize = this.ExpressionEvaluator.extractIntegerValue(targetArray.size);\r\n                    const sourceSize = elements.length;\r\n\r\n                    if (targetSize !== undefined && targetSize !== sourceSize) {\r\n                        const msg = sourceSize > targetSize\r\n                            ? `Array literal has more elements than the fixed array type`\r\n                            : `Array literal has fewer elements than the fixed array type`;\r\n\r\n                        this.reportError(\r\n                            DiagCode.ARRAY_SIZE_MISMATCH,\r\n                            msg,\r\n                            initExpr.span\r\n                        );\r\n                        return false; // Size mismatch - stop validation\r\n                    }\r\n                }\r\n\r\n                // Empty array is valid\r\n                if (elements.length === 0) return true;\r\n\r\n                // Validate ALL elements against target element type\r\n                for (let i = 0; i < elements.length; i++) {\r\n                    // Unified validation for each element\r\n                    if (!this.validateTypeAssignment(\r\n                        elements[i],\r\n                        targetElementType,\r\n                        `Array element ${i} in '${contextName}'`\r\n                    )) {\r\n                        // Error already reported, continue checking other elements\r\n                        continue;\r\n                    }\r\n\r\n                    const elemType = this.inferExpressionType(elements[i]);\r\n                    if (!elemType || !this.isTypeCompatible(targetElementType, elemType)) {\r\n                        this.reportError(\r\n                            DiagCode.TYPE_MISMATCH,\r\n                            `Array element ${i} has type '${elemType ? this.getTypeDisplayName(elemType!) : 'unknown'}' which is not compatible with target element type '${ this.getTypeDisplayName(targetElementType) }'`,\r\n                            elements[i].span\r\n                        );\r\n                    }\r\n                }\r\n\r\n                return true;\r\n            }\r\n\r\n            private validateLetStmt(letNode: AST.LetStmtNode): void {\r\n                this.log('symbols', `Type checking variable '${letNode.field.ident.name}'`);\r\n\r\n                const symbol = this.config.services.scopeManager.getSymbolInCurrentScope(letNode.field.ident.name);\r\n                if (!symbol) return;\r\n\r\n                const currentScope = this.config.services.scopeManager.getCurrentScope();\r\n                // Static variables only allowed in struct/enum types\r\n                if (letNode.field.visibility.kind === 'Static') {\r\n                    const currentScope = this.config.services.scopeManager.getCurrentScope();\r\n\r\n                    // Static is only valid inside struct/enum type definitions\r\n                    if (currentScope.kind !== ScopeKind.Type) {\r\n                        this.reportError(\r\n                            DiagCode.INVALID_VISIBILITY,\r\n                            `Variable '${letNode.field.ident.name}' cannot be 'static' outside of struct/enum`,\r\n                            letNode.field.ident.span\r\n                        );\r\n                        return;\r\n                    }\r\n                }\r\n\r\n                if (letNode.field.type) {\r\n                    if (this.checkCircularTypeDependency(letNode.field.type, letNode.field.ident.name, false)) {\r\n                        return;\r\n                    }\r\n                    this.resolveTypeNode(letNode.field.type);\r\n                }\r\n\r\n                let initType = null;\r\n                if (letNode.field.initializer) {\r\n                    initType = this.extractTypeFromInitializer(letNode.field.initializer);\r\n\r\n                    if (initType && (initType.isStruct() || initType.isEnum())) {\r\n                        if (initType.isStruct()) {\r\n                            this.validateStructType(initType.getStruct()!, symbol);\r\n                        }\r\n                        symbol.type = initType;\r\n                        symbol.isTypeChecked = true;\r\n                        return;\r\n                    }\r\n                }\r\n\r\n                let structTypeToValidate: AST.TypeNode | null = null;\r\n                let objectNodeToValidate: AST.ObjectNode | null = null;\r\n\r\n                // Check for overflow before compatibility check\r\n                if (letNode.field.initializer) {\r\n                    if (letNode.field.type) {\r\n                        // Unified validation handles both character literals and overflow\r\n                        this.validateTypeAssignment(\r\n                            letNode.field.initializer,\r\n                            letNode.field.type,\r\n                            `Variable '${letNode.field.ident.name}'`\r\n                        );\r\n                        this.validateValueFitsInType(letNode.field.initializer, letNode.field.type);\r\n                    } else if (initType) {\r\n                        this.validateTypeAssignment(\r\n                            letNode.field.initializer,\r\n                            initType,\r\n                            `Variable '${letNode.field.ident.name}'`\r\n                        );\r\n                    }\r\n                }\r\n\r\n                else if (letNode.field.initializer && !letNode.field.type) {\r\n                    if ((letNode.field.initializer! as AST.ExprNode).is('Primary')) {\r\n                        const primary = (letNode.field.initializer! as AST.ExprNode).getPrimary();\r\n                        if (primary && primary.is('Object')) {\r\n                            const obj = primary.getObject()!;\r\n\r\n                            if (obj.ident) {\r\n                                const typeSymbol = this.config.services.scopeManager.lookupSymbol(obj.ident.name);\r\n                                if (typeSymbol && typeSymbol.type) {\r\n                                    let actualType = this.resolveIdentifierType(typeSymbol.type);\r\n\r\n                                    if (actualType.isStruct()) {\r\n                                        structTypeToValidate = actualType;\r\n                                        objectNodeToValidate = obj;\r\n                                        letNode.field.type = typeSymbol.type;\r\n                                        symbol.type = typeSymbol.type;\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (structTypeToValidate && objectNodeToValidate) {\r\n                    this.validateStructConstruction(objectNodeToValidate, structTypeToValidate, letNode.field.initializer!.span);\r\n                    symbol.isTypeChecked = true;\r\n                    this.stats.typesInferred++;\r\n                    return;\r\n                }\r\n\r\n                if (letNode.field.initializer) {\r\n                    // Special handling for array literals with explicit type\r\n                    if (letNode.field.type && letNode.field.type.isArray()) {\r\n                        this.validateArrayLiteralWithTargetType(\r\n                            letNode.field.initializer,\r\n                            letNode.field.type,\r\n                            letNode.field.ident.name\r\n                        );\r\n                        symbol.type = letNode.field.type;\r\n                        symbol.isTypeChecked = true;\r\n                        this.stats.typesInferred++;\r\n                        return;\r\n                    }\r\n\r\n                    const initType = this.inferExpressionType(letNode.field.initializer);\r\n\r\n                    if (initType) {\r\n                        if (!letNode.field.type) {\r\n                            letNode.field.type = initType;\r\n                            symbol.type = initType;\r\n                            this.stats.typesInferred++;\r\n                        } else {\r\n                            // Use shared helper for array validation\r\n                            if (!this.validateArrayAssignment(\r\n                                letNode.field.type,\r\n                                initType,\r\n                                letNode.field.initializer.span,\r\n                                `Variable '${letNode.field.ident.name}'`\r\n                            )) {\r\n                                symbol.isTypeChecked = true;\r\n                                return;\r\n                            }\r\n\r\n                            // PASS SOURCE EXPRESSION for strict pointer checking\r\n                            if (!this.isTypeCompatible(letNode.field.type, initType, letNode.field.initializer)) {\r\n                                this.reportError(\r\n                                    DiagCode.TYPE_MISMATCH,\r\n                                    `Cannot assign type '${this.getTypeDisplayName(initType)}' to variable of type '${this.getTypeDisplayName(letNode.field.type)}'`,\r\n                                    letNode.field.initializer!.span\r\n                                );\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    // NEW: Check if initializer is an enum variant that requires a value\r\n                    if (letNode.field.initializer.is('Postfix')) {\r\n                        const postfix = letNode.field.initializer.getPostfix();\r\n                        if (postfix?.kind === 'MemberAccess') {\r\n                            const access = postfix.getMemberAccess()!;\r\n                            const baseType = this.inferExpressionType(access.base);\r\n\r\n                            if (baseType) {\r\n                                const resolvedBase = this.resolveIdentifierType(baseType);\r\n\r\n                                if (resolvedBase.isEnum()) {\r\n                                    const memberName = this.extractMemberName(access.target);\r\n                                    const enumDef = resolvedBase.getEnum()!;\r\n                                    const variant = enumDef.variants.find(v => v.ident.name === memberName);\r\n\r\n                                    if (variant && variant.type) {\r\n                                        this.reportError(\r\n                                            DiagCode.TYPE_MISMATCH,\r\n                                            `Enum variant '${memberName}' requires a value of type '${this.getTypeDisplayName(variant.type)}'. Use '${memberName}(value)' syntax.`,\r\n                                            letNode.field.initializer.span\r\n                                        );\r\n                                        return;\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                } else if (!letNode.field.type) {\r\n                    this.reportError(\r\n                        DiagCode.CANNOT_INFER_TYPE,\r\n                        `Variable '${letNode.field.ident.name}' requires explicit type or initializer`,\r\n                        letNode.field.span\r\n                    );\r\n                }\r\n\r\n                symbol.isTypeChecked = true;\r\n            }\r\n\r\n            private isPointerDereference(expr: AST.ExprNode): boolean {\r\n                if (!expr.is('Postfix')) return false;\r\n\r\n                const postfix = expr.getPostfix();\r\n                return postfix?.kind === 'Dereference';\r\n            }\r\n\r\n        // └──────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌───────────────────────────── [3.5] FUNC ─────────────────────────────┐\r\n\r\n            private handleFuncStmt(funcNode: AST.FuncStmtNode, scope?: Scope, moduleName?: string): void {\r\n                this.validateFuncStmt(funcNode);\r\n            }\r\n\r\n            private validateFuncStmt(funcNode: AST.FuncStmtNode): void {\r\n                this.log('symbols', `Type checking function '${funcNode.ident.name}'`);\r\n\r\n                const funcSymbol = this.config.services.scopeManager.getSymbolInCurrentScope(funcNode.ident.name);\r\n                if (!funcSymbol) {\r\n                    this.reportError(\r\n                        DiagCode.CANNOT_INFER_TYPE,\r\n                        `Function '${funcNode.ident.name}' symbol not found`,\r\n                        funcNode.span\r\n                    );\r\n                    return;\r\n                }\r\n\r\n                const funcScope = this.config.services.scopeManager.findChildScopeByName(funcNode.ident.name, ScopeKind.Function);\r\n                if (!funcScope) {\r\n                    this.reportError(\r\n                        DiagCode.CANNOT_INFER_TYPE,\r\n                        `Function scope for '${funcNode.ident.name}' not found`,\r\n                        funcNode.span\r\n                    );\r\n                    return;\r\n                }\r\n\r\n                // Check if the function is stored IN a Type scope\r\n                const funcSymbolScope = this.config.services.scopeManager.getScope(funcSymbol.scope);\r\n\r\n                // For struct methods, funcSymbol.scope points to the Type scope (Point)\r\n                const parentScope = funcSymbolScope.kind === ScopeKind.Type &&\r\n                                funcSymbolScope.metadata?.typeKind === 'Struct'\r\n                    ? funcSymbolScope\r\n                    : null;\r\n\r\n                const isStaticMethod = parentScope !== null &&\r\n                                    funcNode.visibility.kind === 'Static';\r\n\r\n                const isInstanceMethod = parentScope !== null &&\r\n                                        !(funcNode.visibility.kind === 'Static');\r\n\r\n                // Save previous context\r\n                const previousIsStaticMethod = this.currentIsStaticMethod;\r\n                const previousStructScope = this.currentStructScope;\r\n\r\n                // SET CONTEXT BEFORE ENTERING NEW SCOPE - THIS IS CRITICAL\r\n                this.currentIsStaticMethod = isStaticMethod;\r\n                this.currentStructScope = isStaticMethod || isInstanceMethod ? parentScope : null;\r\n\r\n                this.log('symbols', `Function '${funcNode.ident.name}': isStatic=${isStaticMethod}, isInstance=${isInstanceMethod}, structScope=${this.currentStructScope?.name || 'none'}`);\r\n\r\n                // Save and set current function return/error type\r\n                const previousReturnType = this.currentFunctionReturnType;\r\n                const previousHasReturnStmt = this.hasReturnStatement;\r\n                const previousErrorType = this.currentFunctionErrorType;\r\n                const previousHasThrowStmt = this.hasThrowStatement;\r\n\r\n                this.currentFunctionReturnType = funcNode.returnType || null;\r\n                this.hasReturnStatement = false;\r\n                this.currentFunctionErrorType = funcNode.errorType || null;\r\n                this.hasThrowStatement = false;\r\n\r\n                try {\r\n                    this.config.services.contextTracker.withSavedState(() => {\r\n                        this.config.services.scopeManager.withScope(funcScope.id, () => {\r\n                            // ONLY inject self for instance methods (not static)\r\n                            if (isInstanceMethod) {\r\n                                this.resolveSelfParameter(funcScope, parentScope!);\r\n                            }\r\n\r\n                            // Validate parameters\r\n                            for (const param of funcNode.parameters) {\r\n                                this.validateParameter(param);\r\n                            }\r\n\r\n                            // Build function type\r\n                            const paramTypes: AST.TypeNode[] = [];\r\n                            for (const param of funcNode.parameters) {\r\n                                if (param.type) {\r\n                                    paramTypes.push(param.type);\r\n                                } else {\r\n                                    const paramSymbol = funcScope.symbols.get(param.ident.name);\r\n                                    if (paramSymbol?.type) {\r\n                                        paramTypes.push(paramSymbol.type);\r\n                                    } else {\r\n                                        this.reportError(\r\n                                            DiagCode.CANNOT_INFER_TYPE,\r\n                                            `Cannot infer type for parameter '${param.ident.name}'`,\r\n                                            param.span\r\n                                        );\r\n                                        paramTypes.push(AST.TypeNode.asUndefined(param.span));\r\n                                    }\r\n                                }\r\n                            }\r\n\r\n                            funcSymbol.type = AST.TypeNode.asFunction(\r\n                                funcNode.span,\r\n                                paramTypes,\r\n                                funcNode.returnType ?? this.currentFunctionReturnType ?? undefined\r\n                            );\r\n\r\n                            funcSymbol.metadata!.errorType = funcNode.errorType ?? this.currentFunctionErrorType ?? undefined;\r\n\r\n                            // Validate body\r\n                            if (funcNode.body) {\r\n                                this.validateStmt(funcNode.body);\r\n\r\n                                const expectedReturnType = funcNode.returnType || this.currentFunctionReturnType;\r\n\r\n                                if (expectedReturnType && !expectedReturnType.isVoid()) {\r\n                                    const hasErrorType = funcNode.errorType || this.currentFunctionErrorType;\r\n\r\n                                    if (!this.hasReturnStatement) {\r\n                                        if (!hasErrorType || !this.hasThrowStatement) {\r\n                                            this.reportError(\r\n                                                DiagCode.MISSING_RETURN_STATEMENT,\r\n                                                `Function '${funcNode.ident.name}' with non-void return type must have at least one return statement`,\r\n                                                funcNode.ident.span\r\n                                            );\r\n                                        }\r\n                                    }\r\n                                }\r\n\r\n                                if (!funcNode.returnType) {\r\n                                    if (this.currentFunctionReturnType) {\r\n                                        funcSymbol.type!.getFunction()!.returnType = this.currentFunctionReturnType;\r\n                                    } else {\r\n                                        funcSymbol.type!.getFunction()!.returnType = AST.TypeNode.asVoid(funcNode.span);\r\n                                    }\r\n                                }\r\n                            }\r\n                        });\r\n                    });\r\n\r\n                    if (isInstanceMethod) {\r\n                        this.stats.memberAccessValidated++;\r\n                    }\r\n                } finally {\r\n                    this.config.services.contextTracker.completeDeclaration(funcSymbol.id);\r\n\r\n                    // RESTORE context - ALWAYS do this, even on error\r\n                    this.currentIsStaticMethod = previousIsStaticMethod;\r\n                    this.currentStructScope = previousStructScope;\r\n\r\n                    // Restore previous return/error types\r\n                    this.currentFunctionReturnType = previousReturnType;\r\n                    this.hasReturnStatement = previousHasReturnStmt;\r\n                    this.currentFunctionErrorType = previousErrorType;\r\n                    this.hasThrowStatement = previousHasThrowStmt;\r\n                }\r\n\r\n                funcSymbol.isTypeChecked = true;\r\n            }\r\n\r\n            // ───── PARAMS ─────\r\n\r\n            private validateParameter(paramNode: AST.FieldNode): void {\r\n                const paramSymbol = this.config.services.scopeManager.getSymbolInCurrentScope(paramNode.ident.name);\r\n                if (!paramSymbol) return;\r\n\r\n                // Validate parameter visibility\r\n                if (paramNode.visibility.kind === 'Static') {\r\n                    this.reportError(\r\n                        DiagCode.INVALID_VISIBILITY,\r\n                        `Parameter '${paramNode.ident.name}' cannot be 'static'`,\r\n                        paramNode.ident.span\r\n                    );\r\n                    return;\r\n                } else if (paramNode.visibility.kind === 'Public') {\r\n                    this.reportError(\r\n                        DiagCode.INVALID_VISIBILITY,\r\n                        `Parameter '${paramNode.ident.name}' cannot be 'public'`,\r\n                        paramNode.ident.span\r\n                    );\r\n                    return;\r\n                }\r\n\r\n                if (paramNode.initializer) {\r\n                    // Special handling for array literals with explicit type\r\n                    if (paramNode.type && paramNode.type.isArray()) {\r\n                        this.validateArrayLiteralWithTargetType(\r\n                            paramNode.initializer,\r\n                            paramNode.type,\r\n                            paramNode.ident.name\r\n                        );\r\n                        paramSymbol.type = paramNode.type;\r\n                        paramSymbol.isTypeChecked = true;\r\n                        return;\r\n                    }\r\n\r\n                    const initType = this.inferExpressionType(paramNode.initializer);\r\n\r\n                    if (initType) {\r\n                        if (!paramNode.type) {\r\n                            paramNode.type = initType;\r\n                            paramSymbol.type = initType;\r\n                            this.stats.typesInferred++;\r\n                        } else {\r\n                            // Unified validation\r\n                            this.validateTypeAssignment(\r\n                                paramNode.initializer,\r\n                                paramNode.type,\r\n                                `Parameter '${paramNode.ident.name}' default value`\r\n                            );\r\n\r\n                            if (!this.validateArrayAssignment(\r\n                                paramNode.type,\r\n                                initType,\r\n                                paramNode.initializer.span,\r\n                                `Parameter '${paramNode.ident.name}' default value`\r\n                            )) {\r\n                                paramSymbol.isTypeChecked = true;\r\n                                return;\r\n                            }\r\n\r\n                            // PASS SOURCE EXPRESSION for strict pointer checking\r\n                            if (!this.isTypeCompatible(paramNode.type, initType, paramNode.initializer)) {\r\n                                this.reportError(\r\n                                    DiagCode.TYPE_MISMATCH,\r\n                                    `Cannot assign type '${this.getTypeDisplayName(initType)}' to parameter of type '${this.getTypeDisplayName(paramNode.type)}'`,\r\n                                    paramNode.initializer.span\r\n                                );\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    // NEW: Check if initializer is an enum variant that requires a value\r\n                    if (paramNode.initializer.is('Postfix')) {\r\n                        const postfix = paramNode.initializer.getPostfix();\r\n                        if (postfix?.kind === 'MemberAccess') {\r\n                            const access = postfix.getMemberAccess()!;\r\n                            const baseType = this.inferExpressionType(access.base);\r\n\r\n                            if (baseType) {\r\n                                const resolvedBase = this.resolveIdentifierType(baseType);\r\n\r\n                                if (resolvedBase.isEnum()) {\r\n                                    const memberName = this.extractMemberName(access.target);\r\n                                    const enumDef = resolvedBase.getEnum()!;\r\n                                    const variant = enumDef.variants.find(v => v.ident.name === memberName);\r\n\r\n                                    if (variant && variant.type) {\r\n                                        this.reportError(\r\n                                            DiagCode.TYPE_MISMATCH,\r\n                                            `Enum variant '${memberName}' requires a value of type '${this.getTypeDisplayName(variant.type)}'. Use '${memberName}(value)' syntax.`,\r\n                                            paramNode.initializer.span\r\n                                        );\r\n                                        return;\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    if(paramNode.type) {\r\n                        this.validateValueFitsInType(paramNode.initializer, paramNode.type!);\r\n                    }\r\n                }\r\n\r\n                paramSymbol.isTypeChecked = true;\r\n            }\r\n\r\n            private resolveSelfParameter(funcScope: Scope, structScope: Scope): void {\r\n                const selfSymbol = funcScope.symbols.get('self');\r\n                if (!selfSymbol) {\r\n                    this.log('verbose', `Warning: Expected 'self' parameter in struct method but not found`);\r\n                    return;\r\n                }\r\n\r\n                // Mark self as declared and used in resolution phase\r\n                selfSymbol.declared = true;\r\n                selfSymbol.used = true; // Mark as used by default since it's implicit\r\n\r\n                if (selfSymbol.type) {\r\n                    if (selfSymbol.type.kind === 'ident') {\r\n                        const typeIdent = selfSymbol.type.getIdent()!;\r\n                        if (typeIdent.name !== structScope.name) {\r\n                            this.reportError(\r\n                                DiagCode.TYPE_MISMATCH,\r\n                                `Self type mismatch: expected '${structScope.name}', got '${typeIdent.name}'`,\r\n                                selfSymbol.contextSpan\r\n                            );\r\n                        }\r\n                    }\r\n                }\r\n\r\n                this.log('symbols', `Resolved 'self' parameter in struct method`);\r\n            }\r\n\r\n        // └──────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌───────────────────────────── [3.6] LOOP ─────────────────────────────┐\r\n\r\n            private handleLoopStmt(stmt: AST.StmtNode, scope?: Scope, moduleName?: string): void {\r\n                if(stmt.getLoop === undefined) {\r\n                    const data = stmt;\r\n                    switch (stmt.kind) {\r\n                        case 'While' : {\r\n                            const src = data.source as AST.LoopStmtNode;\r\n                            const loop = AST.LoopStmtNode.createWhile(data.span, src.expr, src.stmt);\r\n                            this.validateLoopStmt(loop);\r\n                            break;\r\n                        }\r\n                        case 'Do' : {\r\n                            const src = data.source as AST.LoopStmtNode;\r\n                            const loop = AST.LoopStmtNode.createDo(data.span, src.expr, src.stmt);\r\n                            this.validateLoopStmt(loop);\r\n                            break;\r\n                        }\r\n                        case 'For' : {\r\n                            const src = data.source as AST.LoopStmtNode;\r\n                            const loop = AST.LoopStmtNode.createFor(data.span, src.expr, src.stmt);\r\n                            this.validateLoopStmt(loop);\r\n                            break;\r\n                        }\r\n                    }\r\n                } else {\r\n                    this.validateLoopStmt(stmt.getLoop()!);\r\n                }\r\n            }\r\n\r\n            private validateLoopStmt(loopStmt: AST.LoopStmtNode): void {\r\n                const loopScope = this.config.services.scopeManager.findChildScopeByName('loop', ScopeKind.Loop);\r\n                if (!loopScope) return;\r\n\r\n                this.config.services.contextTracker.withSavedState(() => {\r\n                    this.config.services.scopeManager.withScope(loopScope.id, () => {\r\n                        if (loopStmt.expr) {\r\n                            const condType = this.inferExpressionType(loopStmt.expr);\r\n\r\n                            if (loopStmt.kind === 'While' && condType && !condType.isBool()) {\r\n                                this.log('verbose', `Loop condition has type ${this.getTypeDisplayName(condType)}, not bool`);\r\n                            }\r\n                        }\r\n\r\n                        if (loopStmt.stmt) {\r\n                            this.validateStmt(loopStmt.stmt);\r\n                        }\r\n                    });\r\n                });\r\n            }\r\n\r\n        // └──────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌──────────────────────────── [3.7] CTRLFLOW ──────────────────────────┐\r\n\r\n            private handleControlflowStmt(stmt: AST.StmtNode, scope?: Scope, moduleName?: string): void {\r\n                if(stmt.getCtrlflow === undefined) {\r\n                    const data = stmt;\r\n                    switch (stmt.kind) {\r\n                        case 'Return' : {\r\n                            const src = data.source as AST.ControlFlowStmtNode;\r\n                            const res = AST.ControlFlowStmtNode.asReturn(data.span, src.value);\r\n                            this.validateReturnStmt(res);\r\n                            break;\r\n                        }\r\n                        case 'Defer' : {\r\n                            const src = data.source as AST.ControlFlowStmtNode;\r\n                            const res = AST.ControlFlowStmtNode.asDefer(data.span, src.value);\r\n                            this.validateDeferStmt(res);\r\n                            break;\r\n                        }\r\n                        case 'Throw' : {\r\n                            const src = data.source as AST.ControlFlowStmtNode;\r\n                            const res = AST.ControlFlowStmtNode.asThrow(data.span, src.value);\r\n                            this.validateThrowStmt(res);\r\n                            break;\r\n                        }\r\n                    }\r\n                } else {\r\n                    switch (stmt.getCtrlflow()!.kind) {\r\n                        case 'return' : {\r\n                            this.validateReturnStmt(stmt.getCtrlflow()!);\r\n                            break;\r\n                        }\r\n                        case 'defer' : {\r\n                            this.validateDeferStmt(stmt.getCtrlflow()!);\r\n                            break;\r\n                        }\r\n                        case 'throw' : {\r\n                            this.validateThrowStmt(stmt.getCtrlflow()!);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            private validateReturnStmt(returnNode: AST.ControlFlowStmtNode): void {\r\n                this.log('symbols', 'Validating return statement');\r\n\r\n                this.stats.returnsValidated++;\r\n                this.hasReturnStatement = true;\r\n\r\n                const isInFunction = this.isInsideFunctionScope();\r\n\r\n                if (returnNode.value) {\r\n                    const isConstructor = this.isConstructorExpression(returnNode.value);\r\n\r\n                    if (!isConstructor && this.isTypeExpression(returnNode.value)) {\r\n                        const functionReturnsType = this.currentFunctionReturnType && this.isTypeType(this.currentFunctionReturnType);\r\n\r\n                        if (!functionReturnsType) {\r\n                            this.reportError(\r\n                                DiagCode.TYPE_MISMATCH,\r\n                                `Cannot return a type as a value. Expected a value of type '${this.currentFunctionReturnType ? this.getTypeDisplayName(this.currentFunctionReturnType!) : 'void'}', got type expression`,\r\n                                returnNode.value.span\r\n                            );\r\n                            return;\r\n                        }\r\n                    }\r\n\r\n                    // Unified character literal validation for returns\r\n                    if (isInFunction && this.currentFunctionReturnType) {\r\n                        if (!this.validateTypeAssignment(\r\n                            returnNode.value,\r\n                            this.currentFunctionReturnType,\r\n                            'Return value'\r\n                        )) {\r\n                            return; // Error already reported\r\n                        }\r\n                    }\r\n\r\n                    const returnType = this.inferExpressionType(returnNode.value);\r\n\r\n                    if (!returnType && this.config.services.diagnosticManager.hasErrors()) {\r\n                        return;\r\n                    }\r\n\r\n                    if (isInFunction && this.currentFunctionReturnType) {\r\n                        // PASS SOURCE EXPRESSION for strict pointer checking\r\n                        if (returnType && !this.isTypeCompatible(this.currentFunctionReturnType, returnType, returnNode.value)) {\r\n                            this.reportError(\r\n                                DiagCode.TYPE_MISMATCH,\r\n                                `Return type '${this.getTypeDisplayName(returnType)}' doesn't match function return type '${this.getTypeDisplayName(this.currentFunctionReturnType)}'`,\r\n                                returnNode.value.span\r\n                            );\r\n                        }\r\n                    } else if (!isInFunction) {\r\n                        this.reportError(\r\n                            DiagCode.ANALYSIS_ERROR,\r\n                            `Return statement outside of function`,\r\n                            returnNode.span\r\n                        );\r\n                    }\r\n                } else {\r\n                    if (isInFunction && this.currentFunctionReturnType && !this.currentFunctionReturnType.isVoid()) {\r\n                        this.reportError(\r\n                            DiagCode.TYPE_MISMATCH,\r\n                            `Function expects return type '${this.getTypeDisplayName(this.currentFunctionReturnType)}' but got void return`,\r\n                            returnNode.span\r\n                        );\r\n                    } else if (!isInFunction) {\r\n                        this.reportError(\r\n                            DiagCode.ANALYSIS_ERROR,\r\n                            `Return statement outside of function`,\r\n                            returnNode.span\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n\r\n            private isConstructorExpression(expr: AST.ExprNode): boolean {\r\n                if (!expr.is('Primary')) return false;\r\n                const primary = expr.getPrimary();\r\n                if (!primary?.is('Object')) return false;\r\n                const obj = primary.getObject();\r\n                // Constructor has a type name: Point { x: 0, y: 0 }\r\n                return obj?.ident !== null && obj?.ident !== undefined;\r\n            }\r\n\r\n            private validateDeferStmt(deferNode: AST.ControlFlowStmtNode): void {\r\n                // this.stats.defersValidated++;\r\n\r\n                // Check if we're in a function scope by walking up the scope chain\r\n                const isInFunction = this.isInsideFunctionScope();\r\n\r\n                if (deferNode.value) {\r\n                    this.inferExpressionType(deferNode.value);\r\n                }\r\n\r\n                if (!isInFunction) {\r\n                    this.reportError(\r\n                        DiagCode.ANALYSIS_ERROR,\r\n                        `Defer statement outside of function`,\r\n                        deferNode.span\r\n                    );\r\n                }\r\n            }\r\n\r\n            private validateThrowStmt(throwNode: AST.ControlFlowStmtNode): void {\r\n                this.log('symbols', 'Validating throw statement');\r\n\r\n                // Mark that we encountered a throw statement\r\n                this.hasThrowStatement = true;\r\n\r\n                // Check if we're in a function scope\r\n                const isInFunction = this.isInsideFunctionScope();\r\n\r\n                if (!isInFunction) {\r\n                    this.reportError(\r\n                        DiagCode.ANALYSIS_ERROR,\r\n                        `Throw statement outside of function`,\r\n                        throwNode.span\r\n                    );\r\n                    return;\r\n                }\r\n\r\n                // Get the current function's error type\r\n                const functionErrorType = this.getCurrentFunctionErrorType();\r\n\r\n                if (!functionErrorType) {\r\n                    this.reportError(\r\n                        DiagCode.THROW_WITHOUT_ERROR_TYPE,\r\n                        `Cannot throw error in function without error type. Add '!ErrorType' to function signature`,\r\n                        throwNode.span\r\n                    );\r\n                    return;\r\n                }\r\n\r\n                // Validate the thrown expression\r\n                if (throwNode.value) {\r\n                    // TRY to infer type, but don't fail if we can't\r\n                    const thrownType = this.inferExpressionType(throwNode.value);\r\n\r\n                    // For error members, we might not get a full type\r\n                    // Instead, validate directly using the expression\r\n                    if (!thrownType) {\r\n                        // Can't infer type - validate using expression directly\r\n                        this.validateThrowExpression(throwNode.value, functionErrorType, throwNode.value.span);\r\n                        return;\r\n                    }\r\n\r\n                    // Normal path: validate with both type and expression\r\n                    this.validateThrowType(thrownType, functionErrorType, throwNode.value, throwNode.value.span);\r\n                } else {\r\n                    this.reportError(\r\n                        DiagCode.ANALYSIS_ERROR,\r\n                        `Throw statement must have an error value`,\r\n                        throwNode.span\r\n                    );\r\n                }\r\n            }\r\n\r\n            private validateThrowExpression(\r\n                throwExpr: AST.ExprNode,\r\n                functionErrorType: AST.TypeNode,\r\n                span: AST.Span\r\n            ): void {\r\n                const funcSymbol = this.getCurrentFunctionSymbol();\r\n                const errorMode = funcSymbol?.metadata?.errorMode as string | undefined;\r\n\r\n                this.log('symbols', `Validating throw expression with error mode: ${errorMode || 'unknown'}`);\r\n\r\n                switch (errorMode) {\r\n                    case 'any-error':\r\n                        // For any-error mode, check if expression looks like an error\r\n                        // (member access on error set, identifier that might be error, etc.)\r\n                        if (!this.isErrorExpression(throwExpr)) {\r\n                            this.reportError(\r\n                                DiagCode.TYPE_MISMATCH,\r\n                                `Cannot throw non-error type. Expected error type`,\r\n                                span\r\n                            );\r\n                        }\r\n                        break;\r\n\r\n                    case 'err-ident':\r\n                    case 'err-group':\r\n                        // For specific error types, validate the expression matches\r\n                        if (!this.isValidErrorExpression(throwExpr, functionErrorType)) {\r\n                            this.reportError(\r\n                                DiagCode.THROW_TYPE_MISMATCH,\r\n                                `Thrown error does not match function error type '${this.getTypeDisplayName(functionErrorType)}'`,\r\n                                span\r\n                            );\r\n                        }\r\n                        break;\r\n\r\n                    case 'self-group':\r\n                        // For self-group, validate member access on selferr\r\n                        const errorName = this.extractErrorMemberName(throwExpr);\r\n                        const allowedErrors = funcSymbol?.metadata?.selfGroupErrors as string[] | undefined;\r\n\r\n                        if (!errorName) {\r\n                            this.reportError(\r\n                                DiagCode.TYPE_MISMATCH,\r\n                                `Cannot resolve error member from thrown expression`,\r\n                                span\r\n                            );\r\n                        } else if (!allowedErrors || !allowedErrors.includes(errorName)) {\r\n                            this.reportError(\r\n                                DiagCode.ERROR_MEMBER_NOT_FOUND,\r\n                                `Error '${errorName}' is not in function's error set [${allowedErrors?.join(', ') || ''}]`,\r\n                                span\r\n                            );\r\n                        }\r\n                        break;\r\n\r\n                    default:\r\n                        // Unknown mode - be lenient but warn\r\n                        this.log('verbose', `Unknown error mode in validateThrowExpression`);\r\n                        if (!this.isErrorExpression(throwExpr)) {\r\n                            this.reportError(\r\n                                DiagCode.TYPE_MISMATCH,\r\n                                `Cannot throw non-error type`,\r\n                                span\r\n                            );\r\n                        }\r\n                }\r\n            }\r\n\r\n            private isErrorExpression(expr: AST.ExprNode): boolean {\r\n                // Check for member access (ErrorSet.Member)\r\n                if (expr.is('Postfix')) {\r\n                    const postfix = expr.getPostfix();\r\n                    if (postfix?.kind === 'MemberAccess') {\r\n                        const memberAccess = postfix.getMemberAccess()!;\r\n\r\n                        // Check if base is an identifier that refers to an error set\r\n                        if (memberAccess.base.is('Primary')) {\r\n                            const primary = memberAccess.base.getPrimary();\r\n                            if (primary?.is('Ident')) {\r\n                                const ident = primary.getIdent()!;\r\n                                const baseSymbol = this.config.services.scopeManager.lookupSymbol(ident.name);\r\n\r\n                                // Check if it's an error set or selferr\r\n                                if (ident.name === 'selferr') return true;\r\n                                if (baseSymbol?.type?.isErrset()) return true;\r\n                                if (baseSymbol?.kind === SymbolKind.Definition && baseSymbol.type?.isErrset()) return true;\r\n                            }\r\n                        }\r\n                        return true; // Assume member access might be error\r\n                    }\r\n                }\r\n\r\n                // Check for direct identifier (might be error variable)\r\n                if (expr.is('Primary')) {\r\n                    const primary = expr.getPrimary();\r\n                    if (primary?.is('Ident')) {\r\n                        const ident = primary.getIdent()!;\r\n                        const symbol = this.config.services.scopeManager.lookupSymbol(ident.name);\r\n\r\n                        // Check if it's an error variable or error type\r\n                        if (symbol?.kind === SymbolKind.Variable && symbol.type?.isErr()) return true;\r\n                        if (symbol?.kind === SymbolKind.Error) return true;\r\n                        if (symbol?.type?.isErrset()) return true;\r\n                    }\r\n                }\r\n\r\n                return false;\r\n            }\r\n\r\n            private isValidErrorExpression(expr: AST.ExprNode, expectedType: AST.TypeNode): boolean {\r\n                // For member access: ErrorSet.Member\r\n                if (expr.is('Postfix')) {\r\n                    const postfix = expr.getPostfix();\r\n                    if (postfix?.kind === 'MemberAccess') {\r\n                        const memberAccess = postfix.getMemberAccess()!;\r\n\r\n                        if (memberAccess.base.is('Primary')) {\r\n                            const primary = memberAccess.base.getPrimary();\r\n                            if (primary?.is('Ident')) {\r\n                                const ident = primary.getIdent()!;\r\n\r\n                                // Check if base matches expected type name\r\n                                if (expectedType.isIdent()) {\r\n                                    const expectedIdent = expectedType.getIdent()!;\r\n                                    return ident.name === expectedIdent.name;\r\n                                }\r\n\r\n                                // Check if base symbol matches expected type\r\n                                const baseSymbol = this.config.services.scopeManager.lookupSymbol(ident.name);\r\n                                if (baseSymbol?.type) {\r\n                                    const resolvedExpected = this.resolveIdentifierType(expectedType);\r\n                                    return this.isSameType(baseSymbol.type, resolvedExpected);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // For direct identifier: check if it matches expected error variable\r\n                if (expr.is('Primary')) {\r\n                    const primary = expr.getPrimary();\r\n                    if (primary?.is('Ident')) {\r\n                        const ident = primary.getIdent()!;\r\n\r\n                        // Check if identifier matches expected type name\r\n                        if (expectedType.isIdent()) {\r\n                            const expectedIdent = expectedType.getIdent()!;\r\n                            return ident.name === expectedIdent.name;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                return true; // If we can't determine, be lenient\r\n            }\r\n\r\n            private validateThrowType(\r\n                thrownType: AST.TypeNode,\r\n                functionErrorType: AST.TypeNode,\r\n                throwExpr: AST.ExprNode,\r\n                span: AST.Span\r\n            ): void {\r\n                const funcSymbol = this.getCurrentFunctionSymbol();\r\n                const errorMode = funcSymbol?.metadata?.errorMode as string | undefined;\r\n\r\n                this.log('symbols', `Validating throw with error mode: ${errorMode || 'unknown'}`);\r\n\r\n                switch (errorMode) {\r\n                    case 'any-error':\r\n                        // Accept ANY error type\r\n                        if (!this.isErrorType(thrownType)) {\r\n                            this.reportError(\r\n                                DiagCode.TYPE_MISMATCH,\r\n                                `Cannot throw non-error type '${this.getTypeDisplayName(thrownType)}'. Expected error type`,\r\n                                span\r\n                            );\r\n                        }\r\n                        break;\r\n\r\n                    case 'err-ident':\r\n                    case 'err-group': {\r\n                        // Quick check: if throwing an identifier, check if it matches the function's expected error type\r\n                        if (throwExpr.is('Primary')) {\r\n                            const primary = throwExpr.getPrimary();\r\n                            if (primary?.is('Ident')) {\r\n                                const thrownIdent = primary.getIdent()!.name;\r\n\r\n                                // Check if function expects an identifier type\r\n                                if (functionErrorType.isIdent()) {\r\n                                    const funcIdent = functionErrorType.getIdent()!.name;\r\n                                    if (thrownIdent === funcIdent) {\r\n                                        // Same identifier - always valid\r\n                                        break;\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                        // Extract what the thrown expression actually refers to\r\n                        let thrownErrorName: string = '';\r\n                        let thrownErrorSet: AST.TypeNode | null = null;\r\n\r\n                        // If throwing an identifier (like MyError), look up what it refers to\r\n                        if (throwExpr.is('Primary')) {\r\n                            const primary = throwExpr.getPrimary();\r\n                            if (primary?.is('Ident')) {\r\n                                const thrownIdent = primary.getIdent()!.name;\r\n                                thrownErrorName = thrownIdent;\r\n\r\n                                // Look up the symbol to get what it actually refers to\r\n                                const thrownSymbol = this.config.services.scopeManager.lookupSymbol(thrownIdent);\r\n                                if (thrownSymbol && thrownSymbol.type) {\r\n                                    thrownErrorSet = this.resolveIdentifierType(thrownSymbol.type);\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                        // If throwing a member access (like FileErrors.NotFound)\r\n                        if (throwExpr.is('Postfix')) {\r\n                            const postfix = throwExpr.getPostfix();\r\n                            if (postfix?.kind === 'MemberAccess') {\r\n                                const memberAccess = postfix.getMemberAccess()!;\r\n                                thrownErrorName = this.extractMemberName(memberAccess.target) || '';\r\n\r\n                                // Get the base type (FileErrors)\r\n                                const baseType = this.inferExpressionType(memberAccess.base);\r\n                                if (baseType) {\r\n                                    thrownErrorSet = this.resolveIdentifierType(baseType);\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                        // Resolve the function's expected error type\r\n                        const resolvedFunctionError = this.resolveIdentifierType(functionErrorType);\r\n\r\n                        // CASE 1: Both are error sets - check if member is in set or if sets are identical\r\n                        if (thrownErrorSet?.isErrset() && resolvedFunctionError.isErrset()) {\r\n                            const thrownSet = thrownErrorSet.getErrset()!;\r\n                            const expectedSet = resolvedFunctionError.getErrset()!;\r\n\r\n                            // Check if thrown error set is the same as expected set\r\n                            if (this.isSameErrorType(thrownErrorSet, resolvedFunctionError)) {\r\n                                break;\r\n                            }\r\n\r\n                            // Check if the specific thrown member is in the expected set\r\n                            if (thrownErrorName) {\r\n                                const isMember = expectedSet.members.some(m => m.name === thrownErrorName);\r\n                                if (isMember) {\r\n                                    break;\r\n                                }\r\n                            }\r\n\r\n                            this.reportError(\r\n                                DiagCode.THROW_TYPE_MISMATCH,\r\n                                `Thrown error type '${thrownErrorName || this.getTypeDisplayName(thrownType)}' is not compatible with function error type '${this.getTypeDisplayName(functionErrorType)}'`,\r\n                                span\r\n                            );\r\n                            break;\r\n                        }\r\n\r\n                        // CASE 2: Function expects identifier that resolves to error set\r\n                        if (resolvedFunctionError.isErrset()) {\r\n                            const expectedSet = resolvedFunctionError.getErrset()!;\r\n\r\n                            // Check if thrown member is in the expected set\r\n                            if (thrownErrorName) {\r\n                                const isMember = expectedSet.members.some(m => m.name === thrownErrorName);\r\n                                if (isMember) {\r\n                                    break;\r\n                                }\r\n                            }\r\n\r\n                            this.reportError(\r\n                                DiagCode.THROW_TYPE_MISMATCH,\r\n                                `Thrown error type '${thrownErrorName || this.getTypeDisplayName(thrownType)}' is not compatible with function error type '${this.getTypeDisplayName(functionErrorType)}'`,\r\n                                span\r\n                            );\r\n                            break;\r\n                        }\r\n\r\n                        // If we get here, something didn't match - report error\r\n                        this.reportError(\r\n                            DiagCode.THROW_TYPE_MISMATCH,\r\n                            `Thrown error type '${thrownErrorName || this.getTypeDisplayName(thrownType)}' is not compatible with function error type '${this.getTypeDisplayName(functionErrorType)}'`,\r\n                            span\r\n                        );\r\n                        break;\r\n                    }\r\n\r\n                    case 'self-group':\r\n                        // Extract error name from the EXPRESSION, not the type\r\n                        const errorName = this.extractErrorMemberName(throwExpr);\r\n                        const allowedErrors = funcSymbol?.metadata?.selfGroupErrors as string[] | undefined;\r\n\r\n                        if (!errorName) {\r\n                            this.reportError(\r\n                                DiagCode.TYPE_MISMATCH,\r\n                                `Cannot resolve error member from thrown expression`,\r\n                                span\r\n                            );\r\n                        } else if (!allowedErrors || !allowedErrors.includes(errorName)) {\r\n                            this.reportError(\r\n                                DiagCode.ERROR_MEMBER_NOT_FOUND,\r\n                                `Error '${errorName}' is not in function's error set [${allowedErrors?.join(', ') || ''}]`,\r\n                                span\r\n                            );\r\n                        }\r\n                        break;\r\n\r\n                    default:\r\n                        // No error mode (shouldn't happen) - fall back to original logic\r\n                        this.log('verbose', `Unknown error mode, falling back to legacy validation`);\r\n                        if (functionErrorType.isErr()) {\r\n                            if (!this.isErrorType(thrownType)) {\r\n                                this.reportError(\r\n                                    DiagCode.TYPE_MISMATCH,\r\n                                    `Cannot throw non-error type`,\r\n                                    span\r\n                                );\r\n                            }\r\n                        } else {\r\n                            const resolvedFunctionError = this.resolveIdentifierType(functionErrorType);\r\n                            const resolvedThrownType = this.resolveIdentifierType(thrownType);\r\n\r\n                            if (!this.isValidThrowType(resolvedThrownType, resolvedFunctionError, span)) {\r\n                                this.reportError(\r\n                                    DiagCode.THROW_TYPE_MISMATCH,\r\n                                    `Thrown error type is not compatible with function error type`,\r\n                                    span\r\n                                );\r\n                            }\r\n                        }\r\n                }\r\n            }\r\n\r\n            private isSameErrorType(type1: AST.TypeNode, type2: AST.TypeNode): boolean {\r\n                // Resolve both to their base forms\r\n                const resolved1 = this.resolveIdentifierType(type1);\r\n                const resolved2 = this.resolveIdentifierType(type2);\r\n\r\n                // CASE 1: Both are error sets - compare their members (IdentNode names)\r\n                if (resolved1.isErrset() && resolved2.isErrset()) {\r\n                    const set1 = resolved1.getErrset()!;\r\n                    const set2 = resolved2.getErrset()!;\r\n\r\n                    if (set1.members.length !== set2.members.length) return false;\r\n\r\n                    const members1 = new Set(set1.members.map(m => m.name));\r\n                    const members2 = new Set(set2.members.map(m => m.name));\r\n\r\n                    for (const member of members1) {\r\n                        if (!members2.has(member)) return false;\r\n                    }\r\n                    return true;\r\n                }\r\n\r\n                // CASE 2: Both are err primitives - compare their text values\r\n                if (resolved1.isErr() && resolved2.isErr()) {\r\n                    const prim1 = resolved1.getPrimitive();\r\n                    const prim2 = resolved2.getPrimitive();\r\n                    return prim1?.text === prim2?.text;\r\n                }\r\n\r\n                // CASE 3: Both are identifiers - compare names\r\n                if (resolved1.isIdent() && resolved2.isIdent()) {\r\n                    return resolved1.getIdent()!.name === resolved2.getIdent()!.name;\r\n                }\r\n\r\n                // Fall back to standard type comparison\r\n                return this.isSameType(resolved1, resolved2);\r\n            }\r\n\r\n            private getCurrentFunctionSymbol(): Symbol | null {\r\n                let currentScope = this.config.services.scopeManager.getCurrentScope();\r\n\r\n                while (currentScope && currentScope.kind !== ScopeKind.Function) {\r\n                    const parent = this.config.services.scopeManager.getScopeParent(currentScope.id);\r\n                    if (!parent) break;\r\n                    currentScope = parent;\r\n                }\r\n\r\n                if (!currentScope || currentScope.kind !== ScopeKind.Function) {\r\n                    return null;\r\n                }\r\n\r\n                const parentScope = this.config.services.scopeManager.getScopeParent(currentScope.id);\r\n                if (!parentScope) return null;\r\n\r\n                return parentScope.symbols.get(currentScope.name) || null;\r\n            }\r\n\r\n            private extractErrorMemberName(thrownExpr: AST.ExprNode): string | null {\r\n                // Handle direct identifier: throw IOError\r\n                if (thrownExpr.is('Primary')) {\r\n                    const primary = thrownExpr.getPrimary();\r\n                    if (primary?.is('Ident')) {\r\n                        return primary.getIdent()!.name;\r\n                    }\r\n                }\r\n\r\n                // Handle member access: throw selferr.IOError\r\n                if (thrownExpr.is('Postfix')) {\r\n                    const postfix = thrownExpr.getPostfix();\r\n                    if (postfix?.kind === 'MemberAccess') {\r\n                        const memberAccess = postfix.getMemberAccess()!;\r\n\r\n                        // Check if base is 'selferr'\r\n                        if (memberAccess.base.is('Primary')) {\r\n                            const primary = memberAccess.base.getPrimary();\r\n                            if (primary?.is('Ident')) {\r\n                                const ident = primary.getIdent();\r\n                                if (ident?.name === 'selferr') {\r\n                                    // Extract the member name (the error variant)\r\n                                    if (memberAccess.target.is('Primary')) {\r\n                                        const targetPrimary = memberAccess.target.getPrimary();\r\n                                        if (targetPrimary?.is('Ident')) {\r\n                                            return targetPrimary.getIdent()!.name;\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                return null;\r\n            }\r\n\r\n            private getCurrentFunctionErrorType(): AST.TypeNode | null {\r\n                // Check if we're in a function scope\r\n                const isInFunction = this.isInsideFunctionScope();\r\n\r\n                if(isInFunction && this.currentFunctionErrorType) {\r\n                    return this.currentFunctionErrorType;\r\n                }\r\n\r\n                // fallback\r\n                {\r\n                    let currentScope = this.config.services.scopeManager.getCurrentScope();\r\n\r\n                    // Walk up to find function scope\r\n                    while (currentScope && currentScope.kind !== ScopeKind.Function) {\r\n                        const parent = this.config.services.scopeManager.getScopeParent(currentScope.id);\r\n                        if (!parent) break;\r\n                        currentScope = parent;\r\n                    }\r\n\r\n                    if (!currentScope || currentScope.kind !== ScopeKind.Function) {\r\n                        return null;\r\n                    }\r\n\r\n                    // Find the function symbol\r\n                    const parentScope = this.config.services.scopeManager.getScopeParent(currentScope.id);\r\n                    if (!parentScope) return null;\r\n\r\n                    const funcSymbol = parentScope.symbols.get(currentScope.name);\r\n                    if (!funcSymbol || !funcSymbol.type || !funcSymbol.type.isFunction()) {\r\n                        return null;\r\n                    }\r\n\r\n                    const funcType = funcSymbol.type.getFunction()!;\r\n                    if(funcSymbol.metadata) { funcSymbol.metadata.errorType = funcType.errorType; }\r\n\r\n                    return funcType.errorType || null;\r\n                }\r\n            }\r\n\r\n        // └──────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌─────────────────────────── [4] EXPR Level ───────────────────────────┐\r\n\r\n            private inferExpressionType(expr: AST.ExprNode): AST.TypeNode | null {\r\n                if (!expr) return null;\r\n\r\n                const cacheKey = this.createCacheKey(expr);\r\n\r\n                if (this.inferenceStack.has(cacheKey)) {\r\n                    this.log('verbose', `Circular type inference detected for ${cacheKey}`);\r\n                    return null;\r\n                }\r\n\r\n                this.inferenceStack.add(cacheKey);\r\n                try {\r\n                    const inferredType = this.performTypeInference(expr);\r\n                    if (inferredType) {\r\n                        this.cacheType(cacheKey, inferredType);\r\n                        this.stats.typesInferred++;\r\n                    }\r\n                    return inferredType;\r\n                } finally {\r\n                    this.inferenceStack.delete(cacheKey);\r\n                }\r\n            }\r\n\r\n            private performTypeInference(expr: AST.ExprNode): AST.TypeNode | null {\r\n                this.config.services.contextTracker.pushContextSpan(expr.span);\r\n                try {\r\n                    switch (expr.kind) {\r\n                        case 'Primary':\r\n                            return this.inferPrimaryType(expr.getPrimary()!);\r\n                        case 'Binary':\r\n                            return this.inferBinaryType(expr.getBinary()!);\r\n                        case 'Prefix':\r\n                            return this.inferPrefixType(expr.getPrefix()!);\r\n                        case 'Postfix':\r\n                            return this.inferPostfixType(expr.getPostfix()!);\r\n                        case 'As':\r\n                            return this.inferAsType(expr.getAs()!);\r\n                        case 'Typeof': {\r\n                            const typeofNode = expr.getTypeof()!;\r\n                            const innerType = this.inferExpressionType(typeofNode.expr);\r\n\r\n                            if (!innerType) {\r\n                                this.reportError(\r\n                                    DiagCode.TYPE_INFERENCE_FAILED,\r\n                                    'Cannot infer type for typeof expression',\r\n                                    typeofNode.expr.span\r\n                                );\r\n                                return null;\r\n                            }\r\n\r\n                            // Return the 'type' primitive, NOT the actual type\r\n                            // This makes typeof return a TYPE (not usable in arithmetic)\r\n                            return AST.TypeNode.asPrimitive(expr.span, 'type');\r\n                        }\r\n\r\n                        case 'Sizeof': {\r\n                            const sizeofNode = expr.getSizeof()!;\r\n                            const targetType = this.inferExpressionType(sizeofNode.expr);\r\n\r\n                            if (!targetType) {\r\n                                this.reportError(\r\n                                    DiagCode.TYPE_INFERENCE_FAILED,\r\n                                    'Cannot infer type for sizeof expression',\r\n                                    sizeofNode.expr.span\r\n                                );\r\n                                return null;\r\n                            }\r\n\r\n                            // Compute size at compile time\r\n                            const size = this.computeTypeSize(targetType);\r\n\r\n                            if (size === null) {\r\n                                this.reportError(\r\n                                    DiagCode.INVALID_SIZEOF_TARGET,\r\n                                    `Cannot compute size of type '${this.getTypeDisplayName(targetType)}'`,\r\n                                    sizeofNode.expr.span\r\n                                );\r\n                                return AST.TypeNode.asComptimeInt(expr.span, '0');\r\n                            }\r\n\r\n                            // Return as compile-time integer\r\n                            return AST.TypeNode.asComptimeInt(expr.span, size.toString());\r\n                        }\r\n                        case 'Orelse':\r\n                            return this.inferOrelseType(expr.getOrelse()!);\r\n                        case 'Range':\r\n                            return this.inferRangeType(expr.getRange()!);\r\n                        case 'Try':\r\n                            return this.inferTryType(expr.getTry()!);\r\n                        case 'Catch':\r\n                            return this.inferCatchType(expr.getCatch()!);\r\n                        case 'If':\r\n                            return this.inferIfType(expr.getIf()!);\r\n                        case 'Match':\r\n                            return this.inferSwitchType(expr.getMatch()!);\r\n                        default:\r\n                            return null;\r\n                    }\r\n                } finally {\r\n                    this.config.services.contextTracker.popContextSpan();\r\n                }\r\n            }\r\n\r\n            private computeTypeSize(type: AST.TypeNode): number | null {\r\n                // Resolve identifier types first\r\n                const resolved = this.resolveIdentifierType(type);\r\n                return this.ExpressionEvaluator.computeTypeSize(resolved);\r\n            }\r\n\r\n            private resolveTypeNode(typeNode: AST.TypeNode): void {\r\n                switch (typeNode.kind) {\r\n                    case 'struct':\r\n                        const tempSymbol: Symbol = {\r\n                            id: -1,\r\n                            name: '<struct-validation>',\r\n                            kind: SymbolKind.Definition,\r\n                            type: typeNode,\r\n                            scope: this.config.services.scopeManager.getCurrentScope().id,\r\n                            contextSpan: typeNode.span,\r\n                            declared: true,\r\n                            initialized: true,\r\n                            used: false,\r\n                            isTypeChecked: false,\r\n                            visibility: { kind: 'Private' },\r\n                            mutability: { kind: 'Immutable' },\r\n                            isExported: false\r\n                        };\r\n                        this.validateStructType(typeNode.getStruct()!, tempSymbol);\r\n                        break;\r\n\r\n                    case 'enum':\r\n                        const tempSymbol2: Symbol = {\r\n                            id: -1,\r\n                            name: '<enum-validation>',\r\n                            kind: SymbolKind.Definition,\r\n                            type: typeNode,\r\n                            scope: this.config.services.scopeManager.getCurrentScope().id,\r\n                            contextSpan: typeNode.span,\r\n                            declared: true,\r\n                            initialized: true,\r\n                            used: false,\r\n                            isTypeChecked: false,\r\n                            visibility: { kind: 'Private' },\r\n                            mutability: { kind: 'Immutable' },\r\n                            isExported: false\r\n                        };\r\n                        this.validateEnumType(typeNode.getEnum()!, tempSymbol2);\r\n                        break;\r\n\r\n                    case 'array':\r\n                        const arr = typeNode.getArray()!;\r\n                        this.resolveTypeNode(arr.target);\r\n                        if (arr.size) {\r\n                            this.validateArraySize(arr.size);\r\n                        }\r\n                        break;\r\n\r\n                    case 'optional':\r\n                        this.resolveTypeNode(typeNode.getOptional()!.target);\r\n                        break;\r\n\r\n                    case 'pointer':\r\n                        this.resolveTypeNode(typeNode.getPointer()!.target);\r\n                        break;\r\n\r\n                    case 'paren':\r\n                        this.resolveTypeNode(typeNode.getParen()!.type);\r\n                        break;\r\n\r\n                    case 'tuple':\r\n                        for (const field of typeNode.getTuple()!.fields) {\r\n                            this.resolveTypeNode(field);\r\n                        }\r\n                        break;\r\n\r\n                    case 'primitive': {\r\n                        // special case i/u width must be from 0 to 65535\r\n                        const src = typeNode.getPrimitive()!;\r\n\r\n                        if(src.isSigned() || src.isUnsigned()) {\r\n                            const width = src.width!;\r\n                            if(width < 0 || width > 65535) {\r\n                                this.reportError(DiagCode.INVALID_TYPE_WIDTH, `Type width must be from 0 to 65535`, typeNode.span);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            private isTypeExpression(expr: AST.ExprNode): boolean {\r\n                if (expr.kind === 'Primary') {\r\n                    const primary = expr.getPrimary();\r\n                    if (!primary) return false;\r\n\r\n                    // Check for Object FIRST before Type\r\n                    // Constructors are Objects with an ident: Point { x: 0 }\r\n                    if (primary.kind === 'Object') {\r\n                        const obj = primary.getObject();\r\n                        // If it has an ident, it's a constructor, NOT a type expression\r\n                        if (obj && obj.ident) {\r\n                            return false; // This is Point { x: 0 }, not a type\r\n                        }\r\n                        // If no ident, it's an anonymous object literal, also not a type\r\n                        return false;\r\n                    }\r\n\r\n                    // Direct type expression: return i32, return struct{}, etc.\r\n                    if (primary.kind === 'Type') {\r\n                        return true;\r\n                    }\r\n\r\n                    // Check if it's an identifier that refers to a type definition\r\n                    if (primary.kind === 'Ident') {\r\n                        const ident = primary.getIdent();\r\n                        if (!ident) return false;\r\n\r\n                        // Look up the symbol to check if it's a type definition\r\n                        const symbol = this.config.services.scopeManager.lookupSymbol(ident.name);\r\n                        if (symbol && symbol.kind === SymbolKind.Definition) {\r\n                            // It's a type definition (like returning `Point` instead of an instance)\r\n                            return true;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                return false;\r\n            }\r\n\r\n            private isTypeType(typeNode: AST.TypeNode): boolean {\r\n                if (!typeNode.isPrimitive()) return false;\r\n                const prim = typeNode.getPrimitive();\r\n                return prim?.kind === 'type';\r\n            }\r\n\r\n            // ===== PRIMARY OPERATIONS =====\r\n\r\n            private inferPrimaryType(primary: AST.PrimaryNode): AST.TypeNode | null {\r\n                switch (primary.kind) {\r\n                    case 'Literal':\r\n                        return this.inferLiteralType(primary.getLiteral()!);\r\n                    case 'Ident':\r\n                        return this.inferIdentifierType(primary.getIdent()!);\r\n                    case 'Paren':\r\n                        const paren = primary.getParen()!;\r\n                        return paren.source ? this.inferExpressionType(paren.source) : null;\r\n                    case 'Tuple':\r\n                        return this.inferTupleType(primary.getTuple()!);\r\n                    case 'Object':\r\n                        return this.inferObjectType(primary.getObject()!);\r\n                    case 'Type':\r\n                        return primary.getType();\r\n                    default:\r\n                        return null;\r\n                }\r\n            }\r\n\r\n            private inferLiteralType(literal: AST.LiteralNode): AST.TypeNode {\r\n                switch (literal.kind) {\r\n                    case 'String':\r\n                        const str = literal.value as string;\r\n                        const sizeExpr = AST.ExprNode.asInteger(literal.span, str.length);\r\n                        return AST.TypeNode.asArray(literal.span, AST.TypeNode.asUnsigned(literal.span, 'u8', 8), sizeExpr);\r\n\r\n                    case 'Integer':\r\n                        return AST.TypeNode.asComptimeInt(literal.span, literal.value as string);\r\n\r\n                    case 'Float':\r\n                        return AST.TypeNode.asComptimeFloat(literal.span, literal.value as string);\r\n\r\n                    case 'Character': {\r\n                        const charValue = literal.value as string;\r\n\r\n                        // Empty character literal - check context\r\n                        if (charValue.length === 0) {\r\n                            // Try to get expected type from context\r\n                            const expectedType = this.currentFunctionReturnType ||\r\n                                            this.getExpectedTypeFromContext();\r\n\r\n                            if (expectedType) {\r\n                                // Resolve identifier types to actual types\r\n                                const resolvedType = this.resolveIdentifierType(expectedType);\r\n\r\n                                // Check if context expects cpoint(u21)\r\n                                if (resolvedType.isUnsigned() && resolvedType.getWidth() === 21) {\r\n                                    return AST.TypeNode.asUnsigned(literal.span, 'u21', 21);\r\n                                }\r\n                                // Check if context expects char(u8)\r\n                                if (resolvedType.isUnsigned() && resolvedType.getWidth() === 8) {\r\n                                    return AST.TypeNode.asUnsigned(literal.span, 'u8', 8);\r\n                                }\r\n                            }\r\n\r\n                            // Default to char(u8) for empty literals\r\n                            return AST.TypeNode.asUnsigned(literal.span, 'u8', 8);\r\n                        }\r\n\r\n                        // Get Unicode code point\r\n                        const codePoint = charValue.codePointAt(0) || 0;\r\n\r\n                        // Non-ASCII (> 127) = cpoint(u21)\r\n                        if (codePoint > 127) {\r\n                            return AST.TypeNode.asUnsigned(literal.span, 'u21', 21);\r\n                        }\r\n\r\n                        // ASCII (≤ 127) = char(u8)\r\n                        return AST.TypeNode.asUnsigned(literal.span, 'u8', 8);\r\n                    }\r\n\r\n                    case 'Bool':\r\n                        return AST.TypeNode.asBool(literal.span);\r\n\r\n                    case 'Null':\r\n                        return AST.TypeNode.asNull(literal.span);\r\n\r\n                    case 'Undefined':\r\n                        return AST.TypeNode.asUndefined(literal.span);\r\n\r\n                    case 'Array':\r\n                        return this.inferArrayLiteralType(literal);\r\n\r\n                    default:\r\n                        return AST.TypeNode.asUndefined(literal.span);\r\n                }\r\n            }\r\n\r\n            private getExpectedTypeFromContext(): AST.TypeNode | null {\r\n                // Check if we're in a variable initialization\r\n                const currentDecl = this.config.services.contextTracker.getCurrentDeclaration();\r\n                if (currentDecl) {\r\n                    const symbol = this.config.services.scopeManager.getSymbol(currentDecl.symbolId);\r\n                    if (symbol && symbol.type) {\r\n                        // Resolve type aliases (char -> u8, cpoint -> u21)\r\n                        return this.resolveIdentifierType(symbol.type);\r\n                    }\r\n                }\r\n\r\n                // Check if we're in a parameter initialization\r\n                const exprContext = this.config.services.contextTracker.getCurrentExpressionContext();\r\n                if (exprContext && exprContext.relatedSymbol !== undefined) {\r\n                    const symbol = this.config.services.scopeManager.getSymbol(exprContext.relatedSymbol);\r\n                    if (symbol && symbol.type) {\r\n                        // Resolve type aliases (char -> u8, cpoint -> u21)\r\n                        return this.resolveIdentifierType(symbol.type);\r\n                    }\r\n                }\r\n\r\n                return null;\r\n            }\r\n\r\n            private inferArrayLiteralType(literal: AST.LiteralNode): AST.TypeNode {\r\n                const elements = literal.value as AST.ExprNode[];\r\n\r\n                if (elements.length === 0) {\r\n                    const sizeExpr = AST.ExprNode.asInteger(literal.span, 0);\r\n                    return AST.TypeNode.asArray(literal.span, AST.TypeNode.asUndefined(literal.span), sizeExpr);\r\n                }\r\n\r\n                const firstType = this.inferExpressionType(elements[0]);\r\n                if (!firstType) {\r\n                    const sizeExpr = AST.ExprNode.asInteger(literal.span, elements.length);\r\n                    return AST.TypeNode.asArray(literal.span, AST.TypeNode.asUndefined(literal.span), sizeExpr);\r\n                }\r\n\r\n                // Validate subsequent elements against first element's type\r\n                for (let i = 1; i < elements.length; i++) {\r\n                    // Unified validation for array elements\r\n                    if (!this.validateTypeAssignment(elements[i], firstType, `Array element ${i}`)) {\r\n                        // Error already reported, but continue checking other elements\r\n                    }\r\n\r\n                    const elemType = this.inferExpressionType(elements[i]);\r\n                    if (!elemType || !this.isTypeCompatible(firstType, elemType)) {\r\n                        this.reportError(\r\n                            DiagCode.TYPE_MISMATCH,\r\n                            'Array elements have incompatible types',\r\n                            elements[i].span\r\n                        );\r\n                    }\r\n                }\r\n\r\n                const sizeExpr = AST.ExprNode.asInteger(literal.span, elements.length);\r\n                return AST.TypeNode.asArray(literal.span, firstType, sizeExpr);\r\n            }\r\n\r\n            private inferIdentifierType(ident: AST.IdentNode): AST.TypeNode | null {\r\n                // Handle 'self' - distinguish static vs instance context\r\n                if (ident.name === 'self') {\r\n                    // // In static methods, using 'self' alone is an error\r\n                    // if (this.currentIsStaticMethod && this.currentStructScope) {\r\n                    //     this.reportError(\r\n                    //         DiagCode.INVALID_STATIC_ACCESS,\r\n                    //         `Cannot use 'self' in static method. Use '${this.currentStructScope.name}' to access static members.`,\r\n                    //         ident.span\r\n                    //     );\r\n                    //     return null;\r\n                    // }\r\n\r\n                    // In instance methods, 'self' refers to the instance\r\n                    const selfSymbol = this.config.services.scopeManager.lookupSymbol('self');\r\n                    if (selfSymbol && selfSymbol.metadata?.isSelf) {\r\n                        selfSymbol.used = true; // Mark as used to prevent false warning\r\n                        return selfSymbol.type;\r\n                    }\r\n                }\r\n\r\n                // SECOND: Check direct field access in static method (without self)\r\n                if (this.currentIsStaticMethod && this.currentStructScope) {\r\n                    const fieldSymbol = this.currentStructScope.symbols.get(ident.name);\r\n\r\n                    if (fieldSymbol) {\r\n                        // Check if it's a struct field OR method\r\n                        if (fieldSymbol.kind === SymbolKind.StructField ||\r\n                            fieldSymbol.kind === SymbolKind.Function) {\r\n\r\n                            const isStatic = fieldSymbol.visibility.kind === 'Static';\r\n\r\n                            if (!isStatic) {\r\n                                const memberType = fieldSymbol.kind === SymbolKind.Function ? 'method' : 'field';\r\n                                this.reportError(\r\n                                    DiagCode.INVALID_STATIC_ACCESS,\r\n                                    `Cannot access instance ${memberType} '${ident.name}' in static method. Static methods can only access static ${memberType}s.`,\r\n                                    ident.span\r\n                                );\r\n                                return null;  // Stop processing and don't mark as used/resolved\r\n                            }\r\n\r\n                            // Valid static member - mark as used and continue\r\n                            fieldSymbol.used = true;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                const symbol = this.config.services.scopeManager.lookupSymbol(ident.name);\r\n                if (!symbol) return null;\r\n\r\n                // Handle regular 'self' in instance methods\r\n                if (ident.name === 'self' && symbol.metadata?.isSelf) {\r\n                    symbol.used = true;\r\n                    return symbol.type;\r\n                }\r\n\r\n                // If this is a type definition (like slice, char, cpoint), return 'type' primitive\r\n                if (symbol.kind === SymbolKind.Definition && symbol.type?.isType()) {\r\n                    return AST.TypeNode.asPrimitive(ident.span, 'type');\r\n                }\r\n\r\n                if (symbol.type) return symbol.type;\r\n\r\n                if (symbol.kind === SymbolKind.Function && symbol.metadata) {\r\n                    const metadata = symbol.metadata as any;\r\n\r\n                    const paramTypes: AST.TypeNode[] = [];\r\n                    if (metadata.params && Array.isArray(metadata.params)) {\r\n                        for (const param of metadata.params) {\r\n                            if (param.type) {\r\n                                paramTypes.push(param.type);\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    const returnType = metadata.returnType || null;\r\n\r\n                    const funcType = AST.TypeNode.asFunction(\r\n                        symbol.contextSpan || ident.span,\r\n                        paramTypes,\r\n                        returnType\r\n                    );\r\n\r\n                    symbol.type = funcType;\r\n                    return funcType;\r\n                }\r\n\r\n                return null;\r\n            }\r\n\r\n            private validateMethodCallContext(\r\n                call: AST.CallNode,\r\n                methodSymbol: Symbol,\r\n                isStaticAccess: boolean,\r\n                baseExpr: AST.ExprNode\r\n            ): void {\r\n                const isStaticMethod = methodSymbol.visibility.kind === 'Static';\r\n\r\n                // CASE 1: Calling instance method on TYPE (Error)\r\n                if (isStaticAccess && !isStaticMethod) {\r\n                    this.reportError(\r\n                        DiagCode.INVALID_STATIC_ACCESS,\r\n                        `Cannot call instance method '${methodSymbol.name}' on type. Create an instance first.`,\r\n                        call.span\r\n                    );\r\n                    return;\r\n                }\r\n\r\n                // CASE 2: Static calling instance via Type.method() - ADD THIS CHECK\r\n                if (isStaticAccess && isStaticMethod) {\r\n                    // Check if we're in a static method context\r\n                    if (this.currentIsStaticMethod) {\r\n                        // Verify the called method is also static\r\n                        // (already checked above, but this prevents static->instance calls)\r\n                    }\r\n                }\r\n            }\r\n\r\n            private inferObjectType(obj: AST.ObjectNode): AST.TypeNode | null {\r\n                // CASE 1: Named constructor (MyStruct { ... })\r\n                if (obj.ident) {\r\n                    const typeSymbol = this.config.services.scopeManager.lookupSymbol(obj.ident.name);\r\n\r\n                    if (!typeSymbol) {\r\n                        this.reportError(\r\n                            DiagCode.UNDEFINED_IDENTIFIER,\r\n                            `Type '${obj.ident.name}' not found`,\r\n                            obj.span\r\n                        );\r\n                        return null;\r\n                    }\r\n\r\n                    if (!typeSymbol.type) {\r\n                        this.reportError(\r\n                            DiagCode.SYMBOL_NOT_FOUND,\r\n                            `Symbol '${obj.ident.name}' has no type`,\r\n                            obj.span\r\n                        );\r\n                        return null;\r\n                    }\r\n\r\n                    let actualType = typeSymbol.type;\r\n                    if (actualType.isIdent()) {\r\n                        const typeIdent = actualType.getIdent()!;\r\n                        const resolvedSymbol = this.config.services.scopeManager.lookupSymbol(typeIdent.name);\r\n                        if (resolvedSymbol && resolvedSymbol.type) {\r\n                            actualType = resolvedSymbol.type;\r\n                        }\r\n                    }\r\n\r\n                    if (actualType.isStruct()) {\r\n                        this.validateStructConstruction(obj, actualType, obj.span);\r\n                        return typeSymbol.type;\r\n                    } else {\r\n                        this.reportError(\r\n                            DiagCode.TYPE_MISMATCH,\r\n                            `'${obj.ident.name}' is not a struct type`,\r\n                            obj.span\r\n                        );\r\n                        return null;\r\n                    }\r\n                }\r\n\r\n                // CASE 2: Anonymous object literal\r\n                // NEW: Check if we're in an assignment/initialization context with an expected type\r\n                const expectedType = this.getExpectedTypeFromContext();\r\n\r\n                if (expectedType) {\r\n                    const resolvedExpected = this.resolveIdentifierType(expectedType);\r\n\r\n                    // If expected type is a union, check if any member is a matching struct\r\n                    if (resolvedExpected.isUnion()) {\r\n                        const unionType = resolvedExpected.getUnion()!;\r\n\r\n                        for (const memberType of unionType.types) {\r\n                            const resolvedMember = this.resolveIdentifierType(memberType);\r\n\r\n                            if (resolvedMember.isStruct()) {\r\n                                const struct = resolvedMember.getStruct()!;\r\n\r\n                                // Check if object literal matches this struct's shape\r\n                                if (this.doesObjectMatchStruct(obj, struct)) {\r\n                                    // Return the union member type, not a new anonymous struct\r\n                                    return memberType;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    // If expected type is directly a struct\r\n                    if (resolvedExpected.isStruct()) {\r\n                        const struct = resolvedExpected.getStruct()!;\r\n\r\n                        if (this.doesObjectMatchStruct(obj, struct)) {\r\n                            return expectedType;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // Fall back to creating anonymous struct (existing code)\r\n                const fields: AST.TypeNode[] = [];\r\n                const fieldNodes: AST.FieldNode[] = [];\r\n\r\n                for (const prop of obj.props) {\r\n                    const fieldType = prop.val\r\n                        ? this.inferExpressionType(prop.val)\r\n                        : AST.TypeNode.asUndefined(prop.key.span);\r\n\r\n                    if (!fieldType) {\r\n                        this.reportError(\r\n                            DiagCode.CANNOT_INFER_TYPE,\r\n                            `Cannot infer type for property '${prop.key.name}'`,\r\n                            prop.key.span\r\n                        );\r\n                        return null;\r\n                    }\r\n\r\n                    fields.push(fieldType);\r\n\r\n                    const fieldNode = AST.FieldNode.create(\r\n                        prop.key.span,\r\n                        { kind: 'Private' },\r\n                        { kind: 'Runtime' },\r\n                        { kind: 'Immutable' },\r\n                        prop.key,\r\n                        fieldType,\r\n                        prop.val || undefined\r\n                    );\r\n                    fieldNodes.push(fieldNode);\r\n                }\r\n\r\n                const members = fieldNodes.map(f => AST.StructMemberNode.createField(f.span, f));\r\n                return AST.TypeNode.asStruct(obj.span, members, 'Anonymous');\r\n            }\r\n\r\n            // Helper method to check if object literal matches struct shape\r\n            private doesObjectMatchStruct(obj: AST.ObjectNode, struct: AST.StructTypeNode): boolean {\r\n                const structFields = new Map<string, AST.FieldNode>();\r\n\r\n                for (const member of struct.members) {\r\n                    if (member.isField()) {\r\n                        const field = member.source as AST.FieldNode;\r\n                        structFields.set(field.ident.name, field);\r\n                    }\r\n                }\r\n\r\n                // Check if object has same fields (ignoring order)\r\n                if (obj.props.length !== structFields.size) {\r\n                    return false;\r\n                }\r\n\r\n                for (const prop of obj.props) {\r\n                    const structField = structFields.get(prop.key.name);\r\n\r\n                    if (!structField) {\r\n                        return false; // Object has field not in struct\r\n                    }\r\n\r\n                    // Could add type compatibility check here if needed\r\n                    if (prop.val && structField.type) {\r\n                        const propType = this.inferExpressionType(prop.val);\r\n                        if (propType && !this.isTypeCompatible(structField.type, propType)) {\r\n                            return false;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                return true;\r\n            }\r\n\r\n            private inferTupleType(tuple: AST.ExprTupleNode): AST.TypeNode | null {\r\n                const fieldTypes: AST.TypeNode[] = [];\r\n\r\n                for (const field of tuple.fields) {\r\n                    const fieldType = this.inferExpressionType(field);\r\n                    if (!fieldType) return null;\r\n                    fieldTypes.push(fieldType);\r\n                }\r\n\r\n                return AST.TypeNode.asTuple(tuple.span, fieldTypes);\r\n            }\r\n\r\n            // ===== BINARY OPERATIONS =====\r\n\r\n            private getExpressionMutability(expr: AST.ExprNode): 'Mutable' | 'Immutable' | 'Literal' | 'Unset' {\r\n            // For identifiers, look up the symbol\r\n                if (expr.is('Primary')) {\r\n                    const primary = expr.getPrimary();\r\n                    if (primary?.is('Ident')) {\r\n                        const ident = primary.getIdent();\r\n                        if (ident) {\r\n                            const symbol = this.config.services.scopeManager.lookupSymbol(ident.name);\r\n                            if (symbol) {\r\n\r\n                                // [] mut u8\r\n                                if(symbol.type?.isArray()) {\r\n                                    return symbol.type?.getArray()?.mutable ? 'Mutable' : 'Immutable';\r\n                                }\r\n\r\n                                // let mut ..\r\n                                // return symbol.mutability.kind;\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    // String literals - special case (compatible with both)\r\n                    if (primary?.is('Literal')) {\r\n                        const literal = primary.getLiteral();\r\n                        if (literal?.kind === 'String') {\r\n                            return 'Literal';  // Changed from 'Immutable'\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // For binary expressions (chained concatenation)\r\n                if (expr.is('Binary')) {\r\n                    const binary = expr.getBinary()!;\r\n                    if (binary.kind === 'Additive' && binary.operator === '+') {\r\n                        const leftMut = this.getExpressionMutability(binary.left);\r\n                        const rightMut = this.getExpressionMutability(binary.right);\r\n\r\n                        // Ignore literals - they're compatible with everything\r\n                        if (leftMut === 'Literal') return rightMut;\r\n                        if (rightMut === 'Literal') return leftMut;\r\n\r\n                        // If mixing mutable and immutable variables, that's an error\r\n                        if ((leftMut === 'Mutable') !== (rightMut === 'Mutable')) {\r\n                            return 'Unset'; // Signal incompatibility\r\n                        }\r\n\r\n                        // Both same mutability\r\n                        return leftMut;\r\n                    }\r\n                }\r\n\r\n                // For member access (obj.field), check the field's mutability\r\n                if (expr.is('Postfix')) {\r\n                    const postfix = expr.getPostfix();\r\n                    if (postfix?.kind === 'MemberAccess') {\r\n                        const access = postfix.getMemberAccess()!;\r\n                        const memberName = this.extractMemberName(access.target);\r\n\r\n                        if (memberName) {\r\n                            const baseType = this.inferExpressionType(access.base);\r\n                            if (baseType) {\r\n                                const resolvedBase = this.resolveIdentifierType(baseType);\r\n                                if (resolvedBase.isStruct()) {\r\n                                    const struct = resolvedBase.getStruct()!;\r\n                                    const scopeId = struct.metadata?.scopeId as number | undefined;\r\n\r\n                                    if (scopeId !== undefined) {\r\n                                        const structScope = this.config.services.scopeManager.getScope(scopeId);\r\n                                        const fieldSymbol = structScope.symbols.get(memberName);\r\n\r\n                                        if (fieldSymbol) {\r\n                                            return fieldSymbol.mutability.kind;\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // Cannot determine mutability - assume immutable (safest default)\r\n                return 'Immutable';\r\n            }\r\n\r\n            private inferBinaryType(binary: AST.BinaryNode): AST.TypeNode | null {\r\n                if (!binary.left || !binary.right) return null;\r\n\r\n                // Handle Assignment FIRST, before inferring operand types\r\n                if (binary.kind === 'Assignment') {\r\n                    this.validateAssignment(binary);\r\n\r\n                    // Assignment expression evaluates to the right-hand side value\r\n                    return this.inferExpressionType(binary.right);\r\n                }\r\n\r\n                const leftType = this.inferExpressionType(binary.left);\r\n                const rightType = this.inferExpressionType(binary.right);\r\n\r\n                if (!leftType || !rightType) return null;\r\n\r\n                // Reject 'type' in arithmetic\r\n                if (this.isTypeType(leftType) || this.isTypeType(rightType)) {\r\n                    this.reportError(\r\n                        DiagCode.TYPE_MISMATCH,\r\n                        `Cannot perform ${binary.kind} operation on type values`,\r\n                        binary.span\r\n                    );\r\n                    return null;\r\n                }\r\n\r\n                // slice/u8Array\r\n                if(binary.kind === 'Additive' && binary.operator === '+') {\r\n                    // Resolve both types to their base forms (slice -> []u8)\r\n                    const resolvedLeft = this.resolveIdentifierType(leftType);\r\n                    const resolvedRight = this.resolveIdentifierType(rightType);\r\n\r\n                    const leftIsString = this.isStringType(resolvedLeft);\r\n                    const rightIsString = this.isStringType(resolvedRight);\r\n\r\n                    if (leftIsString && rightIsString) {\r\n                        const leftMutability = this.getExpressionMutability(binary.left);\r\n                        const rightMutability = this.getExpressionMutability(binary.right);\r\n\r\n                        // Ignore literals - they're compatible with everything\r\n                        const leftEffective = leftMutability === 'Literal' ? null : leftMutability;\r\n                        const rightEffective = rightMutability === 'Literal' ? null : rightMutability;\r\n\r\n                        // If both are non-literals, they must match\r\n                        if (leftEffective !== null && rightEffective !== null) {\r\n                            if (leftEffective !== rightEffective) {\r\n                                this.reportError(\r\n                                    DiagCode.MUTABILITY_MISMATCH,\r\n                                    `Cannot concatenate arrays with different mutability`,\r\n                                    binary.span\r\n                                );\r\n                                return null;\r\n                            }\r\n                        }\r\n\r\n                        return leftType;\r\n                    }\r\n\r\n                    // Reject: mixing strings with non-strings\r\n                    if (leftIsString || rightIsString) {\r\n                        this.reportError(\r\n                            DiagCode.TYPE_MISMATCH,\r\n                            `Cannot concatenate string with non-string type`,\r\n                            binary.span\r\n                        );\r\n                        return null;\r\n                    }\r\n\r\n                    // If neither is string, fall through to numeric check below\r\n                }\r\n\r\n                switch (binary.kind) {\r\n                    case 'Additive':\r\n                    case 'Multiplicative':\r\n                    case 'Power':\r\n                        // Validate operands are numeric\r\n                        if (!this.isNumericType(leftType) || !this.isNumericType(rightType)) {\r\n                            this.reportError(\r\n                                DiagCode.TYPE_MISMATCH,\r\n                                `Cannot perform ${binary.kind} operation on non-numeric types '${this.getTypeDisplayName(leftType)}' and '${this.getTypeDisplayName(rightType)}'`,\r\n                                binary.span\r\n                            );\r\n                            return null;\r\n                        }\r\n                        return this.promoteNumericTypes(leftType, rightType, binary.span);\r\n\r\n                    case 'Shift':\r\n                    case 'BitwiseAnd':\r\n                    case 'BitwiseXor':\r\n                    case 'BitwiseOr':\r\n                        // Validate operands are integers\r\n                        if (!this.isIntegerType(leftType) || !this.isIntegerType(rightType)) {\r\n                            this.reportError(\r\n                                DiagCode.TYPE_MISMATCH,\r\n                                `Bitwise operations require integer types, got '${this.getTypeDisplayName(leftType)}' and '${this.getTypeDisplayName(rightType)}'`,\r\n                                binary.span\r\n                            );\r\n                            return null;\r\n                        }\r\n                        return this.promoteNumericTypes(leftType, rightType, binary.span);\r\n\r\n                    case 'Equality':\r\n                    case 'Relational':\r\n                        // NEW: Validate null comparison with non-optional types\r\n                        // Allow: optional types, null itself, and POINTERS to be compared with null\r\n                        if (leftType.isNull() && !rightType.isOptional() && !rightType.isNull() && !rightType.isPointer()) {\r\n                            this.reportError(\r\n                                DiagCode.TYPE_MISMATCH,\r\n                                `Cannot compare non-optional type '${this.getTypeDisplayName(rightType)}' with null`,\r\n                                binary.right.span\r\n                            );\r\n                        } else if (rightType.isNull() && !leftType.isOptional() && !leftType.isNull() && !leftType.isPointer()) {\r\n                            this.reportError(\r\n                                DiagCode.TYPE_MISMATCH,\r\n                                `Cannot compare non-optional type '${this.getTypeDisplayName(leftType)}' with null`,\r\n                                binary.left.span\r\n                            );\r\n                        }\r\n                        return AST.TypeNode.asBool(binary.span);\r\n\r\n                    case 'LogicalAnd':\r\n                    case 'LogicalOr':\r\n                        return AST.TypeNode.asBool(binary.span);\r\n\r\n                    default:\r\n                        return null;\r\n                }\r\n            }\r\n\r\n            private validateAssignment(binary: AST.BinaryNode): void {\r\n                if (binary.kind !== 'Assignment') return;\r\n\r\n                this.stats.assignmentsValidated++;\r\n\r\n                // Check for assignment through immutable pointer dereference\r\n                if (binary.left.is('Postfix')) {\r\n                    const postfix = binary.left.getPostfix();\r\n                    if (postfix?.kind === 'Dereference') {\r\n                        const ptrExpr = postfix.getAsExprNode()!;\r\n                        const ptrType = this.inferExpressionType(ptrExpr);\r\n\r\n                        if (ptrType) {\r\n                            const normalizedPtrType = this.normalizeType(ptrType);\r\n\r\n                            if (normalizedPtrType.isPointer()) {\r\n                                const ptr = normalizedPtrType.getPointer()!;\r\n\r\n                                if (!ptr.mutable) {\r\n                                    this.reportError(\r\n                                        DiagCode.MUTABILITY_MISMATCH,\r\n                                        `Cannot assign through immutable pointer. Declare as '*mut T' to allow mutation`,\r\n                                        binary.left.span\r\n                                    );\r\n                                    return;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                const leftSymbol = this.extractSymbolFromExpression(binary.left);\r\n\r\n                if (leftSymbol) {\r\n                    // Check if trying to assign to static field\r\n                    if (leftSymbol.kind === SymbolKind.StructField &&\r\n                        leftSymbol.visibility.kind === 'Static') {\r\n                        this.reportError(\r\n                            DiagCode.MUTABILITY_MISMATCH,\r\n                            `Cannot assign to static field '${leftSymbol.name}'. Static fields are immutable.`,\r\n                            binary.left.span\r\n                        );\r\n                        return;\r\n                    }\r\n\r\n                    // Check if the LEFT SIDE SYMBOL is immutable\r\n                    if (leftSymbol.mutability.kind === 'Immutable') {\r\n                        let symbolType = 'variable';\r\n                        if (leftSymbol.kind === SymbolKind.Parameter) {\r\n                            symbolType = 'parameter';\r\n                        } else if (leftSymbol.kind === SymbolKind.StructField) {\r\n                            symbolType = 'field';\r\n                        }\r\n\r\n                        this.reportError(\r\n                            DiagCode.MUTABILITY_MISMATCH,\r\n                            `Cannot assign to immutable ${symbolType} '${leftSymbol.name}'`,\r\n                            binary.left.span\r\n                        );\r\n                        return;\r\n                    }\r\n                }\r\n\r\n                // Type compatibility check\r\n                const leftType = this.inferExpressionType(binary.left);\r\n                const rightType = this.inferExpressionType(binary.right);\r\n\r\n                // PASS SOURCE EXPRESSION for strict pointer checking\r\n                if (leftType && rightType && !this.isTypeCompatible(leftType, rightType, binary.right)) {\r\n                    this.reportError(\r\n                        DiagCode.TYPE_MISMATCH,\r\n                        `Cannot assign type '${this.getTypeDisplayName(rightType)}' to '${this.getTypeDisplayName(leftType)}'`,\r\n                        binary.right.span\r\n                    );\r\n                }\r\n\r\n                // Check for overflow\r\n                if (leftType) {\r\n                    this.validateValueFitsInType(binary.right, leftType);\r\n                }\r\n            }\r\n\r\n            // ===== PREFIX OPERATIONS =====\r\n\r\n            private inferPrefixType(prefix: AST.PrefixNode): AST.TypeNode | null {\r\n                const exprType = this.inferExpressionType(prefix.expr);\r\n                if (!exprType) return null;\r\n\r\n                switch (prefix.kind) {\r\n                    case 'UnaryPlus':\r\n                    case 'UnaryMinus':\r\n                        if (!this.isNumericType(exprType)) {\r\n                            this.reportError(\r\n                                DiagCode.TYPE_MISMATCH,\r\n                                `Unary '${prefix.kind === 'UnaryMinus' ? '-' : '+'}' requires a numeric operand, got '${this.getTypeDisplayName(exprType)}'`,\r\n                                prefix.expr.span\r\n                            );\r\n                            return null;\r\n                        }\r\n                        return this.computeUnaryResultType(exprType, prefix.kind === 'UnaryMinus', prefix.span);\r\n\r\n                    case 'Increment':\r\n                    case 'Decrement':\r\n                        if (!this.isNumericType(exprType)) {\r\n                            this.reportError(\r\n                                DiagCode.TYPE_MISMATCH,\r\n                                `${prefix.kind} requires a numeric operand`,\r\n                                prefix.expr.span\r\n                            );\r\n                            return null;\r\n                        }\r\n                        return exprType;\r\n\r\n                    case 'LogicalNot':\r\n                        return AST.TypeNode.asBool(prefix.span);\r\n\r\n                    case 'BitwiseNot':\r\n                        if (!this.isIntegerType(exprType)) {\r\n                            this.reportError(\r\n                                DiagCode.TYPE_MISMATCH,\r\n                                `Bitwise not requires integer type, got '${this.getTypeDisplayName(exprType)}'`,\r\n                                prefix.expr.span\r\n                            );\r\n                            return null;\r\n                        }\r\n                        return exprType;\r\n\r\n                    case 'Reference':\r\n                        // Check if expression is an lvalue before taking reference\r\n                        if (!this.isLValueExpression(prefix.expr)) {\r\n                            this.reportError(\r\n                                DiagCode.TYPE_MISMATCH,\r\n                                `Cannot take reference of non-lvalue expression`,\r\n                                prefix.expr.span\r\n                            );\r\n                            return null; // Stop type inference\r\n                        }\r\n\r\n                        let isMutablePointer = false;\r\n                        let resolvedType = exprType;\r\n\r\n                        // Extract the symbol being referenced\r\n                        if (prefix.expr.is('Primary')) {\r\n                            const primary = prefix.expr.getPrimary();\r\n                            if (primary?.is('Ident')) {\r\n                                const ident = primary.getIdent();\r\n                                if (ident) {\r\n                                    const symbol = this.config.services.scopeManager.lookupSymbol(ident.name);\r\n\r\n                                    if (symbol && symbol.mutability.kind === 'Mutable') {\r\n                                        isMutablePointer = true;\r\n                                    }\r\n\r\n                                    if (symbol && symbol.type) {\r\n                                        resolvedType = symbol.type;\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                        const normalizedType = this.normalizeType(resolvedType);\r\n                        return AST.TypeNode.asPointer(prefix.span, normalizedType, isMutablePointer);\r\n\r\n                    default:\r\n                        return null;\r\n                }\r\n            }\r\n\r\n            private isLValueExpression(expr: AST.ExprNode): boolean {\r\n                switch (expr.kind) {\r\n                    case 'Primary': {\r\n                        const primary = expr.getPrimary()!;\r\n\r\n                        switch (primary.kind) {\r\n                            case 'Ident':\r\n                                // Variables are lvalues\r\n                                return true;\r\n\r\n                            case 'Literal':\r\n                                // Literals are NOT lvalues\r\n                                return false;\r\n\r\n                            case 'Paren': {\r\n                                // Check the inner expression\r\n                                const paren = primary.getParen()!;\r\n                                return paren.source ? this.isLValueExpression(paren.source) : false;\r\n                            }\r\n\r\n                            default:\r\n                                // Tuples, objects, types are not lvalues\r\n                                return false;\r\n                        }\r\n                    }\r\n\r\n                    case 'Postfix': {\r\n                        const postfix = expr.getPostfix()!;\r\n\r\n                        switch (postfix.kind) {\r\n                            case 'Dereference':\r\n                                // ptr.* is an lvalue (points to memory)\r\n                                return true;\r\n\r\n                            case 'ArrayAccess':\r\n                                // arr[i] is an lvalue (array element has memory)\r\n                                return true;\r\n\r\n                            case 'MemberAccess':\r\n                                // obj.field is an lvalue (field has memory)\r\n                                return true;\r\n\r\n                            case 'Call':\r\n                                // Function calls are NOT lvalues (return temporary values)\r\n                                return false;\r\n\r\n                            case 'Increment':\r\n                            case 'Decrement':\r\n                                // Post-increment/decrement return the OLD value (temporary)\r\n                                return false;\r\n\r\n                            default:\r\n                                return false;\r\n                        }\r\n                    }\r\n\r\n                    case 'Prefix': {\r\n                        const prefix = expr.getPrefix()!;\r\n\r\n                        switch (prefix.kind) {\r\n                            case 'Reference':\r\n                                // &ptr is an lvalue\r\n                                return true;\r\n\r\n                            case 'Increment':\r\n                            case 'Decrement':\r\n                                // Pre-increment/decrement modify and return the lvalue\r\n                                return this.isLValueExpression(prefix.expr);\r\n\r\n                            default:\r\n                                // Unary +, -, !, ~ return temporary values\r\n                                return false;\r\n                        }\r\n                    }\r\n\r\n                    case 'Binary':\r\n                    case 'As':\r\n                    case 'Orelse':\r\n                    case 'Range':\r\n                    case 'Try':\r\n                    case 'Catch':\r\n                    case 'If':\r\n                    case 'Match':\r\n                    case 'Typeof':\r\n                    case 'Sizeof':\r\n                        // All of these return temporary values, not lvalues\r\n                        return false;\r\n\r\n                    default:\r\n                        return false;\r\n                }\r\n            }\r\n\r\n            // ===== POSTFIX OPERATIONS =====\r\n\r\n            private inferPostfixType(postfix: AST.PostfixNode): AST.TypeNode | null {\r\n                switch (postfix.kind) {\r\n                    case 'Call':\r\n                        return this.inferCallType(postfix.getCall()!);\r\n\r\n                    case 'ArrayAccess':\r\n                        return this.inferArrayAccessType(postfix.getArrayAccess()!);\r\n\r\n                    case 'MemberAccess':\r\n                        return this.inferMemberAccessType(postfix.getMemberAccess()!);\r\n\r\n                    case 'Increment':\r\n                    case 'Decrement':\r\n                        const exprType = this.inferExpressionType(postfix.getAsExprNode()!);\r\n                        if (exprType && !this.isNumericType(exprType)) {\r\n                            this.reportError(\r\n                                DiagCode.TYPE_MISMATCH,\r\n                                `${postfix.kind} requires numeric type`,\r\n                                postfix.span\r\n                            );\r\n                            return null;\r\n                        }\r\n                        return exprType;\r\n\r\n                    case 'Dereference':\r\n                        const ptrType = this.inferExpressionType(postfix.getAsExprNode()!);\r\n\r\n                        if (!ptrType) {\r\n                            this.reportError(\r\n                                DiagCode.TYPE_INFERENCE_FAILED,\r\n                                'Cannot infer type for dereference operation',\r\n                                postfix.span\r\n                            );\r\n                            return null;\r\n                        }\r\n\r\n                        // Unwrap paren types before checking if pointer\r\n                        const unwrappedPtrType = this.unwrapParenType(ptrType);\r\n\r\n                        if (!unwrappedPtrType.isPointer()) {\r\n                            this.reportError(\r\n                                DiagCode.TYPE_MISMATCH,\r\n                                `Cannot dereference non-pointer type '${this.getTypeDisplayName(ptrType)}'`,\r\n                                postfix.span\r\n                            );\r\n                            return null;\r\n                        }\r\n\r\n                        return unwrappedPtrType.getPointer()!.target;\r\n\r\n                    default:\r\n                        return null;\r\n                }\r\n            }\r\n\r\n            private inferCallType(call: AST.CallNode): AST.TypeNode | null {\r\n                this.stats.callsValidated++;\r\n\r\n                // Check builtins FIRST\r\n                if (this.isBuiltinFunction(call.base)) {\r\n                    return this.validateBuiltinCall(call);\r\n                }\r\n\r\n                // Check if this is an enum variant constructor BEFORE checking methods\r\n                if (call.base.is('Postfix')) {\r\n                    const postfix = call.base.getPostfix();\r\n                    if (postfix?.kind === 'MemberAccess') {\r\n                        const access = postfix.getMemberAccess()!;\r\n                        const baseType = this.inferExpressionType(access.base);\r\n\r\n                        if (baseType) {\r\n                            const resolvedBase = this.resolveIdentifierType(baseType);\r\n\r\n                            if (resolvedBase.isEnum()) {\r\n                                return this.validateEnumVariantConstruction(call, access, resolvedBase);\r\n                            }\r\n\r\n                            if (resolvedBase.isStruct()) {\r\n                                const memberName = this.extractMemberName(access.target);\r\n                                if (memberName) {\r\n                                    const struct = resolvedBase.getStruct()!;\r\n                                    const scopeId = struct.metadata?.scopeId as number | undefined;\r\n\r\n                                    if (scopeId !== undefined) {\r\n                                        const structScope = this.config.services.scopeManager.getScope(scopeId);\r\n                                        const methodSymbol = structScope.symbols.get(memberName);\r\n\r\n                                        if (methodSymbol && methodSymbol.kind === SymbolKind.Function) {\r\n                                            const isStaticAccess = this.isStaticMemberAccess(access.base);\r\n                                            this.validateMethodCallContext(call, methodSymbol, isStaticAccess, access.base);\r\n                                            this.validateMemberVisibility(methodSymbol, structScope, access.target.span);\r\n                                        }\r\n                                    }\r\n                                }\r\n\r\n                                return this.validateStructMethodCall(call, access, resolvedBase);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // Regular function call...\r\n                const calleeSymbol = this.findCallTargetSymbol(call.base);\r\n                let calleeType = calleeSymbol ? calleeSymbol.type : this.inferExpressionType(call.base);\r\n\r\n                if (!calleeType) {\r\n                    return null;\r\n                }\r\n\r\n                // RESOLVE IDENTIFIER TYPES (BinaryOp -> fn(i32, i32) -> i32)\r\n                const resolvedCalleeType = this.resolveIdentifierType(calleeType);\r\n\r\n                if (resolvedCalleeType.isFunction()) {\r\n                    return this.validateCallArgumentsWithContext(call, resolvedCalleeType);\r\n                }\r\n\r\n                // Now the error is accurate\r\n                this.reportError(\r\n                    DiagCode.TYPE_MISMATCH,\r\n                    `Cannot call value of non-function type '${this.getTypeDisplayName(calleeType)}'`,\r\n                    call.base.span\r\n                );\r\n                return null;\r\n            }\r\n\r\n            private validateEnumVariantConstruction(\r\n                call: AST.CallNode,\r\n                access: AST.MemberAccessNode,\r\n                enumType: AST.TypeNode\r\n            ): AST.TypeNode | null {\r\n                const variantName = this.extractMemberName(access.target);\r\n                if (!variantName) return null;\r\n\r\n                const enumDef = enumType.getEnum()!;\r\n                const scopeId = enumDef.metadata?.scopeId as number | undefined;\r\n\r\n                if (scopeId === undefined) {\r\n                    this.reportError(\r\n                        DiagCode.INTERNAL_ERROR,\r\n                        `Cannot find scope for enum`,\r\n                        call.span\r\n                    );\r\n                    return null;\r\n                }\r\n\r\n                const enumScope = this.config.services.scopeManager.getScope(scopeId);\r\n                const variantSymbol = enumScope.symbols.get(variantName);\r\n\r\n                if (!variantSymbol || variantSymbol.kind !== SymbolKind.EnumVariant) {\r\n                    this.reportError(\r\n                        DiagCode.SYMBOL_NOT_FOUND,\r\n                        `Variant '${variantName}' not found in enum`,\r\n                        access.target.span\r\n                    );\r\n                    return null;\r\n                }\r\n\r\n                // Find the variant definition\r\n                const variant = enumDef.variants.find(v => v.ident.name === variantName);\r\n                if (!variant) return null;\r\n\r\n                // Check if variant has associated type\r\n                if (!variant.type) {\r\n                    this.reportError(\r\n                        DiagCode.TOO_MANY_ARGUMENTS,\r\n                        `Variant '${variantName}' does not take any arguments`,\r\n                        call.span\r\n                    );\r\n                    return null;\r\n                }\r\n\r\n                // Validate argument count (should be exactly 1 for now)\r\n                if (call.args.length !== 1) {\r\n                    this.reportError(\r\n                        DiagCode.TOO_MANY_ARGUMENTS,\r\n                        `Variant '${variantName}' expects exactly 1 argument`,\r\n                        call.span\r\n                    );\r\n                    return null;\r\n                }\r\n\r\n                // Validate argument type\r\n                const argType = this.inferExpressionType(call.args[0]);\r\n                if (argType && !this.isTypeCompatible(variant.type, argType)) {\r\n                    this.reportError(\r\n                        DiagCode.TYPE_MISMATCH,\r\n                        `Argument type '${this.getTypeDisplayName(argType)}' is not compatible with variant type '${this.getTypeDisplayName(variant.type)}'`,\r\n                        call.args[0].span\r\n                    );\r\n                }\r\n\r\n                // Return the enum type itself\r\n                return enumType;\r\n            }\r\n\r\n            private validateMemberVisibility(\r\n                memberSymbol: Symbol,\r\n                structScope: Scope,\r\n                accessSpan: AST.Span\r\n            ): void {\r\n                // Public members are always accessible - skip check\r\n                if (memberSymbol.visibility.kind === 'Public') {\r\n                    return;\r\n                }\r\n\r\n                // Check if member is private and being accessed from outside\r\n                if (memberSymbol.visibility.kind === 'Private') {\r\n                    const currentScope = this.config.services.scopeManager.getCurrentScope();\r\n\r\n                    // Walk up to find if we're inside the same struct\r\n                    let isInsideStruct = false;\r\n                    let checkScope: Scope | null = currentScope;\r\n\r\n                    while (checkScope) {\r\n                        if (checkScope.id === structScope.id) {\r\n                            isInsideStruct = true;\r\n                            break;\r\n                        }\r\n\r\n                        if (checkScope.parent !== null) {\r\n                            checkScope = this.config.services.scopeManager.getScope(checkScope.parent);\r\n                        } else {\r\n                            break;\r\n                        }\r\n                    }\r\n\r\n                    if (!isInsideStruct) {\r\n                        this.reportError(\r\n                            DiagCode.SYMBOL_NOT_ACCESSIBLE,\r\n                            `Cannot access private ${memberSymbol.kind === SymbolKind.Function ? 'method' : 'field'} '${memberSymbol.name}' from outside struct`,\r\n                            accessSpan\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n\r\n            private validateBuiltinCall(call: AST.CallNode): AST.TypeNode | null {\r\n                const builtinName = this.extractBuiltinName(call.base);\r\n                if (!builtinName) {\r\n                    this.reportError(\r\n                        DiagCode.INTERNAL_ERROR,\r\n                        'Failed to extract builtin name',\r\n                        call.base.span\r\n                    );\r\n                    return AST.TypeNode.asVoid(call.span);\r\n                }\r\n\r\n                // Look up builtin in global scope\r\n                const globalScope = this.config.services.scopeManager.getGlobalScope();\r\n                const builtinSymbol = globalScope.symbols.get(builtinName);\r\n\r\n                if (!builtinSymbol || !builtinSymbol.type) {\r\n                    this.reportError(\r\n                        DiagCode.UNDEFINED_BUILTIN,\r\n                        `Unknown builtin function '${builtinName}'`,\r\n                        call.base.span\r\n                    );\r\n                    return AST.TypeNode.asVoid(call.span);\r\n                }\r\n\r\n                const funcType = builtinSymbol.type;\r\n                if (!funcType.isFunction()) {\r\n                    this.reportError(\r\n                        DiagCode.TYPE_MISMATCH,\r\n                        `'${builtinName}' is not callable`,\r\n                        call.base.span\r\n                    );\r\n                    return AST.TypeNode.asVoid(call.span);\r\n                }\r\n\r\n                const func = funcType.getFunction()!;\r\n\r\n                // Check argument count\r\n                if (func.params.length !== call.args.length) {\r\n                    const code = func.params.length > call.args.length\r\n                        ? DiagCode.TOO_FEW_ARGUMENTS\r\n                        : DiagCode.TOO_MANY_ARGUMENTS;\r\n\r\n                    this.reportError(\r\n                        code,\r\n                        `Builtin '${builtinName}' expects ${func.params.length} argument(s), but got ${call.args.length}`,\r\n                        call.args.length ? { start: call.args[0].span.start, end: call.args[call.args.length-1].span.end } : call.span\r\n                    );\r\n                    return func.returnType || AST.TypeNode.asVoid(call.span);\r\n                }\r\n\r\n                // Validate argument types\r\n                for (let i = 0; i < func.params.length; i++) {\r\n                    const paramType = func.params[i];\r\n                    const arg = call.args[i];\r\n                    const argType = this.inferExpressionType(arg);\r\n\r\n                    if (!argType) continue;\r\n\r\n                    if (!this.isTypeCompatible(paramType, argType)) {\r\n                        this.reportError(\r\n                            DiagCode.TYPE_MISMATCH,\r\n                            `Argument type '${this.getTypeDisplayName(argType)}' is not compatible with parameter type '${this.getTypeDisplayName(paramType)}'`,\r\n                            arg.span\r\n                        );\r\n                    }\r\n                }\r\n\r\n                return func.returnType || AST.TypeNode.asVoid(call.span);\r\n            }\r\n\r\n            private validateStructMethodCall(\r\n                call: AST.CallNode,\r\n                access: AST.MemberAccessNode,\r\n                structType: AST.TypeNode\r\n            ): AST.TypeNode | null {\r\n                const methodName = this.extractMemberName(access.target);\r\n                if (!methodName) return null;\r\n\r\n                // Get the struct scope\r\n                const struct = structType.getStruct()!;\r\n                const scopeId = struct.metadata?.scopeId as number | undefined;\r\n\r\n                if (scopeId === undefined) {\r\n                    this.reportError(\r\n                        DiagCode.INTERNAL_ERROR,\r\n                        `Cannot find scope for struct method call`,\r\n                        call.span\r\n                    );\r\n                    return null;\r\n                }\r\n\r\n                const structScope = this.config.services.scopeManager.getScope(scopeId);\r\n\r\n                // Find the method symbol\r\n                const methodSymbol = structScope.symbols.get(methodName);\r\n                if (!methodSymbol || methodSymbol.kind !== SymbolKind.Function) {\r\n                    this.reportError(\r\n                        DiagCode.SYMBOL_NOT_FOUND,\r\n                        `Method '${methodName}' not found in struct`,\r\n                        access.target.span\r\n                    );\r\n                    return null;\r\n                }\r\n\r\n                if (!methodSymbol.type || !methodSymbol.type.isFunction()) {\r\n                    this.reportError(\r\n                        DiagCode.TYPE_MISMATCH,\r\n                        `'${methodName}' is not a callable method`,\r\n                        call.span\r\n                    );\r\n                    return null;\r\n                }\r\n\r\n                // Actually validate the call arguments!\r\n                return this.validateMethodCall(call, methodSymbol, structScope, access.base);\r\n            }\r\n\r\n            private validateCallArgumentsWithContext(call: AST.CallNode, funcType: AST.TypeNode): AST.TypeNode | null {\r\n                const func = funcType.getFunction()!;\r\n\r\n                if (func.params.length !== call.args.length) {\r\n                    const code = func.params.length > call.args.length ?\r\n                        DiagCode.TOO_FEW_ARGUMENTS : DiagCode.TOO_MANY_ARGUMENTS;\r\n\r\n                    this.reportError(\r\n                        code,\r\n                        `Expected ${func.params.length} arguments, but got ${call.args.length}`,\r\n                        call.span\r\n                    );\r\n                    return null;\r\n                }\r\n\r\n                for (let i = 0; i < func.params.length; i++) {\r\n                    const paramType = func.params[i];\r\n                    const arg = call.args[i];\r\n\r\n                    // Unified character literal validation\r\n                    if (!this.validateTypeAssignment(arg, paramType, `Argument ${i + 1}`)) {\r\n                        continue; // Error already reported\r\n                    }\r\n\r\n                    let argType = this.inferExpressionTypeWithContext(arg, paramType);\r\n\r\n                    if (!argType) {\r\n                        this.reportError(\r\n                            DiagCode.TYPE_INFERENCE_FAILED,\r\n                            `Cannot infer type for argument ${i + 1}`,\r\n                            arg.span\r\n                        );\r\n                        continue;\r\n                    }\r\n\r\n                    if (!this.isTypeCompatible(paramType, argType)) {\r\n                        this.reportError(\r\n                            DiagCode.TYPE_MISMATCH,\r\n                            `Argument type '${this.getTypeDisplayName(argType)}' is not assignable to parameter type '${this.getTypeDisplayName(paramType)}'`,\r\n                            arg.span\r\n                        );\r\n                    }\r\n                }\r\n\r\n                return func.returnType || AST.TypeNode.asVoid(call.span);\r\n            }\r\n\r\n            private inferExpressionTypeWithContext(expr: AST.ExprNode, expectedType?: AST.TypeNode): AST.TypeNode | null {\r\n                if (expectedType && expr.is('Primary')) {\r\n                    const primary = expr.getPrimary();\r\n                    if (primary && primary.is('Object')) {\r\n                        const obj = primary.getObject()!;\r\n\r\n                        if (!obj.ident) {\r\n                            const resolvedExpected = this.resolveIdentifierType(expectedType);\r\n\r\n                            if (resolvedExpected.isStruct()) {\r\n                                this.validateStructConstruction(obj, resolvedExpected, expr.span);\r\n                                return expectedType;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                return this.inferExpressionType(expr);\r\n            }\r\n\r\n            private inferArrayAccessType(access: AST.ArrayAccessNode): AST.TypeNode | null {\r\n                const baseType = this.inferExpressionType(access.base);\r\n                const indexType = this.inferExpressionType(access.index);\r\n\r\n                if (!baseType) return null;\r\n\r\n                // NEW: Resolve type aliases (slice -> []u8)\r\n                const resolvedType = this.resolveIdentifierType(baseType);\r\n\r\n                // Handle range indexing\r\n                if (access.index.kind === 'Range') {\r\n                    // Return same type as base ([]u8 for slice)\r\n                    return resolvedType;\r\n                }\r\n\r\n                if (indexType && !this.isIntegerType(indexType)) {\r\n                    this.reportError(\r\n                        DiagCode.TYPE_MISMATCH,\r\n                        `Array index must be integer type, got '${this.getTypeDisplayName(indexType)}'`,\r\n                        access.index.span\r\n                    );\r\n                }\r\n\r\n                // Check if it's a tuple type\r\n                if (resolvedType.isTuple()) {\r\n                    return this.inferTupleIndexAccess(resolvedType, access.index, access.span);\r\n                }\r\n\r\n                // Check resolved type for arrays/strings\r\n                if (resolvedType.isArray() || this.isStringType(resolvedType)) {\r\n                    return resolvedType.getArray()!.target;\r\n                }\r\n\r\n                this.reportError(\r\n                    DiagCode.TYPE_MISMATCH,\r\n                    `Cannot index non-array type '${this.getTypeDisplayName(baseType)}'`,\r\n                    access.base.span\r\n                );\r\n                return null;\r\n            }\r\n\r\n            private inferTupleIndexAccess(tupleType: AST.TypeNode, indexExpr: AST.ExprNode, span: AST.Span): AST.TypeNode | null {\r\n                const tuple = tupleType.getTuple()!;\r\n\r\n                // Try to evaluate index as compile-time constant\r\n                const indexValue = this.ExpressionEvaluator.evaluateComptimeExpression(indexExpr);\r\n\r\n                if (indexValue === null) {\r\n                    this.reportError(\r\n                        DiagCode.TYPE_MISMATCH,\r\n                        `Tuple index must be a compile-time constant`,\r\n                        indexExpr.span\r\n                    );\r\n                    return null;\r\n                }\r\n\r\n                const index = Number(indexValue);\r\n\r\n                // Validate index range\r\n                if (index < 0 || index >= tuple.fields.length) {\r\n                    this.reportError(\r\n                        DiagCode.TYPE_MISMATCH,\r\n                        `Tuple index ${index} out of bounds (tuple has ${tuple.fields.length} field${tuple.fields.length !== 1 ? 's' : ''})`,\r\n                        indexExpr.span\r\n                    );\r\n                    return null;\r\n                }\r\n\r\n                return tuple.fields[index];\r\n            }\r\n\r\n            private inferMemberAccessType(access: AST.MemberAccessNode): AST.TypeNode | null {\r\n                // DEBUG: Log the current context\r\n                this.log('verbose', `inferMemberAccessType: currentIsStaticMethod=${this.currentIsStaticMethod}, currentStructScope=${this.currentStructScope?.name || 'null'}`);\r\n\r\n\r\n                // Check wildcard imports FIRST, before inferring base type\r\n                if (access.base.is('Primary')) {\r\n                    const primary = access.base.getPrimary();\r\n                    if (primary?.is('Ident')) {\r\n                        const ident = primary.getIdent()!;\r\n\r\n                        if (ident?.name === 'self') {\r\n                            // ALLOW self in static methods, but validate member is static\r\n                            if (this.currentIsStaticMethod && this.currentStructScope) {\r\n                                const memberName = this.extractMemberName(access.target);\r\n                                if (!memberName) {\r\n                                    this.reportError(DiagCode.INTERNAL_ERROR, `Could not resolve member access on self`, access.target.span);\r\n                                    return null;\r\n                                }\r\n\r\n                                const memberSymbol = this.currentStructScope.symbols.get(memberName);\r\n\r\n                                if (!memberSymbol) {\r\n                                    this.reportError(DiagCode.SYMBOL_NOT_FOUND, `Member '${memberName}' not found in struct`, access.target.span);\r\n                                    return null;\r\n                                }\r\n\r\n                                const isStaticMember = memberSymbol.visibility.kind === 'Static';\r\n\r\n                                // ❌ ERROR if accessing instance member via self in static method\r\n                                if (!isStaticMember) {\r\n                                    const memberType = memberSymbol.kind === SymbolKind.Function ? 'method' : 'field';\r\n                                    this.reportError(\r\n                                        DiagCode.INVALID_STATIC_ACCESS,\r\n                                        `Cannot access instance ${memberType} '${memberName}' via 'self' in static method. Static methods can only access static members.`,\r\n                                        access.target.span\r\n                                    );\r\n                                    return null;\r\n                                }\r\n\r\n                                // Valid static member access via self\r\n                                memberSymbol.used = true;\r\n                                return memberSymbol.type || null;\r\n                            }\r\n\r\n                            // Instance method - resolve self normally\r\n                            const selfSymbol = this.config.services.scopeManager.lookupSymbol('self');\r\n                            if (selfSymbol && selfSymbol.metadata?.isSelf) {\r\n                                selfSymbol.used = true;\r\n                                const selfType = selfSymbol.type;\r\n                                if (selfType) {\r\n                                    return this.resolveMemberOnUnwrappedType(selfType, access, null, false);\r\n                                }\r\n                            }\r\n\r\n                            return null;\r\n                        }\r\n\r\n                        const baseSymbol = this.config.services.scopeManager.lookupSymbol(ident.name);\r\n\r\n                        // Handle wildcard import member access\r\n                        if (baseSymbol && baseSymbol.kind === SymbolKind.Use &&\r\n                            baseSymbol.metadata?.isWildcardImport) {\r\n\r\n                            return this.resolveWildcardMemberAccess(access, baseSymbol);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // Continue with normal resolution...\r\n                let baseType = this.inferExpressionType(access.base);\r\n                if (!baseType) {\r\n                    return null;\r\n                }\r\n\r\n                // NEW: Resolve type aliases (slice -> []u8)\r\n                baseType = this.resolveIdentifierType(baseType);\r\n\r\n                // NEW: Handle built-in array/slice properties\r\n                if (baseType.isArray() || this.isStringType(baseType)) {\r\n                    const memberName = this.extractMemberName(access.target);\r\n\r\n                    if (memberName === 'len') {\r\n                        // Return usize for length\r\n                        return AST.TypeNode.asUnsigned(access.span, 'usize', 64);\r\n                    }\r\n\r\n                    // TODO:\r\n                    // if (memberName === 'ptr') {\r\n                    // }\r\n\r\n                    // Reject other members\r\n                    this.reportError(\r\n                        DiagCode.SYMBOL_NOT_FOUND,\r\n                        `Type '${this.getTypeDisplayName(baseType)}' has no property '${memberName}'. Available: len`,\r\n                        access.target.span\r\n                    );\r\n                    return null;\r\n                }\r\n\r\n                // NEW: Handle built-in tuple properties\r\n                if (baseType.isTuple()) {\r\n                    const memberName = this.extractMemberName(access.target);\r\n\r\n                    if (memberName === 'len') {\r\n                        // Return usize for length\r\n                        return AST.TypeNode.asUnsigned(access.span, 'usize', 64);\r\n                    }\r\n\r\n                    // Reject other members\r\n                    this.reportError(\r\n                        DiagCode.SYMBOL_NOT_FOUND,\r\n                        `Type '${this.getTypeDisplayName(baseType)}' has no property '${memberName}'. Available: len`,\r\n                        access.target.span\r\n                    );\r\n                    return null;\r\n                }\r\n\r\n                if (access.optional && !baseType.isOptional()) {\r\n                    this.reportError(\r\n                        DiagCode.TYPE_MISMATCH,\r\n                        `Cannot use optional chaining on non-optional type '${this.getTypeDisplayName(baseType)}'`,\r\n                        access.span\r\n                    );\r\n                    return null;\r\n                }\r\n\r\n                // Handle dereference in base expression\r\n                if (access.base.is('Postfix')) {\r\n                    const postfix = access.base.getPostfix();\r\n                    if (postfix?.kind === 'Dereference') {\r\n                        if (baseType.isIdent()) {\r\n                            const ident = baseType.getIdent()!;\r\n                            const typeSymbol = this.config.services.scopeManager.lookupSymbol(ident.name);\r\n                            if (typeSymbol?.type) {\r\n                                baseType = typeSymbol.type;\r\n                            }\r\n                        }\r\n                        return this.resolveMemberOnUnwrappedType(baseType, access, null);\r\n                    }\r\n                }\r\n\r\n                let unwrappedType = baseType;\r\n                let optionalDepth = 0;\r\n\r\n                while (unwrappedType.isOptional()) {\r\n                    unwrappedType = unwrappedType.getOptional()!.target;\r\n                    optionalDepth++;\r\n                }\r\n\r\n                if (unwrappedType.isIdent()) {\r\n                    const ident = unwrappedType.getIdent()!;\r\n                    const typeSymbol = this.config.services.scopeManager.lookupSymbol(ident.name);\r\n                    if (typeSymbol?.type) {\r\n                        unwrappedType = typeSymbol.type;\r\n                    }\r\n                }\r\n\r\n                if (unwrappedType.isEnum()) {\r\n                    const memberType = this.resolveEnumMember(unwrappedType, access);\r\n\r\n                    // NEW: Check if variant requires a value but is used without construction\r\n                    if (memberType) {\r\n                        const enumDef = unwrappedType.getEnum()!;\r\n                        const memberName = this.extractMemberName(access.target);\r\n                        const variant = enumDef.variants.find(v => v.ident.name === memberName);\r\n\r\n                        if (variant && variant.type) {\r\n                            // This variant has an associated type but is accessed without ()\r\n                            // Only error if it's NOT being called (checked in parent context)\r\n                            // We'll handle this in the validation phase\r\n                        }\r\n                    }\r\n\r\n                    return memberType;\r\n                }\r\n\r\n                // Check if accessing static member on type identifier\r\n                const isStaticAccess = this.isStaticMemberAccess(access.base);\r\n\r\n                const memberType = this.resolveMemberOnUnwrappedType(\r\n                    unwrappedType,\r\n                    access,\r\n                    null,\r\n                    isStaticAccess\r\n                );\r\n\r\n                if (optionalDepth > 0 && memberType) {\r\n                    return AST.TypeNode.asOptional(access.span, memberType);\r\n                }\r\n\r\n                return memberType;\r\n            }\r\n\r\n            private resolveWildcardMemberAccess(\r\n                access: AST.MemberAccessNode,\r\n                wildcardSymbol: Symbol\r\n            ): AST.TypeNode | null {\r\n                const memberName = this.extractMemberName(access.target);\r\n                if (!memberName) {\r\n                    this.reportError(\r\n                        DiagCode.INTERNAL_ERROR,\r\n                        `Cannot extract member name from wildcard access`,\r\n                        access.target.span\r\n                    );\r\n                    return null;\r\n                }\r\n\r\n                const targetModuleName = wildcardSymbol.importSource;\r\n                if (!targetModuleName) {\r\n                    this.reportError(\r\n                        DiagCode.INTERNAL_ERROR,\r\n                        `Wildcard import has no source module`,\r\n                        access.span\r\n                    );\r\n                    return null;\r\n                }\r\n\r\n                // Find target module scope\r\n                const targetModuleScope = this.findModuleScope(targetModuleName);\r\n                if (!targetModuleScope) {\r\n                    this.reportError(\r\n                        DiagCode.MODULE_SCOPE_NOT_FOUND,\r\n                        `Cannot find scope for module '${targetModuleName}'`,\r\n                        access.span\r\n                    );\r\n                    return null;\r\n                }\r\n\r\n                // Look up the member in the target module\r\n                const memberSymbol = targetModuleScope.symbols.get(memberName);\r\n                if (!memberSymbol) {\r\n                    // THIS IS THE ERROR THAT SHOULD FIRE\r\n                    this.reportError(\r\n                        DiagCode.SYMBOL_NOT_FOUND,\r\n                        `Module '${targetModuleName}' has no exported symbol '${memberName}'`,\r\n                        access.target.span\r\n                    );\r\n                    return null;\r\n                }\r\n\r\n                // Check if symbol is exported\r\n                if (!memberSymbol.isExported) {\r\n                    this.reportError(\r\n                        DiagCode.SYMBOL_NOT_EXPORTED,\r\n                        `Symbol '${memberName}' is not exported from module '${targetModuleName}'`,\r\n                        access.target.span\r\n                    );\r\n                    return null;\r\n                }\r\n\r\n                // Mark as used\r\n                memberSymbol.used = true;\r\n                wildcardSymbol.used = true;\r\n\r\n                // this.stats.memberAccessResolved++;\r\n\r\n                return memberSymbol.type;\r\n            }\r\n\r\n            private isStaticMemberAccess(baseExpr: AST.ExprNode): boolean {\r\n                if (!baseExpr.is('Primary')) return false;\r\n\r\n                const primary = baseExpr.getPrimary();\r\n                if (!primary?.is('Ident')) return false;\r\n\r\n                const ident = primary.getIdent();\r\n                if (!ident) return false;\r\n\r\n                const symbol = this.config.services.scopeManager.lookupSymbol(ident.name);\r\n\r\n                // Static access if it's a type definition (not an instance)\r\n                return symbol?.kind === SymbolKind.Definition;\r\n            }\r\n\r\n            private resolveMemberOnUnwrappedType(\r\n                type: AST.TypeNode,\r\n                access: AST.MemberAccessNode,\r\n                symbol?: Symbol | null,\r\n                isStaticAccess: boolean = false\r\n            ): AST.TypeNode | null {\r\n                if (type.isStruct()) {\r\n                    return this.resolveStructMember(type, access, symbol || null, isStaticAccess);\r\n                }\r\n\r\n                if (type.isEnum()) {\r\n                    return this.resolveEnumMember(type, access);\r\n                }\r\n\r\n                if (type.isErrset()) {\r\n                    return this.resolveEnumMember(type, access);\r\n                }\r\n\r\n                if (type.isOptional()) {\r\n                    const inner = type.getOptional()!.target;\r\n                    const result = this.resolveMemberOnUnwrappedType(inner, access, symbol, isStaticAccess);\r\n                    return result ? AST.TypeNode.asOptional(access.span, result) : null;\r\n                }\r\n\r\n                return null;\r\n            }\r\n\r\n            private resolveStructMember(\r\n                structType: AST.TypeNode,\r\n                access: AST.MemberAccessNode,\r\n                baseSymbol: Symbol | null,\r\n                isStaticAccess: boolean = false\r\n            ): AST.TypeNode | null {\r\n                const struct = structType.getStruct()!;\r\n                const memberName = this.extractMemberName(access.target);\r\n                if (!memberName) return null;\r\n\r\n                let structScope: Scope | null = null;\r\n\r\n                // PRIORITY 1: Use metadata scopeId (most reliable - unique per struct)\r\n                if (struct.metadata?.scopeId !== undefined) {\r\n                    try {\r\n                        structScope = this.config.services.scopeManager.getScope(struct.metadata.scopeId as number);\r\n                    } catch {\r\n                        structScope = null;\r\n                    }\r\n                }\r\n\r\n                // PRIORITY 2: Search by name only if metadata is missing\r\n                if (!structScope && struct.name && struct.name !== 'Anonymous') {\r\n                    // Search in CURRENT scope's children first (to find local Point, not imported Point)\r\n                    const currentScope = this.config.services.scopeManager.getCurrentScope();\r\n                    structScope = this.config.services.scopeManager.findChildScopeByNameFromId(\r\n                        struct.name,\r\n                        currentScope.id,\r\n                        ScopeKind.Type\r\n                    );\r\n\r\n                    // Fall back to global search if not found locally\r\n                    if (!structScope) {\r\n                        structScope = this.config.services.scopeManager.findScopeByName(struct.name, ScopeKind.Type);\r\n                    }\r\n                }\r\n\r\n                if (!structScope) {\r\n                    this.reportError(\r\n                        DiagCode.SYMBOL_NOT_FOUND,\r\n                        `Cannot find scope for struct type`,\r\n                        access.base.span\r\n                    );\r\n                    return null;\r\n                }\r\n\r\n                // Look up the member symbol from the struct scope (where visibility was collected)\r\n                const memberSymbol = structScope.symbols.get(memberName);\r\n\r\n                if (!memberSymbol) {\r\n                    this.reportError(\r\n                        DiagCode.SYMBOL_NOT_FOUND,\r\n                        `Struct has no member '${memberName}'`,\r\n                        access.target.span\r\n                    );\r\n                    return null;\r\n                }\r\n\r\n                // Check visibility using the COLLECTED symbol, not the AST\r\n                if (memberSymbol.visibility.kind === 'Private') {\r\n                    this.reportError(\r\n                        DiagCode.SYMBOL_NOT_ACCESSIBLE,\r\n                        `Cannot access private ${memberSymbol.kind === SymbolKind.Function ? 'method' : 'field'} '${memberName}' from outside struct`,\r\n                        access.target.span\r\n                    );\r\n                    return null;\r\n                }\r\n\r\n                // Handle static vs instance access\r\n                const isStaticField = memberSymbol.visibility.kind === 'Static';\r\n\r\n                if (isStaticAccess && !isStaticField && memberSymbol.kind === SymbolKind.StructField) {\r\n                    this.reportError(\r\n                        DiagCode.INVALID_STATIC_ACCESS,\r\n                        `Cannot access instance field '${memberName}' on type. Use an instance instead.`,\r\n                        access.target.span\r\n                    );\r\n                    return null;\r\n                }\r\n\r\n                if (!isStaticAccess && isStaticField && memberSymbol.kind === SymbolKind.StructField) {\r\n                    this.reportError(\r\n                        DiagCode.INVALID_STATIC_ACCESS,\r\n                        `Cannot access static field '${memberName}' on instance. Use '${struct.name}.${memberName}' instead.`,\r\n                        access.target.span\r\n                    );\r\n                    return null;\r\n                }\r\n\r\n                return memberSymbol.type || null;\r\n            }\r\n\r\n            private validateMethodCall(\r\n                call: AST.CallNode,\r\n                methodSymbol: Symbol,\r\n                structScope: Scope,\r\n                baseExpr: AST.ExprNode\r\n            ): AST.TypeNode | null {\r\n                this.log('symbols', `Validating method call '${methodSymbol.name}' on struct instance`);\r\n\r\n                if (!methodSymbol.type || !methodSymbol.type.isFunction()) {\r\n                    this.reportError(\r\n                        DiagCode.TYPE_MISMATCH,\r\n                        `'${methodSymbol.name}' is not a callable method`,\r\n                        call.span\r\n                    );\r\n                    return null;\r\n                }\r\n\r\n                const funcType = methodSymbol.type.getFunction()!;\r\n\r\n                if (funcType.params.length !== call.args.length) {\r\n                    const code = funcType.params.length > call.args.length ?\r\n                        DiagCode.TOO_FEW_ARGUMENTS : DiagCode.TOO_MANY_ARGUMENTS;\r\n\r\n                    this.reportError(\r\n                        code,\r\n                        `Expected ${funcType.params.length} arguments, but got ${call.args.length}`,\r\n                        call.span\r\n                    );\r\n                    return null;\r\n                }\r\n\r\n                // Validate arguments in CALLER'S scope, not struct scope\r\n                // Arguments are expressions evaluated in the calling context\r\n                for (let i = 0; i < funcType.params.length; i++) {\r\n                    const paramType = funcType.params[i];\r\n                    const arg = call.args[i];\r\n\r\n                    const argType = this.inferExpressionTypeWithContext(arg, paramType);\r\n\r\n                    if (!argType || !this.isTypeCompatible(paramType, argType)) {\r\n                        this.reportError(\r\n                            DiagCode.TYPE_MISMATCH,\r\n                            `Argument type '${argType ? this.getTypeDisplayName(argType!) : 'unknown'}' is not assignable to parameter type '${this.getTypeDisplayName(paramType)}'`,\r\n                            arg.span\r\n                        );\r\n                    }\r\n                }\r\n\r\n                return funcType.returnType || AST.TypeNode.asVoid(call.span);\r\n            }\r\n\r\n            private resolveEnumMember(enumType: AST.TypeNode, access: AST.MemberAccessNode): AST.TypeNode | null {\r\n                const memberName = this.extractMemberName(access.target);\r\n                if (!memberName) return null;\r\n\r\n                // Handle enum types\r\n                if (enumType.isEnum()) {\r\n                    const enumDef = enumType.getEnum()!;\r\n                    for (const variant of enumDef.variants) {\r\n                        if (variant.ident.name === memberName) {\r\n                            return variant.type || enumType;\r\n                        }\r\n                    }\r\n\r\n                    // ADD THIS: Report error if variant not found\r\n                    this.reportError(\r\n                        DiagCode.SYMBOL_NOT_FOUND,\r\n                        `Enum variant '${memberName}' not found`,\r\n                        access.target.span\r\n                    );\r\n                    return null;\r\n                }\r\n\r\n                // Handle error types - use 'members' not 'variants'\r\n                if (enumType.isErrset()) {\r\n                    const errorType = enumType.getErrset()!;\r\n                    for (const member of errorType.members) {\r\n                        if (member.name === memberName) {\r\n                            return AST.TypeNode.asIdentifier(member.span, member.name);\r\n                        }\r\n                    }\r\n\r\n                    // ADD THIS: Report error if error member not found\r\n                    this.reportError(\r\n                        DiagCode.ERROR_MEMBER_NOT_FOUND,\r\n                        `Error member '${memberName}' not found in error set`,\r\n                        access.target.span\r\n                    );\r\n                    return null;\r\n                }\r\n\r\n                // Only report if we get here (neither enum nor errset matched)\r\n                this.reportError(\r\n                    DiagCode.SYMBOL_NOT_FOUND,\r\n                    `${enumType.isErrset() ? 'Error set' : 'Enum'} has no variant '${memberName}'`,\r\n                    access.target.span\r\n                );\r\n                return null;\r\n            }\r\n\r\n            // ===== SPECIAL EXPRESSIONS =====\r\n\r\n            private inferAsType(asNode: AST.AsNode): AST.TypeNode | null {\r\n                const sourceType = this.inferExpressionType(asNode.base);\r\n                if (!sourceType) return null;\r\n\r\n                if (!this.canConvertTypes(sourceType, asNode.type)) {\r\n                    this.reportError(\r\n                        DiagCode.TYPE_MISMATCH,\r\n                        `Cannot convert type '${this.getTypeDisplayName(sourceType)}' to type '${this.getTypeDisplayName(asNode.type)}'`,\r\n                        asNode.span\r\n                    );\r\n                }\r\n\r\n                return asNode.type;\r\n            }\r\n\r\n            private inferOrelseType(orelse: AST.OrelseNode): AST.TypeNode | null {\r\n                const leftType = this.inferExpressionType(orelse.left);\r\n                const rightType = this.inferExpressionType(orelse.right);\r\n\r\n                if (!leftType) return rightType;\r\n                if (!rightType) return leftType;\r\n\r\n                // Handle ?T ?? something\r\n                if (leftType.isOptional()) {\r\n                    const unwrapped = leftType.getOptional()!.target; // T\r\n\r\n                    // CASE 1: ?T ?? null -> T | null\r\n                    if (rightType.isNull()) {\r\n                        return AST.TypeNode.asUnion(orelse.span, [unwrapped, rightType]);\r\n                    }\r\n\r\n                    // CASE 2: ?T ?? ?U -> ?T (keeps leftType as-is)\r\n                    // Example: ?i32 ?? ?i32 = ?i32\r\n                    if (rightType.isOptional()) {\r\n                        const rightUnwrapped = rightType.getOptional()!.target;\r\n\r\n                        // Validate that T and U are compatible\r\n                        if (!this.isTypeCompatible(unwrapped, rightUnwrapped)) {\r\n                            this.reportError(\r\n                                DiagCode.TYPE_MISMATCH,\r\n                                `Cannot use type '${this.getTypeDisplayName(rightType)}' as fallback for '${this.getTypeDisplayName(leftType)}'`,\r\n                                orelse.right.span\r\n                            );\r\n                        }\r\n\r\n                        // Return the optional type (left side takes precedence)\r\n                        return leftType; // ?T\r\n                    }\r\n\r\n                    // CASE 3: ?T ?? T -> T (unwrapped)\r\n                    // Example: ?i32 ?? 0 = i32\r\n                    if (!this.isTypeCompatible(unwrapped, rightType)) {\r\n                        this.reportError(\r\n                            DiagCode.TYPE_MISMATCH,\r\n                            `Cannot use type '${this.getTypeDisplayName(rightType)}' as fallback for '${this.getTypeDisplayName(leftType)}'`,\r\n                            orelse.right.span\r\n                        );\r\n                    }\r\n\r\n                    return unwrapped; // T\r\n                }\r\n\r\n                // Left is not optional, just return it\r\n                return leftType;\r\n            }\r\n\r\n            private inferRangeType(range: AST.RangeNode): AST.TypeNode | null {\r\n                if (range.leftExpr) {\r\n                    const leftType = this.inferExpressionType(range.leftExpr);\r\n                    if (leftType && !this.isIntegerType(leftType)) {\r\n                        this.reportError(\r\n                            DiagCode.TYPE_MISMATCH,\r\n                            `Range start must be integer type, got '${this.getTypeDisplayName(leftType)}'`,\r\n                            range.leftExpr.span\r\n                        );\r\n                    }\r\n                }\r\n\r\n                if (range.rightExpr) {\r\n                    const rightType = this.inferExpressionType(range.rightExpr);\r\n                    if (rightType && !this.isIntegerType(rightType)) {\r\n                        this.reportError(\r\n                            DiagCode.TYPE_MISMATCH,\r\n                            `Range end must be integer type, got '${this.getTypeDisplayName(rightType)}'`,\r\n                            range.rightExpr.span\r\n                        );\r\n                    }\r\n                }\r\n\r\n                return null;\r\n            }\r\n\r\n            private inferTryType(tryNode: AST.TryNode): AST.TypeNode | null {\r\n                const exprType = this.inferExpressionType(tryNode.expr);\r\n                if (!exprType) return null;\r\n                return exprType;\r\n            }\r\n\r\n            private inferCatchType(catchNode: AST.CatchNode): AST.TypeNode | null {\r\n                const leftType = this.inferExpressionType(catchNode.leftExpr);\r\n\r\n                const exprScope = this.config.services.scopeManager.findChildScopeByName('expr', ScopeKind.Expression);\r\n                if (exprScope) {\r\n                    this.config.services.contextTracker.withSavedState(() => {\r\n                        this.config.services.scopeManager.withScope(exprScope.id, () => {\r\n                            this.validateStmt(catchNode.rightStmt);\r\n                        });\r\n                    });\r\n                }\r\n\r\n                return leftType;\r\n            }\r\n\r\n            private inferIfType(ifNode: AST.IfNode): AST.TypeNode | null {\r\n                const condType = this.inferExpressionType(ifNode.condExpr);\r\n                if (condType && !condType.isBool()) {\r\n                    this.log('verbose', `If condition has type ${this.getTypeDisplayName(condType)}, expected bool`);\r\n                }\r\n\r\n                const exprScope = this.config.services.scopeManager.findChildScopeByName('expr', ScopeKind.Expression);\r\n                if (exprScope) {\r\n                    this.config.services.contextTracker.withSavedState(() => {\r\n                        this.config.services.scopeManager.withScope(exprScope.id, () => {\r\n                            this.validateStmt(ifNode.thenStmt);\r\n                            if (ifNode.elseStmt) {\r\n                                this.validateStmt(ifNode.elseStmt);\r\n                            }\r\n                        });\r\n                    });\r\n                } else {\r\n                    this.validateStmt(ifNode.thenStmt);\r\n                    if (ifNode.elseStmt) {\r\n                        this.validateStmt(ifNode.elseStmt);\r\n                    }\r\n                }\r\n\r\n                return null;\r\n            }\r\n\r\n            private inferSwitchType(MatchNode: AST.MatchNode): AST.TypeNode | null {\r\n                this.inferExpressionType(MatchNode.condExpr);\r\n                this.validateSwitchExhaustiveness(MatchNode);\r\n\r\n                const exprScope = this.config.services.scopeManager.findChildScopeByName('expr', ScopeKind.Expression);\r\n\r\n                for (const switchCase of MatchNode.cases) {\r\n                    if (switchCase.expr) {\r\n                        this.inferExpressionType(switchCase.expr);\r\n                    }\r\n                    if (switchCase.stmt) {\r\n                        if (exprScope) {\r\n                            this.config.services.contextTracker.withSavedState(() => {\r\n                                this.config.services.scopeManager.withScope(exprScope.id, () => {\r\n                                    this.validateStmt(switchCase.stmt!);\r\n                                });\r\n                            });\r\n                        } else {\r\n                            this.validateStmt(switchCase.stmt);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (MatchNode.defCase) {\r\n                    if (exprScope) {\r\n                        this.config.services.contextTracker.withSavedState(() => {\r\n                            this.config.services.scopeManager.withScope(exprScope.id, () => {\r\n                                this.validateStmt(MatchNode.defCase!.stmt);\r\n                            });\r\n                        });\r\n                    } else {\r\n                        this.validateStmt(MatchNode.defCase.stmt);\r\n                    }\r\n                }\r\n\r\n                return null;\r\n            }\r\n\r\n        // └──────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌─────────────────────────── [5] Ident Level ──────────────────────────┐\r\n\r\n            private resolveIdentifierType(type: AST.TypeNode): AST.TypeNode {\r\n                if (!type.isIdent()) return type;\r\n\r\n                const ident = type.getIdent()!;\r\n                if (ident.builtin) return type;\r\n\r\n                const symbol = this.config.services.scopeManager.lookupSymbol(ident.name);\r\n                if (symbol && symbol.type) {\r\n                    // RECURSIVELY resolve until we hit a non-identifier\r\n                    return this.resolveIdentifierType(symbol.type);\r\n                }\r\n\r\n                return type;\r\n            }\r\n\r\n        // └──────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌─────────────────────────── [6] Type Level ───────────────────────────┐\r\n\r\n            private validateStructType(structType: AST.StructTypeNode, symbol: Symbol): void {\r\n                let typeScope: Scope | null = null;\r\n\r\n                if (structType.metadata?.scopeId !== undefined) {\r\n                    try {\r\n                        typeScope = this.config.services.scopeManager.getScope(structType.metadata.scopeId as number);\r\n                    } catch {\r\n                        typeScope = null;\r\n                    }\r\n                }\r\n\r\n                if (!typeScope && structType.name && structType.name !== 'Anonymous') {\r\n                    typeScope = this.config.services.scopeManager.findScopeByName(structType.name, ScopeKind.Type);\r\n                }\r\n\r\n                if (!typeScope) {\r\n                    typeScope = this.config.services.scopeManager.findChildScopeByNameFromId(\r\n                        symbol.name,\r\n                        symbol.scope,\r\n                        ScopeKind.Type\r\n                    );\r\n                }\r\n\r\n                if (!typeScope) {\r\n                    this.reportError(\r\n                        DiagCode.INTERNAL_ERROR,\r\n                        `Cannot find type scope for struct validation`,\r\n                        structType.span\r\n                    );\r\n                    return;\r\n                }\r\n\r\n                this.config.services.contextTracker.withSavedState(() => {\r\n                    this.config.services.scopeManager.withScope(typeScope!.id, () => {\r\n                        for (const member of structType.members) {\r\n                            if (member.isField()) {\r\n                                const field = member.getField()!;\r\n\r\n                                // Validate field visibility\r\n                                if (field.visibility.kind === 'Static' && field.mutability.kind === 'Mutable') {\r\n                                    this.reportError(\r\n                                        DiagCode.INVALID_VISIBILITY,\r\n                                        `Struct field '${field.ident.name}' cannot be 'static'`,\r\n                                        field.span\r\n                                    );\r\n                                    continue;\r\n                                }\r\n\r\n                                // Resolve field type\r\n                                if (field.type) {\r\n                                    this.resolveTypeNode(field.type);\r\n                                }\r\n\r\n                                // Validate field initializer\r\n                                if (field.initializer) {\r\n                                    // Special handling for array literals with explicit type\r\n                                    if (field.type && field.type.isArray()) {\r\n                                        this.validateArrayLiteralWithTargetType(\r\n                                            field.initializer,\r\n                                            field.type,\r\n                                            field.ident.name\r\n                                        );\r\n                                        continue; // Skip to next field\r\n                                    }\r\n\r\n                                    const initType = this.inferExpressionType(field.initializer);\r\n\r\n                                    if (field.type && initType) {\r\n                                        // Unified validation\r\n                                        this.validateTypeAssignment(\r\n                                            field.initializer,\r\n                                            field.type,\r\n                                            `Field '${field.ident.name}' initializer`\r\n                                        );\r\n\r\n                                        if (!this.validateArrayAssignment(\r\n                                            field.type,\r\n                                            initType,\r\n                                            field.initializer.span,\r\n                                            `Field '${field.ident.name}' initializer`\r\n                                        )) {\r\n                                            continue;\r\n                                        }\r\n\r\n                                        // PASS SOURCE EXPRESSION for strict pointer checking\r\n                                        if (!this.isTypeCompatible(field.type, initType, field.initializer)) {\r\n                                            this.reportError(\r\n                                                DiagCode.TYPE_MISMATCH,\r\n                                                `Field '${field.ident.name}' initializer type '${this.getTypeDisplayName(initType)}' doesn't match field type '${this.getTypeDisplayName(field.type)}'`,\r\n                                                field.initializer.span\r\n                                            );\r\n                                        }\r\n                                    } else if (!field.type && initType) {\r\n                                        field.type = initType;\r\n                                    }\r\n\r\n                                    // NEW: Check if initializer is an enum variant that requires a value\r\n                                    if (field.initializer.is('Postfix')) {\r\n                                        const postfix = field.initializer.getPostfix();\r\n                                        if (postfix?.kind === 'MemberAccess') {\r\n                                            const access = postfix.getMemberAccess()!;\r\n                                            const baseType = this.inferExpressionType(access.base);\r\n\r\n                                            if (baseType) {\r\n                                                const resolvedBase = this.resolveIdentifierType(baseType);\r\n\r\n                                                if (resolvedBase.isEnum()) {\r\n                                                    const memberName = this.extractMemberName(access.target);\r\n                                                    const enumDef = resolvedBase.getEnum()!;\r\n                                                    const variant = enumDef.variants.find(v => v.ident.name === memberName);\r\n\r\n                                                    if (variant && variant.type) {\r\n                                                        this.reportError(\r\n                                                            DiagCode.TYPE_MISMATCH,\r\n                                                            `Enum variant '${memberName}' requires a value of type '${this.getTypeDisplayName(variant.type)}'. Use '${memberName}(value)' syntax.`,\r\n                                                            field.initializer.span\r\n                                                        );\r\n                                                        return;\r\n                                                    }\r\n                                                }\r\n                                            }\r\n                                        }\r\n                                    }\r\n\r\n                                    if (field.type) {\r\n                                        this.validateValueFitsInType(field.initializer, field.type);\r\n                                    }\r\n                                }\r\n                            } else {\r\n                                const method = member.getMethod()!;\r\n                                this.validateFuncStmt(method);\r\n                            }\r\n                        }\r\n                    });\r\n                });\r\n            }\r\n\r\n            private validateStructConstruction(\r\n                objNode: AST.ObjectNode,\r\n                structType: AST.TypeNode,\r\n                initSpan: AST.Span\r\n            ): boolean {\r\n                if (!structType.isStruct()) {\r\n                    this.reportError(\r\n                        DiagCode.TYPE_MISMATCH,\r\n                        `Cannot initialize non-struct type with object literal`,\r\n                        initSpan\r\n                    );\r\n                    return false;\r\n                }\r\n\r\n                const struct = structType.getStruct()!;\r\n\r\n                // Validate constructor name matches type name\r\n                if (objNode.ident) {\r\n                    const constructorName = objNode.ident.name;\r\n                    const expectedName = struct.name || this.extractTypeName(structType);\r\n\r\n                    if (expectedName && constructorName !== expectedName) {\r\n                        this.reportError(\r\n                            DiagCode.TYPE_MISMATCH,\r\n                            `Constructor '${constructorName}' does not match expected type '${expectedName}'`,\r\n                            objNode.ident.span\r\n                        );\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                const structFields = new Map<string, AST.FieldNode>();\r\n                for (const member of struct.members) {\r\n                    if (member.isField()) {\r\n                        const field = member.source as AST.FieldNode;\r\n                        structFields.set(field.ident.name, field);\r\n                    }\r\n                }\r\n\r\n                const providedFields = new Set<string>();\r\n\r\n                for (const prop of objNode.props) {\r\n                    const fieldName = prop.key.name;\r\n                    providedFields.add(fieldName);\r\n\r\n                    const structField = structFields.get(fieldName);\r\n                    if (!structField) {\r\n                        this.reportError(\r\n                            DiagCode.SYMBOL_NOT_FOUND,\r\n                            `Struct '${struct.name || '<anonymous>'}' has no field '${fieldName}'`,\r\n                            prop.key.span\r\n                        );\r\n                        continue;\r\n                    }\r\n\r\n                    if (structField.visibility.kind === 'Static') {\r\n                        this.reportError(\r\n                            DiagCode.INVALID_STATIC_ACCESS,\r\n                            `Cannot initialize static field '${fieldName}' in constructor. Static fields belong to the type, not instances.`,\r\n                            prop.key.span\r\n                        );\r\n                        continue;\r\n                    }\r\n\r\n                    // Unified validation for field values\r\n                    if (prop.val && structField.type) {\r\n                        if (!this.validateTypeAssignment(\r\n                            prop.val,\r\n                            structField.type,\r\n                            `Field '${fieldName}'`\r\n                        )) {\r\n                            continue; // Error already reported\r\n                        }\r\n\r\n                        const valueType = this.inferExpressionType(prop.val);\r\n\r\n                        if (valueType && !this.isTypeCompatible(structField.type, valueType)) {\r\n                            this.reportError(\r\n                                DiagCode.TYPE_MISMATCH,\r\n                                `Field '${fieldName}' expects type '${this.getTypeDisplayName(structField.type)}' but got '${this.getTypeDisplayName(valueType)}'`,\r\n                                prop.val.span\r\n                            );\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // Check for missing required fields (skip static fields)\r\n                let hasMissingFields = false;\r\n                for (const [fieldName, field] of structFields) {\r\n                    if (field.visibility.kind === 'Static') {\r\n                        continue;\r\n                    }\r\n\r\n                    if (!providedFields.has(fieldName) && !field.initializer) {\r\n                        this.reportError(\r\n                            DiagCode.TYPE_MISMATCH,\r\n                            `Missing required field '${fieldName}' in struct initialization`,\r\n                            initSpan\r\n                        );\r\n                        hasMissingFields = true;\r\n                    }\r\n                }\r\n\r\n                return !hasMissingFields;\r\n            }\r\n\r\n            private validateEnumType(enumType: AST.EnumTypeNode, symbol: Symbol): void {\r\n                const typeScope = this.config.services.scopeManager.findChildScopeByName(symbol.name, ScopeKind.Type);\r\n                if (!typeScope) return;\r\n\r\n                this.config.services.contextTracker.withSavedState(() => {\r\n                    this.config.services.scopeManager.withScope(typeScope.id, () => {\r\n                        for (const variant of enumType.variants) {\r\n                            if (variant.type) {\r\n                                this.resolveTypeNode(variant.type);\r\n                            }\r\n                        }\r\n                    });\r\n                });\r\n            }\r\n\r\n            private validateArraySize(sizeExpr: AST.ExprNode): void {\r\n                // Track errors before evaluation\r\n                const errorCountBefore = this.config.services.diagnosticManager.length();\r\n\r\n                // Try to evaluate the size expression\r\n                // This handles:\r\n                // - Literals: [10]i32\r\n                // - Function calls: [get_size()]i32  (comptime functions only)\r\n                // - Binary operations: [base() + base()]i32\r\n                // - Arithmetic: [5 + 5]i32\r\n                // etc.\r\n\r\n                const comptimeValue = this.ExpressionEvaluator.evaluateComptimeExpression(sizeExpr);\r\n\r\n                // Check if evaluation added errors\r\n                const errorCountAfter = this.config.services.diagnosticManager.length();\r\n                const evaluationFailed = errorCountAfter > errorCountBefore;\r\n\r\n                if (evaluationFailed) {\r\n                    return; // Errors already reported with full context\r\n                }\r\n\r\n                if (comptimeValue === null) {\r\n                    this.reportError(\r\n                        DiagCode.TYPE_MISMATCH,\r\n                        'Array size must be a compile-time constant expression. Use literals, comptime functions, or compile-time arithmetic.',\r\n                        sizeExpr.span\r\n                    );\r\n                    return;\r\n                }\r\n\r\n                // Validate the computed size is positive\r\n                if (comptimeValue <= BigInt(0)) {\r\n                    this.reportError(\r\n                        DiagCode.TYPE_MISMATCH,\r\n                        `Array size must be positive, got ${comptimeValue}`,\r\n                        sizeExpr.span\r\n                    );\r\n                    return;\r\n                }\r\n\r\n                // Check for reasonable size limits\r\n                const MAX_ARRAY_SIZE = BigInt(2_147_483_647);\r\n                if (comptimeValue > MAX_ARRAY_SIZE) {\r\n                    this.reportError(\r\n                        DiagCode.TYPE_MISMATCH,\r\n                        `Array size ${comptimeValue} exceeds maximum allowed size ${MAX_ARRAY_SIZE}`,\r\n                        sizeExpr.span\r\n                    );\r\n                    return;\r\n                }\r\n\r\n                // SUCCESS: Size is valid\r\n            }\r\n\r\n            private validateSwitchExhaustiveness(MatchNode: AST.MatchNode): void {\r\n                const condType = this.inferExpressionType(MatchNode.condExpr);\r\n                if (!condType) return;\r\n\r\n                // Resolve identifier types first\r\n                let resolvedType = condType;\r\n                if (condType.isIdent()) {\r\n                    const ident = condType.getIdent()!;\r\n                    const typeSymbol = this.config.services.scopeManager.lookupSymbol(ident.name);\r\n                    if (typeSymbol && typeSymbol.type) {\r\n                        resolvedType = typeSymbol.type;\r\n                    }\r\n                }\r\n\r\n                // Handle enum exhaustiveness\r\n                if (resolvedType.isEnum()) {\r\n                    const enumType = resolvedType.getEnum()!;\r\n                    const coveredVariants = new Set<string>();\r\n\r\n                    for (const switchCase of MatchNode.cases) {\r\n                        if (switchCase.expr) {\r\n                            const variantName = this.extractEnumVariantName(switchCase.expr);\r\n                            if (variantName) {\r\n                                coveredVariants.add(variantName);\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    // Check exhaustiveness only if no default case\r\n                    if (!MatchNode.defCase) {\r\n                        const missingVariants: string[] = [];\r\n                        for (const variant of enumType.variants) {\r\n                            if (!coveredVariants.has(variant.ident.name)) {\r\n                                missingVariants.push(variant.ident.name);\r\n                            }\r\n                        }\r\n\r\n                        if (missingVariants.length > 0) {\r\n                            this.reportError(\r\n                                DiagCode.TYPE_MISMATCH,\r\n                                `Switch is not exhaustive. Missing variants: ${missingVariants.join(', ')}`,\r\n                                MatchNode.span\r\n                            );\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // Handle boolean exhaustiveness\r\n                if (resolvedType.isBool()) {\r\n                    const hasTrue = MatchNode.cases.some((c: AST.CaseNode) => this.isBoolLiteral(c.expr, true));\r\n                    const hasFalse = MatchNode.cases.some((c: AST.CaseNode) => this.isBoolLiteral(c.expr, false));\r\n\r\n                    if (!MatchNode.defCase && (!hasTrue || !hasFalse)) {\r\n                        this.reportError(\r\n                            DiagCode.TYPE_MISMATCH,\r\n                            'Match on boolean must handle both true and false cases or have a default',\r\n                            MatchNode.span\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n\r\n            private validateArrayAssignment(\r\n                declaredType: AST.TypeNode,\r\n                initType: AST.TypeNode,\r\n                initSpan: AST.Span,\r\n                contextName: string\r\n            ): boolean {\r\n                if (!declaredType.isArray() || !initType.isArray()) {\r\n                    return true; // Not an array assignment, validation not applicable\r\n                }\r\n\r\n                const targetArray = declaredType.getArray()!;\r\n                const sourceArray = initType.getArray()!;\r\n\r\n                if (!targetArray.size || !sourceArray.size) {\r\n                    return true; // No size constraints to validate\r\n                }\r\n\r\n                const targetSize = this.ExpressionEvaluator.extractIntegerValue(targetArray.size);\r\n                const sourceSize = this.ExpressionEvaluator.extractIntegerValue(sourceArray.size);\r\n\r\n                if (targetSize === undefined || sourceSize === undefined) {\r\n                    return true; // Cannot extract sizes, skip validation\r\n                }\r\n\r\n                if (targetSize !== sourceSize) {\r\n                    const msg = sourceSize > targetSize\r\n                        ? `Array literal has more elements than the fixed array type`\r\n                        : `Array literal has fewer elements than the fixed array type`;\r\n\r\n                    this.reportError(\r\n                        DiagCode.ARRAY_SIZE_MISMATCH,\r\n                        `${msg}`,\r\n                        initSpan\r\n                    );\r\n                    return false; // Validation failed\r\n                }\r\n\r\n                return true; // Sizes match, validation passed\r\n            }\r\n\r\n            private checkCircularTypeDependency(\r\n                typeNode: AST.TypeNode,\r\n                typeName: string,\r\n                allowIndirection: boolean = false,\r\n                pathHasIndirection: boolean = false\r\n            ): boolean {\r\n                const key = `${typeName}:${typeNode.kind}:${typeNode.span.start}`;\r\n\r\n                if (this.circularTypeDetectionStack.has(key)) {\r\n                    if (!pathHasIndirection) {\r\n                        this.reportError(\r\n                            DiagCode.TYPE_MISMATCH,\r\n                            `Circular type dependency detected for '${typeName}'. Use pointer or optional to break the cycle.`,\r\n                            typeNode.span\r\n                        );\r\n                        return true;\r\n                    }\r\n                    return false;\r\n                }\r\n\r\n                this.circularTypeDetectionStack.add(key);\r\n\r\n                try {\r\n                    switch (typeNode.kind) {\r\n                        case 'ident': {\r\n                            const ident = typeNode.getIdent()!;\r\n                            if (!ident.builtin && ident.name === typeName) {\r\n                                if (!pathHasIndirection) {\r\n                                    this.reportError(\r\n                                        DiagCode.TYPE_MISMATCH,\r\n                                        `Direct self-reference in type '${typeName}'. Use pointer or optional to break the cycle.`,\r\n                                        typeNode.span\r\n                                    );\r\n                                    return true;\r\n                                }\r\n                                return false;\r\n                            }\r\n\r\n                            if (!ident.builtin) {\r\n                                const typeSymbol = this.config.services.scopeManager.lookupSymbol(ident.name);\r\n                                if (typeSymbol && typeSymbol.type && typeSymbol.kind === SymbolKind.Definition) {\r\n                                    return this.checkCircularTypeDependency(\r\n                                        typeSymbol.type,\r\n                                        typeName,\r\n                                        allowIndirection,\r\n                                        pathHasIndirection\r\n                                    );\r\n                                }\r\n                            }\r\n                            break;\r\n                        }\r\n\r\n                        case 'array':\r\n                            return this.checkCircularTypeDependency(\r\n                                typeNode.getArray()!.target,\r\n                                typeName,\r\n                                allowIndirection,\r\n                                pathHasIndirection\r\n                            );\r\n\r\n                        case 'optional':\r\n                        case 'pointer':\r\n                            if (allowIndirection) {\r\n                                return false;\r\n                            }\r\n                            return this.checkCircularTypeDependency(\r\n                                typeNode.kind === 'optional'\r\n                                    ? typeNode.getOptional()!.target\r\n                                    : typeNode.getPointer()!.target,\r\n                                typeName,\r\n                                allowIndirection,\r\n                                true\r\n                            );\r\n\r\n                        case 'tuple':\r\n                            for (const field of typeNode.getTuple()!.fields) {\r\n                                if (this.checkCircularTypeDependency(\r\n                                    field,\r\n                                    typeName,\r\n                                    allowIndirection,\r\n                                    pathHasIndirection\r\n                                )) {\r\n                                    return true;\r\n                                }\r\n                            }\r\n                            break;\r\n\r\n                        case 'struct': {\r\n                            const struct = typeNode.getStruct()!;\r\n                            for (const member of struct.members) {\r\n                                if (member.isField()) {\r\n                                    const field = member.source as AST.FieldNode;\r\n                                    if (field.type && this.checkCircularTypeDependency(\r\n                                        field.type,\r\n                                        typeName,\r\n                                        allowIndirection,\r\n                                        pathHasIndirection\r\n                                    )) {\r\n                                        return true;\r\n                                    }\r\n                                }\r\n                            }\r\n                            break;\r\n                        }\r\n\r\n                        case 'enum': {\r\n                            const enumType = typeNode.getEnum()!;\r\n                            for (const variant of enumType.variants) {\r\n                                if (variant.type && this.checkCircularTypeDependency(\r\n                                    variant.type,\r\n                                    typeName,\r\n                                    allowIndirection,\r\n                                    pathHasIndirection\r\n                                )) {\r\n                                    return true;\r\n                                }\r\n                            }\r\n                            break;\r\n                        }\r\n\r\n                        case 'union': {\r\n                            const unionType = typeNode.getUnion()!;\r\n                            for (const member of unionType.types) {\r\n                                if (this.checkCircularTypeDependency(\r\n                                    member,\r\n                                    typeName,\r\n                                    allowIndirection,\r\n                                    pathHasIndirection\r\n                                )) {\r\n                                    return true;\r\n                                }\r\n                            }\r\n                            break;\r\n                        }\r\n\r\n                        case 'paren': {\r\n                            return this.checkCircularTypeDependency(\r\n                                typeNode.getParen()!.type,\r\n                                typeName,\r\n                                allowIndirection,\r\n                                pathHasIndirection\r\n                            )\r\n                        }\r\n                    }\r\n\r\n                    return false;\r\n                } finally {\r\n                    this.circularTypeDetectionStack.delete(key);\r\n                }\r\n            }\r\n\r\n        // └──────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌──────────────────────── UNIFIED CHARACTER LITERAL VALIDATION ────────────────────────┐\r\n\r\n            private isCharacterLiteral(expr: AST.ExprNode): boolean {\r\n                if (!expr.is('Primary')) return false;\r\n                const primary = expr.getPrimary();\r\n                if (!primary?.is('Literal')) return false;\r\n                const literal = primary.getLiteral();\r\n                return literal?.kind === 'Character';\r\n            }\r\n\r\n            private validateCharacterLiteralCompatibility(\r\n                expr: AST.ExprNode,\r\n                targetType: AST.TypeNode,\r\n                context: string\r\n            ): boolean {\r\n                // Only validate character literals\r\n                if (!this.isCharacterLiteral(expr)) {\r\n                    return true; // Not a character literal, skip validation\r\n                }\r\n\r\n                const primary = expr.getPrimary()!;\r\n                const literal = primary.getLiteral()!;\r\n                const charValue = literal.value as string;\r\n\r\n                // Empty character - always valid\r\n                if (charValue.length === 0) return true;\r\n\r\n                const codePoint = charValue.codePointAt(0) || 0;\r\n                const resolvedType = this.resolveIdentifierType(targetType);\r\n\r\n                // Check if target is char (u8) - can only hold ASCII (0-255)\r\n                if (resolvedType.isUnsigned() && resolvedType.getWidth() === 8) {\r\n                    if (codePoint > 255) {\r\n                        this.reportError(\r\n                            DiagCode.ARITHMETIC_OVERFLOW,\r\n                            `Value ${codePoint} does not fit in type '${this.getTypeDisplayName(targetType)}' (valid range: 0 to 255)`,\r\n                            expr.span\r\n                        );\r\n                        return false;\r\n                    }\r\n                }\r\n                // Check if target is cpoint (u21) - can hold up to 2,097,151\r\n                else if (resolvedType.isUnsigned() && resolvedType.getWidth() === 21) {\r\n                    if (codePoint > 0x1FFFFF) {\r\n                        this.reportError(\r\n                            DiagCode.ARITHMETIC_OVERFLOW,\r\n                            `Value ${codePoint} does not fit in type '${this.getTypeDisplayName(targetType)}' (valid range: 0 to 2097151)`,\r\n                            expr.span\r\n                        );\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                return true;\r\n            }\r\n\r\n            private validateTypeAssignment(\r\n                sourceExpr: AST.ExprNode,\r\n                targetType: AST.TypeNode,\r\n                context: string\r\n            ): boolean {\r\n                // Only validate character literal compatibility (value range check)\r\n                if (!this.validateCharacterLiteralCompatibility(sourceExpr, targetType, context)) {\r\n                    return false; // Error already reported\r\n                }\r\n\r\n                // Don't do type compatibility check here - it's done by the caller\r\n                // (validateLetStmt, validateParameter, etc.)\r\n                return true;\r\n            }\r\n\r\n            private unwrapParenType(type: AST.TypeNode): AST.TypeNode {\r\n                while (type.isParen()) {\r\n                    type = type.getParen()!.type;\r\n                }\r\n                return type;\r\n            }\r\n\r\n        // └──────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌──────────────────────────────── ---- ────────────────────────────────┐\r\n\r\n            private isTypeCompatible(target: AST.TypeNode, source: AST.TypeNode, sourceExpr?: AST.ExprNode): boolean {\r\n                this.stats.compatibilityChecks++;\r\n\r\n                // ⚠️ STRICT MODE: Pointer dereference requires EXACT type match\r\n                if (sourceExpr && this.isPointerDereference(sourceExpr)) {\r\n                    const normalizedTarget = this.normalizeType(target);\r\n                    const normalizedSource = this.normalizeType(source);\r\n\r\n                    // For pointer dereference, only allow exact type match (no widening)\r\n                    if (!this.isSameType(normalizedTarget, normalizedSource)) {\r\n                        return false;\r\n                    }\r\n                    // If types match exactly, continue with normal validation\r\n                }\r\n\r\n                // STEP 1: NORMALIZE BOTH TYPES (unwrap parens, etc.)\r\n                const normalizedTarget = this.normalizeType(target);\r\n                const normalizedSource = this.normalizeType(source);\r\n\r\n                // STEP 2: RESOLVE IDENTIFIERS EARLY (Point -> struct, slice -> []u8, etc.)\r\n                const resolvedTarget = this.resolveIdentifierType(normalizedTarget);\r\n                const resolvedSource = this.resolveIdentifierType(normalizedSource);\r\n\r\n                // STEP 3: QUICK CHECKS\r\n\r\n                // 'any' accepts everything\r\n                if (this.isAnyType(resolvedTarget)) return true;\r\n\r\n                // Exact type match\r\n                if (this.isSameType(resolvedTarget, resolvedSource)) return true;\r\n\r\n                // STEP 4: ERROR TYPE HANDLING\r\n\r\n                // 'err' primitive accepts any error type\r\n                if (resolvedTarget.isErr()) {\r\n                    if (this.isErrorType(resolvedSource)) {\r\n                        return true;\r\n                    }\r\n\r\n                    // Check if source is an error identifier\r\n                    if (resolvedSource.isIdent()) {\r\n                        const sourceIdent = resolvedSource.getIdent()!;\r\n                        const sourceSymbol = this.config.services.scopeManager.lookupSymbol(sourceIdent.name);\r\n\r\n                        if (sourceSymbol && sourceSymbol.kind === SymbolKind.Error) {\r\n                            return true;\r\n                        }\r\n                    }\r\n\r\n                    return false;\r\n                }\r\n\r\n                // STEP 5: NUMERIC TYPE HANDLING\r\n\r\n                // Bool is NOT compatible with numeric types\r\n                if (resolvedSource.isBool() && this.isNumericType(resolvedTarget)) {\r\n                    return false;\r\n                }\r\n\r\n                // Numeric compatibility (i32 -> i64, comptime_int -> i32, etc.)\r\n                if (this.isNumericType(resolvedTarget) && this.isNumericType(resolvedSource)) {\r\n                    return this.areNumericTypesCompatible(resolvedTarget, resolvedSource);\r\n                }\r\n\r\n                // STEP 6: UNION TYPE HANDLING\r\n\r\n                // Union to Union: all source types must be compatible with target union\r\n                if (resolvedTarget.isUnion() && resolvedSource.isUnion()) {\r\n                    const targetUnion = resolvedTarget.getUnion()!;\r\n                    const sourceUnion = resolvedSource.getUnion()!;\r\n\r\n                    return sourceUnion.types.every((sourceType: AST.TypeNode) =>\r\n                        targetUnion.types.some((targetType: AST.TypeNode) =>\r\n                            this.isTypeCompatible(targetType, sourceType)\r\n                        )\r\n                    );\r\n                }\r\n\r\n                // Target is Union: check if source matches ANY union member\r\n                if (resolvedTarget.isUnion()) {\r\n                    const unionType = resolvedTarget.getUnion()!;\r\n\r\n                    // PRIORITY 1: Check NORMALIZED source identifier (BEFORE resolution)\r\n                    if (normalizedSource.isIdent()) {\r\n                        const sourceIdent = normalizedSource.getIdent()!;\r\n\r\n                        const identMatch = unionType.types.some((memberType: AST.TypeNode, idx: number) => {\r\n                            if (memberType.isIdent()) {\r\n                                const match = memberType.getIdent()!.name === sourceIdent.name;\r\n                                return match;\r\n                            }\r\n                            return false;\r\n                        });\r\n\r\n                        if (identMatch) {\r\n                            return true;\r\n                        }\r\n                    }\r\n\r\n                    // PRIORITY 2: Check if RESOLVED source is a named struct\r\n                    if (resolvedSource.isStruct()) {\r\n                        const struct = resolvedSource.getStruct()!;\r\n\r\n                        if (struct.name && struct.name !== 'Anonymous') {\r\n                            const structNameMatch = unionType.types.some((memberType: AST.TypeNode, idx: number) => {\r\n                                if (memberType.isIdent()) {\r\n                                    const match = memberType.getIdent()!.name === struct.name;\r\n                                    return match;\r\n                                }\r\n                                return false;\r\n                            });\r\n\r\n                            if (structNameMatch) {\r\n                                return true;\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    // PRIORITY 3: Check RESOLVED source for structural matches\r\n                    const structuralMatch = unionType.types.some((memberType: AST.TypeNode, idx: number) => {\r\n\r\n                        // Resolve the union member type\r\n                        const resolvedMember = this.resolveIdentifierType(memberType);\r\n\r\n                        // For struct types, use specialized structural comparison\r\n                        if (resolvedMember.isStruct() && resolvedSource.isStruct()) {\r\n                            const result = this.areStructsStructurallyCompatible(\r\n                                resolvedMember.getStruct()!,\r\n                                resolvedSource.getStruct()!\r\n                            );\r\n                            return result;\r\n                        }\r\n\r\n                        // For array types, use specialized array comparison\r\n                        if (resolvedMember.isArray() && resolvedSource.isArray()) {\r\n                            const result = this.areArrayTypesCompatible(resolvedMember, resolvedSource);\r\n                            return result;\r\n                        }\r\n\r\n                        // For other types, recursively check compatibility\r\n                        const result = this.isTypeCompatible(resolvedMember, normalizedSource);\r\n                        return result;\r\n                    });\r\n\r\n                    return structuralMatch;\r\n                }\r\n\r\n                // Source is Union: check if ALL source types are compatible with target\r\n                // This handles cases like: let x: i32 = (1 | 2); // union value to single type\r\n                if (resolvedSource.isUnion()) {\r\n                    const sourceUnion = resolvedSource.getUnion()!;\r\n\r\n                    return sourceUnion.types.every((sourceType: AST.TypeNode) =>\r\n                        this.isTypeCompatible(resolvedTarget, sourceType)\r\n                    );\r\n                }\r\n\r\n                // STEP 7: OPTIONAL TYPE HANDLING\r\n\r\n                // Target is optional: accept null/undefined OR unwrapped type\r\n                if (resolvedTarget.isOptional()) {\r\n                    if (resolvedSource.isNull() || resolvedSource.isUndefined()) return true;\r\n\r\n                    const targetInner = resolvedTarget.getOptional()!.target;\r\n                    return this.isTypeCompatible(targetInner, resolvedSource);\r\n                }\r\n\r\n                // Source is optional: for union targets, check if inner type + null are both compatible\r\n                if (resolvedSource.isOptional()) {\r\n                    const sourceInner = resolvedSource.getOptional()!.target;\r\n\r\n                    if (resolvedTarget.isUnion()) {\r\n                        const unionType = resolvedTarget.getUnion()!;\r\n                        const hasInnerType = unionType.types.some((t: AST.TypeNode) =>\r\n                            this.isTypeCompatible(t, sourceInner)\r\n                        );\r\n                        const hasNull = unionType.types.some((t: AST.TypeNode) => t.isNull());\r\n                        return hasInnerType && hasNull;\r\n                    }\r\n\r\n                    // For non-union targets, optional source is not compatible\r\n                    return false;\r\n                }\r\n\r\n                // STEP 8: ARRAY TYPE HANDLING\r\n\r\n                if (resolvedTarget.isArray() && resolvedSource.isArray()) {\r\n                    return this.areArrayTypesCompatible(resolvedTarget, resolvedSource);\r\n                }\r\n\r\n                // STEP 9: POINTER TYPE HANDLING\r\n\r\n                if (resolvedTarget.isPointer()) {\r\n                    if (resolvedSource.isNull()) return true;\r\n\r\n                    if (resolvedSource.isPointer()) {\r\n                        return this.arePointerTypesCompatible(resolvedTarget, resolvedSource);\r\n                    }\r\n\r\n                    return false;\r\n                }\r\n\r\n                // STEP 10: TUPLE TYPE HANDLING\r\n\r\n                if (resolvedTarget.isTuple() && resolvedSource.isTuple()) {\r\n                    return this.areTupleTypesCompatible(resolvedTarget, resolvedSource);\r\n                }\r\n\r\n                // STEP 11: STRUCT TYPE HANDLING\r\n\r\n                if (resolvedTarget.isStruct() && resolvedSource.isStruct()) {\r\n                    return this.areStructTypesCompatible(resolvedTarget, resolvedSource);\r\n                }\r\n\r\n                // STEP 12: ENUM TYPE HANDLING\r\n\r\n                if (resolvedTarget.isEnum() && resolvedSource.isEnum()) {\r\n                    return this.isSameType(resolvedTarget, resolvedSource);\r\n                }\r\n\r\n                // STEP 13: TYPE PRIMITIVE HANDLING\r\n\r\n                // 'type' is a special meta-type\r\n                if (resolvedTarget.isType()) {\r\n                    return true;\r\n                }\r\n\r\n                // STEP 14: NO MATCH\r\n                return false;\r\n            }\r\n\r\n            private isNumericType(type: AST.TypeNode): boolean {\r\n                // Exclude 'type' primitive\r\n                if (this.isTypeType(type)) {\r\n                    return false;\r\n                }\r\n\r\n                return type.isFloat() || type.isSigned() || type.isUnsigned() ||\r\n                       type.isComptimeInt() || type.isComptimeFloat();\r\n            }\r\n\r\n            private isAnyType(type: AST.TypeNode): boolean {\r\n                if (!type.isPrimitive()) return false;\r\n                const prim = type.getPrimitive();\r\n                return prim?.kind === 'any';\r\n            }\r\n\r\n            private isIntegerType(type: AST.TypeNode): boolean {\r\n                return type.isSigned() || type.isUnsigned() || type.isComptimeInt();\r\n            }\r\n\r\n            private isStringType(type: AST.TypeNode): boolean {\r\n                if (!type.isArray()) return false;\r\n                const arrayType = type.getArray()!;\r\n                const elemType = arrayType.target;\r\n                return elemType.isUnsigned() && elemType.getWidth() === 8;\r\n            }\r\n\r\n            private isErrorType(type: AST.TypeNode): boolean {\r\n                // Direct error set: error{A, B, C}\r\n                if (type.isErrset()) {\r\n                    return true;\r\n                }\r\n\r\n                // Error type: check if it resolves to an error type\r\n                if (type.isErr()) { return true; }\r\n\r\n                // Error identifier: check if it resolves to an error type\r\n                if (type.isIdent()) {\r\n                    const ident = type.getIdent()!;\r\n\r\n                    // Try to lookup symbol in current scope chain\r\n                    const symbol = this.config.services.scopeManager.lookupSymbol(ident.name);\r\n\r\n                    if (symbol) {\r\n                        // Check if it's an Error symbol (member of error set)\r\n                        if (symbol.kind === SymbolKind.Error) {\r\n                            return true;\r\n                        }\r\n\r\n                        // Check if it's an error type definition\r\n                        if (symbol.type && symbol.type.isErrset()) {\r\n                            return true;\r\n                        }\r\n                    }\r\n\r\n                    // If not found in current scope chain, check ALL scopes\r\n                    // This handles error members that are in their parent error type's scope\r\n                    const allScopes = this.config.services.scopeManager.getAllScopes();\r\n                    for (const scope of allScopes) {\r\n                        const scopeSymbol = scope.symbols.get(ident.name);\r\n                        if (scopeSymbol && scopeSymbol.kind === SymbolKind.Error) {\r\n                            return true;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                return false;\r\n            }\r\n\r\n            private isSameType(type1: AST.TypeNode, type2: AST.TypeNode): boolean {\r\n                if (type1 === type2) return true;\r\n                if (type1.kind !== type2.kind) return false;\r\n\r\n                switch (type1.kind) {\r\n                    case 'primitive':\r\n                        const prim1 = type1.getPrimitive()!;\r\n                        const prim2 = type2.getPrimitive()!;\r\n                        return prim1.kind === prim2.kind && prim1.width === prim2.width;\r\n\r\n                    case 'array':\r\n                        const arr1 = type1.getArray()!;\r\n                        const arr2 = type2.getArray()!;\r\n                        return this.isSameType(arr1.target, arr2.target);\r\n\r\n                    case 'pointer':\r\n                        const ptr1 = type1.getPointer()!;\r\n                        const ptr2 = type2.getPointer()!;\r\n                        return this.isSameType(ptr1.target, ptr2.target) && ptr1.mutable === ptr2.mutable;\r\n\r\n                    case 'paren':\r\n                        return this.isSameType(type1.getParen()!.type, type2.getParen()!.type);\r\n\r\n                    case 'optional':\r\n                        const opt1 = type1.getOptional()!;\r\n                        const opt2 = type2.getOptional()!;\r\n                        return this.isSameType(opt1.target, opt2.target);\r\n\r\n                    case 'tuple':\r\n                        const tup1 = type1.getTuple()!;\r\n                        const tup2 = type2.getTuple()!;\r\n                        if (tup1.fields.length !== tup2.fields.length) return false;\r\n                        return tup1.fields.every((f: AST.TypeNode, i: number) => this.isSameType(f, tup2.fields[i]));\r\n\r\n                    case 'function':\r\n                        const func1 = type1.getFunction()!;\r\n                        const func2 = type2.getFunction()!;\r\n                        if (func1.params.length !== func2.params.length) return false;\r\n                        if (!func1.params.every((p: AST.TypeNode, i: number) => this.isSameType(p, func2.params[i]))) return false;\r\n                        const ret1 = func1.returnType;\r\n                        const ret2 = func2.returnType;\r\n                        if (ret1 && ret2) return this.isSameType(ret1, ret2);\r\n                        return ret1 === ret2;\r\n\r\n                    case 'ident':\r\n                        const id1 = type1.getIdent()!;\r\n                        const id2 = type2.getIdent()!;\r\n                        return id1.name === id2.name;\r\n\r\n                    default:\r\n                        return false;\r\n                }\r\n            }\r\n\r\n            private promoteNumericTypes(type1: AST.TypeNode, type2: AST.TypeNode, span?: AST.Span): AST.TypeNode {\r\n                if (type1.isComptimeInt() && this.isNumericType(type2)) return type2;\r\n                if (type2.isComptimeInt() && this.isNumericType(type1)) return type1;\r\n                if (type1.isComptimeFloat() && type2.isFloat()) return type2;\r\n                if (type2.isComptimeFloat() && type1.isFloat()) return type1;\r\n\r\n                if (type1.isFloat() || type2.isFloat()) {\r\n                    const width1 = type1.getWidth() ?? 32;\r\n                    const width2 = type2.getWidth() ?? 32;\r\n                    const maxWidth = Math.max(width1, width2);\r\n                    return AST.TypeNode.asFloat(span, `f${maxWidth}`, maxWidth);\r\n                }\r\n\r\n                const width1 = type1.getWidth() ?? 32;\r\n                const width2 = type2.getWidth() ?? 32;\r\n                const maxWidth = Math.max(width1, width2);\r\n\r\n                if (type1.isSigned() || type2.isSigned()) {\r\n                    return AST.TypeNode.asSigned(span, `i${maxWidth}`, maxWidth);\r\n                }\r\n\r\n                return AST.TypeNode.asUnsigned(span, `u${maxWidth}`, maxWidth);\r\n            }\r\n\r\n            private computeUnaryResultType(operandType: AST.TypeNode, isNegation: boolean, span?: AST.Span): AST.TypeNode {\r\n                if (operandType.isComptimeInt()) {\r\n                    const prim = operandType.getPrimitive();\r\n                    const txtStr = prim?.text !== undefined ? String(prim.text) : 'cint';\r\n                    const resultText = isNegation ?\r\n                        (txtStr.startsWith('-') ? txtStr.slice(1) : `-${txtStr}`) : txtStr;\r\n                    return AST.TypeNode.asComptimeInt(span, resultText);\r\n                }\r\n\r\n                if (operandType.isUnsigned() && isNegation) {\r\n                    const width = operandType.getWidth() ?? 32;\r\n                    return AST.TypeNode.asSigned(span, `i${width}`, width);\r\n                }\r\n\r\n                return operandType;\r\n            }\r\n\r\n        // └──────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌──────────────────────────────── ---- ────────────────────────────────┐\r\n\r\n            private arePointerTypesCompatible(target: AST.TypeNode, source: AST.TypeNode): boolean {\r\n                // Use normalizeType instead of unwrapParenType\r\n                const normalizedTarget = this.normalizeType(target);\r\n                const normalizedSource = this.normalizeType(source);\r\n\r\n                const targetPtr = normalizedTarget.getPointer()!;\r\n                const sourcePtr = normalizedSource.getPointer()!;\r\n\r\n                // Normalize the pointer targets as well\r\n                const resolvedTargetBase = this.normalizeType(this.resolveIdentifierType(targetPtr.target));\r\n                const resolvedSourceBase = this.normalizeType(this.resolveIdentifierType(sourcePtr.target));\r\n\r\n                // Special handling for optional: *T -> *?T is allowed\r\n                if (resolvedTargetBase.isOptional()) {\r\n                    const targetInner = resolvedTargetBase.getOptional()!.target;\r\n                    const innerCompatible = this.isSameType(targetInner, resolvedSourceBase);\r\n\r\n                    if (!innerCompatible) {\r\n                        this.reportError(\r\n                            DiagCode.TYPE_MISMATCH,\r\n                            `Cannot assign '${this.getTypeDisplayName(source)}' to variable of type '${this.getTypeDisplayName(target)}'`,\r\n                            source.span\r\n                        );\r\n                        return false;\r\n                    }\r\n                } else {\r\n                    const baseCompatible = this.isSameType(resolvedTargetBase, resolvedSourceBase);\r\n\r\n                    if (!baseCompatible) {\r\n                        this.reportError(\r\n                            DiagCode.TYPE_MISMATCH,\r\n                            `Cannot assign '${this.getTypeDisplayName(source)}' to variable of type '${this.getTypeDisplayName(target)}'`,\r\n                            source.span\r\n                        );\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                if (targetPtr.mutable && !sourcePtr.mutable) {\r\n                    this.reportError(\r\n                        DiagCode.MUTABILITY_MISMATCH,\r\n                        `Cannot assign immutable pointer to mutable pointer variable`,\r\n                        source.span\r\n                    );\r\n                    return false;\r\n                }\r\n\r\n                return true;\r\n            }\r\n\r\n            private areTupleTypesCompatible(target: AST.TypeNode, source: AST.TypeNode): boolean {\r\n                const targetTuple = target.getTuple()!;\r\n                const sourceTuple = source.getTuple()!;\r\n\r\n                if (targetTuple.fields.length !== sourceTuple.fields.length) {\r\n                    return false;\r\n                }\r\n\r\n                for (let i = 0; i < targetTuple.fields.length; i++) {\r\n                    if (!this.isTypeCompatible(targetTuple.fields[i], sourceTuple.fields[i])) {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                return true;\r\n            }\r\n\r\n            private areStructTypesCompatible(target: AST.TypeNode, source: AST.TypeNode): boolean {\r\n                // NEW: Resolve identifiers first\r\n                let resolvedTarget = target;\r\n                let resolvedSource = source;\r\n\r\n                if (target.isIdent()) {\r\n                    const resolved = this.resolveIdentifierType(target);\r\n                    if (resolved.isStruct()) {\r\n                        resolvedTarget = resolved;\r\n                    }\r\n                }\r\n\r\n                if (source.isIdent()) {\r\n                    const resolved = this.resolveIdentifierType(source);\r\n                    if (resolved.isStruct()) {\r\n                        resolvedSource = resolved;\r\n                    }\r\n                }\r\n\r\n                // Now check if both are structs after resolution\r\n                if (!resolvedTarget.isStruct() || !resolvedSource.isStruct()) {\r\n                    return false;\r\n                }\r\n\r\n                const targetStruct = resolvedTarget.getStruct()!;\r\n                const sourceStruct = resolvedSource.getStruct()!;\r\n\r\n                if (targetStruct.metadata?.scopeId !== undefined &&\r\n                    sourceStruct.metadata?.scopeId !== undefined) {\r\n                    return targetStruct.metadata.scopeId === sourceStruct.metadata.scopeId;\r\n                }\r\n\r\n                if (targetStruct.name && targetStruct.name !== 'Anonymous' &&\r\n                    sourceStruct.name && sourceStruct.name !== 'Anonymous') {\r\n                    return targetStruct.name === sourceStruct.name;\r\n                }\r\n\r\n                return this.areStructsStructurallyCompatible(targetStruct, sourceStruct);\r\n            }\r\n\r\n            private areStructsStructurallyCompatible(\r\n                target: AST.StructTypeNode,\r\n                source: AST.StructTypeNode\r\n            ): boolean {\r\n                const targetFields = new Map<string, AST.FieldNode>();\r\n                const sourceFields = new Map<string, AST.FieldNode>();\r\n\r\n                for (const member of target.members) {\r\n                    if (member.isField()) {\r\n                        const field = member.getField()!;\r\n                        targetFields.set(field.ident.name, field);\r\n                    }\r\n                }\r\n\r\n                for (const member of source.members) {\r\n                    if (member.isField()) {\r\n                        const field = member.getField()!;\r\n                        sourceFields.set(field.ident.name, field);\r\n                    }\r\n                }\r\n\r\n                // Check size first\r\n                if (targetFields.size !== sourceFields.size) {\r\n                    return false;\r\n                }\r\n\r\n                // Check each field\r\n                for (const [fieldName, targetField] of targetFields) {\r\n                    const sourceField = sourceFields.get(fieldName);\r\n\r\n                    if (!sourceField) {\r\n                        return false;\r\n                    }\r\n\r\n                    // CRITICAL FIX: Both fields must have types\r\n                    if (!targetField.type || !sourceField.type) {\r\n                        return false;\r\n                    }\r\n\r\n                    // CRITICAL FIX: Use isTypeCompatible, not isSameType\r\n                    // This allows i32 to match comptime_int, etc.\r\n                    if (!this.isTypeCompatible(targetField.type, sourceField.type)) {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                return true;\r\n            }\r\n\r\n            private areNumericTypesCompatible(target: AST.TypeNode, source: AST.TypeNode): boolean {\r\n                // Booleans are NOT numeric types\r\n                if (source.isBool() || target.isBool()) {\r\n                    return false;\r\n                }\r\n\r\n                // **CHECK COMPTIME FIRST - BEFORE ANY WIDTH CHECKS**\r\n                if (source.isComptimeInt() || source.isComptimeFloat()) {\r\n                    // Comptime integers to unsigned must be non-negative\r\n                    if (source.isComptimeInt() && target.isUnsigned()) {\r\n                        const prim = source.getPrimitive();\r\n                        const txtStr = prim?.text !== undefined ? String(prim.text) : '0';\r\n                        try {\r\n                            const value = BigInt(txtStr);\r\n                            if (value < BigInt(0)) {\r\n                                return false;\r\n                            }\r\n                        } catch {\r\n                            return false;\r\n                        }\r\n                    }\r\n\r\n                    // All other comptime conversions are allowed\r\n                    return true;\r\n                }\r\n\r\n                // **NOW CHECK NARROWING - ONLY FOR RUNTIME TYPES**\r\n                const targetWidth = target.getWidth() ?? 64;\r\n                const sourceWidth = source.getWidth() ?? 64;\r\n\r\n                if (sourceWidth > targetWidth) {\r\n                    return false; // Narrowing not allowed\r\n                }\r\n\r\n                return true;\r\n            }\r\n\r\n            private areArrayTypesCompatible(target: AST.TypeNode, source: AST.TypeNode): boolean {\r\n                const targetArray = target.getArray()!;\r\n                const sourceArray = source.getArray()!;\r\n\r\n                // Allow empty array to match any type\r\n                if (sourceArray.target.isUndefined()) {\r\n                    return true;\r\n                }\r\n\r\n                // Check element type compatibility\r\n                if (!this.isTypeCompatible(targetArray.target, sourceArray.target)) {\r\n                    return false;\r\n                }\r\n\r\n                // Check size compatibility (don't report error here - done in validateLetStmt)\r\n                if (targetArray.size && sourceArray.size) {\r\n                    const targetSize = this.ExpressionEvaluator.extractIntegerValue(targetArray.size);\r\n                    const sourceSize = this.ExpressionEvaluator.extractIntegerValue(sourceArray.size);\r\n\r\n                    if (targetSize !== undefined && sourceSize !== undefined) {\r\n                        return targetSize === sourceSize;\r\n                    }\r\n                }\r\n\r\n                return true;\r\n            }\r\n\r\n            private canConvertTypes(source: AST.TypeNode, target: AST.TypeNode): boolean {\r\n                if (source.isIdent()) {\r\n                    const sourceSymbol = this.config.services.scopeManager.lookupSymbol(source.getIdent()!.name);\r\n                    if (sourceSymbol && sourceSymbol.type) {\r\n                        source = sourceSymbol.type;\r\n                    } else {\r\n                        return false;\r\n                    }\r\n                }\r\n                if (target.isIdent()) {\r\n                    const targetSymbol = this.config.services.scopeManager.lookupSymbol(target.getIdent()!.name);\r\n                    if (targetSymbol && targetSymbol.type) {\r\n                        target = targetSymbol.type;\r\n                    } else {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                if (this.isSameType(source, target)) return true;\r\n\r\n                if (this.isNumericType(source) && this.isNumericType(target)) return true;\r\n\r\n                if (source.isComptimeInt() && this.isNumericType(target)) return true;\r\n                if (source.isComptimeFloat() && target.isFloat()) return true;\r\n\r\n                if (source.isPointer() && target.isPointer()) return true;\r\n\r\n                if (this.isIntegerType(source) && target.isPointer()) return true;\r\n\r\n                if (source.isEnum() && this.isIntegerType(target)) return true;\r\n\r\n                return false;\r\n            }\r\n\r\n            private validateValueFitsInType(expr: AST.ExprNode, targetType: AST.TypeNode): void {\r\n                // Handle both integers and floats\r\n                const unwrapped = this.resolveIdentifierType(targetType);\r\n\r\n                // Check if it's an integer type\r\n                if (unwrapped.isSigned() || unwrapped.isUnsigned() || unwrapped.isComptimeInt()) {\r\n                    const value = this.ExpressionEvaluator.evaluateComptimeExpression(expr, targetType);\r\n                    // Value check already done in evaluateComptimeExpression\r\n                    return;\r\n                }\r\n\r\n                // Check if it's a float type\r\n                if (unwrapped.isFloat() || unwrapped.isComptimeFloat()) {\r\n                    const value = this.ExpressionEvaluator.evaluateComptimeFloat(expr, targetType);\r\n                    // Value check already done in evaluateComptimeFloat\r\n                    return;\r\n                }\r\n\r\n                // Not a numeric type - no validation needed\r\n            }\r\n\r\n            private isValidThrowType(thrownType: AST.TypeNode, functionErrorType: AST.TypeNode, span: AST.Span): boolean {\r\n                // Resolve the error type if it's an identifier\r\n                const resolvedErrorType = this.resolveIdentifierType(functionErrorType);\r\n\r\n                // CASE 1: Function expects errset\r\n                if (resolvedErrorType.isErrset()) {\r\n                    const errorSet = resolvedErrorType.getErrset()!;\r\n\r\n                    // If throwing an identifier, check if it's a member of the error set\r\n                    if (thrownType.isIdent()) {\r\n                        const thrownIdent = thrownType.getIdent()!;\r\n                        const isMember = errorSet.members.some(member => member.name === thrownIdent.name);\r\n                        return isMember;\r\n                    }\r\n\r\n                    return false;\r\n                }\r\n\r\n                // CASE 2: Function expects err primitive type\r\n                if (resolvedErrorType.isPrimitive()) {\r\n                    const prim = resolvedErrorType.getPrimitive();\r\n                    if (prim?.kind === 'err') {\r\n                        // The error name is stored in text field\r\n                        // Compare with thrown type's name\r\n                        if (thrownType.isIdent()) {\r\n                            return thrownType.getIdent()!.name === prim.text;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                return true;\r\n            }\r\n\r\n        // └──────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌──────────────────────────────── ---- ────────────────────────────────┐\r\n\r\n            private extractTypeFromInitializer(expr: AST.ExprNode): AST.TypeNode | null {\r\n                if (expr.kind !== 'Primary') return null;\r\n\r\n                const primary = expr.getPrimary();\r\n                if (!primary || primary.kind !== 'Type') return null;\r\n\r\n                return primary.getType();\r\n            }\r\n\r\n            private extractSymbolFromExpression(expr: AST.ExprNode): Symbol | null {\r\n                if (expr.is('Primary')) {\r\n                    const primary = expr.getPrimary();\r\n                    if (primary?.is('Ident')) {\r\n                        const ident = primary.getIdent();\r\n                        if (ident) {\r\n                            return this.config.services.scopeManager.lookupSymbol(ident.name);\r\n                        }\r\n                    }\r\n                }\r\n                return null;\r\n            }\r\n\r\n            private extractBuiltinName(expr: AST.ExprNode): string | null {\r\n                if (expr.kind !== 'Primary') return null;\r\n                const primary = expr.getPrimary();\r\n                if (!primary || primary.kind !== 'Ident') return null;\r\n                const ident = primary.getIdent();\r\n                return (ident?.name ? '@'+ident.name : null) || null;\r\n            }\r\n\r\n            private extractMemberName(memberExpr: AST.ExprNode): string | null {\r\n                switch (memberExpr.kind) {\r\n                    case 'Primary': {\r\n                        const src = memberExpr.getPrimary()!;\r\n                        if (src.kind === 'Ident') {\r\n                            return src.getIdent()!.name;\r\n                        }\r\n                        return null;\r\n                    }\r\n\r\n                    case 'Prefix': {\r\n                        const src = memberExpr.getPrefix()!;\r\n                        return this.extractMemberName(src.expr);\r\n                    }\r\n\r\n                    case 'Postfix': {\r\n                        const src = memberExpr.getPostfix()!;\r\n\r\n                        switch (src.kind) {\r\n                            case 'MemberAccess': {\r\n                                const access = src.getMemberAccess()!;\r\n                                return this.extractMemberName(access.target);\r\n                            }\r\n\r\n                            case 'Call': {\r\n                                const call = src.getCall()!;\r\n                                return this.extractMemberName(call.base);\r\n                            }\r\n\r\n                            case 'ArrayAccess': {\r\n                                const index = src.getArrayAccess()!;\r\n                                return this.extractMemberName(index.base);\r\n                            }\r\n\r\n                            case 'Increment':\r\n                            case 'Decrement':\r\n                            case 'Dereference': {\r\n                                return this.extractMemberName(src.getAsExprNode()!);\r\n                            }\r\n\r\n                            default:\r\n                                return null;\r\n                        }\r\n                    }\r\n\r\n                    case 'Binary':\r\n                    case 'As':\r\n                    case 'Orelse':\r\n                    case 'Range':\r\n                    case 'Try':\r\n                    case 'Catch':\r\n                    case 'If':\r\n                    case 'Match':\r\n                    case 'Typeof':\r\n                    case 'Sizeof':\r\n                        return null;\r\n\r\n                    default:\r\n                        this.log('verbose', `Cannot extract member name from expression kind: ${memberExpr.kind}`);\r\n                        return null;\r\n                }\r\n            }\r\n\r\n            private extractEnumVariantName(expr: AST.ExprNode): string | null {\r\n                if (expr.is('Postfix')) {\r\n                    const postfix = expr.getPostfix();\r\n                    if (postfix?.kind === 'MemberAccess') {\r\n                        const access = postfix.getMemberAccess()!;\r\n                        return this.extractMemberName(access.target);\r\n                    }\r\n                }\r\n                return null;\r\n            }\r\n\r\n            private extractTypeName(typeNode: AST.TypeNode): string | null {\r\n                if (typeNode.isIdent()) {\r\n                    return typeNode.getIdent()!.name;\r\n                }\r\n                if (typeNode.isStruct()) {\r\n                    return typeNode.getStruct()!.name || null;\r\n                }\r\n                return null;\r\n            }\r\n\r\n            private normalizeType(type: AST.TypeNode): AST.TypeNode {\r\n                // Unwrap all paren layers\r\n                while (type.isParen()) {\r\n                    type = type.getParen()!.type;\r\n                }\r\n\r\n                // Recursively normalize nested types\r\n                switch (type.kind) {\r\n                    case 'pointer': {\r\n                        const ptr = type.getPointer()!;\r\n                        const normalizedTarget = this.normalizeType(ptr.target);\r\n\r\n                        // Only create new node if target changed\r\n                        if (normalizedTarget !== ptr.target) {\r\n                            return AST.TypeNode.asPointer(type.span, normalizedTarget, ptr.mutable);\r\n                        }\r\n                        return type;\r\n                    }\r\n\r\n                    case 'optional': {\r\n                        const opt = type.getOptional()!;\r\n                        const normalizedTarget = this.normalizeType(opt.target);\r\n\r\n                        if (normalizedTarget !== opt.target) {\r\n                            return AST.TypeNode.asOptional(type.span, normalizedTarget);\r\n                        }\r\n                        return type;\r\n                    }\r\n\r\n                    case 'array': {\r\n                        const arr = type.getArray()!;\r\n                        const normalizedTarget = this.normalizeType(arr.target);\r\n\r\n                        if (normalizedTarget !== arr.target) {\r\n                            return AST.TypeNode.asArray(type.span, normalizedTarget, arr.size);\r\n                        }\r\n                        return type;\r\n                    }\r\n\r\n                    case 'tuple': {\r\n                        const tuple = type.getTuple()!;\r\n                        const normalizedFields = tuple.fields.map(f => this.normalizeType(f));\r\n\r\n                        // Check if any field changed\r\n                        const hasChanges = normalizedFields.some((nf, i) => nf !== tuple.fields[i]);\r\n                        if (hasChanges) {\r\n                            return AST.TypeNode.asTuple(type.span, normalizedFields);\r\n                        }\r\n                        return type;\r\n                    }\r\n\r\n                    case 'function': {\r\n                        const func = type.getFunction()!;\r\n                        const normalizedParams = func.params.map(p => this.normalizeType(p));\r\n                        const normalizedReturn = func.returnType ? this.normalizeType(func.returnType) : null;\r\n\r\n                        const hasChanges = normalizedParams.some((np, i) => np !== func.params[i]) ||\r\n                                        (normalizedReturn && normalizedReturn !== func.returnType);\r\n\r\n                        if (hasChanges) {\r\n                            return AST.TypeNode.asFunction(\r\n                                type.span,\r\n                                normalizedParams,\r\n                                normalizedReturn || undefined\r\n                            );\r\n                        }\r\n                        return type;\r\n                    }\r\n\r\n                    case 'union': {\r\n                        const union = type.getUnion()!;\r\n                        const normalizedTypes = union.types.map(t => this.normalizeType(t));\r\n\r\n                        const hasChanges = normalizedTypes.some((nt, i) => nt !== union.types[i]);\r\n                        if (hasChanges) {\r\n                            return AST.TypeNode.asUnion(type.span, normalizedTypes);\r\n                        }\r\n                        return type;\r\n                    }\r\n\r\n                    default:\r\n                        return type;\r\n                }\r\n            }\r\n\r\n        // └──────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌──────────────────────────────── ---- ────────────────────────────────┐\r\n\r\n            private findModuleScope(moduleName: string): Scope | null {\r\n                const moduleScope = this.config.services.scopeManager.findScopeByName(moduleName, ScopeKind.Module);\r\n                if (!moduleScope) {\r\n                    this.reportError(DiagCode.MODULE_SCOPE_NOT_FOUND, `Module scope for '${moduleName}' not found`);\r\n                }\r\n                return moduleScope;\r\n            }\r\n\r\n            private findCallTargetSymbol(baseExpr: AST.ExprNode): Symbol | null {\r\n                if (baseExpr.is('Primary')) {\r\n                    const primary = baseExpr.getPrimary();\r\n\r\n                    if (primary?.is('Ident')) {\r\n                        const ident = primary.getIdent();\r\n                        if (ident && !ident.builtin) {\r\n                            return this.config.services.scopeManager.lookupSymbol(ident.name);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                return null;\r\n            }\r\n\r\n        // └──────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌──────────────────────────────── ---- ────────────────────────────────┐\r\n\r\n            private isBuiltinFunction(baseExpr: AST.ExprNode): boolean {\r\n                if (baseExpr.isIdent()) {\r\n                    const ident = baseExpr.getIdent();\r\n                    return ident?.builtin === true || (ident?.name.startsWith('@') === true);\r\n                }\r\n\r\n                return false;\r\n            }\r\n\r\n            private isInsideFunctionScope(): boolean {\r\n                let currentScope = this.config.services.scopeManager.getCurrentScope();\r\n\r\n                while (currentScope) {\r\n                    if (currentScope.kind === ScopeKind.Function) {\r\n                        return true;\r\n                    }\r\n\r\n                    // Don't stop at Type scopes - they can contain methods\r\n                    // Only stop at Module boundaries\r\n                    if (currentScope.kind === ScopeKind.Module || currentScope.kind === ScopeKind.Global) {\r\n                        return false;\r\n                    }\r\n\r\n                    // Walk up the scope chain\r\n                    if (currentScope.parent !== null) {\r\n                        try {\r\n                            currentScope = this.config.services.scopeManager.getScope(currentScope.parent);\r\n                        } catch {\r\n                            return false;\r\n                        }\r\n                    } else {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                return false;\r\n            }\r\n\r\n            private isBoolLiteral(expr: AST.ExprNode | undefined, value: boolean): boolean {\r\n                if (!expr || !expr.is('Primary')) return false;\r\n\r\n                const primary = expr.getPrimary();\r\n                if (!primary?.is('Literal')) return false;\r\n\r\n                const literal = primary.getLiteral();\r\n                return literal?.kind === 'Bool' && literal.value === value;\r\n            }\r\n\r\n        // └──────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌──────────────────────────────── ---- ────────────────────────────────┐\r\n\r\n            private createCacheKey(expr: AST.ExprNode): string {\r\n                const moduleName = this.config.services.contextTracker.getModuleName() || 'unknown';\r\n                const span = expr.span || { start: 0, end: 0 };\r\n                return `${moduleName}:${span.start}:${span.end}:${expr.kind}`;\r\n            }\r\n\r\n            private cacheType(key: string, type: AST.TypeNode): void {\r\n                if (this.typeCtx.typeCache.size >= this.CACHE_MAX_SIZE) {\r\n                    const entries = Array.from(this.typeCtx.typeCache.entries());\r\n                    const toKeep = entries.slice(-Math.floor(this.CACHE_MAX_SIZE / 2));\r\n                    this.typeCtx.typeCache.clear();\r\n                    toKeep.forEach(([k, v]) => this.typeCtx.typeCache.set(k, v));\r\n                }\r\n\r\n                this.typeCtx.typeCache.set(key, type || null);\r\n            }\r\n\r\n        // └──────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌──────────────────────────────── ---- ────────────────────────────────┐\r\n\r\n            private init(): boolean {\r\n                this.config.services.contextTracker.reset();\r\n                this.config.services.contextTracker.setPhase(AnalysisPhase.TypeValidation);\r\n\r\n                const globalScope = this.config.services.scopeManager.getGlobalScope();\r\n                this.config.services.scopeManager.setCurrentScope(globalScope.id);\r\n                this.config.services.contextTracker.setScope(globalScope.id);\r\n\r\n                this.log('verbose', 'Type validation initialized');\r\n                return true;\r\n            }\r\n\r\n            private initStats(): TypeValidationStats {\r\n                return {\r\n                    modulesProcessed        : 0,\r\n                    typesInferred           : 0,\r\n                    typesCached             : 0,\r\n                    compatibilityChecks     : 0,\r\n                    callsValidated          : 0,\r\n                    memberAccessValidated   : 0,\r\n                    assignmentsValidated    : 0,\r\n                    returnsValidated        : 0,\r\n                    errors                  : 0,\r\n                    startTime               : Date.now()\r\n                };\r\n            }\r\n\r\n            private initTypeValidatorContext(): TypeValidatorContext {\r\n                return {\r\n                    currentModule   : '',\r\n                    moduleStack     : [],\r\n                    typeCache       : new Map(),\r\n                };\r\n            }\r\n\r\n            private getTypeDisplayName(type: AST.TypeNode): string {\r\n                // Handle pointer types\r\n                if (type.isPointer()) {\r\n                    const ptr = type.getPointer()!;\r\n                    const targetName = this.getTypeDisplayName(ptr.target);\r\n                    return ptr.mutable ? `*mut ${targetName}` : `*${targetName}`;\r\n                }\r\n\r\n                // Handle optional types\r\n                if (type.isOptional()) {\r\n                    const opt = type.getOptional()!;\r\n                    const targetName = this.getTypeDisplayName(opt.target);\r\n                    return `?${targetName}`;\r\n                }\r\n\r\n                // Handle array types\r\n                if (type.isArray()) {\r\n                    const arr = type.getArray()!;\r\n                    const targetName = this.getTypeDisplayName(arr.target);\r\n                    // return `[${arr.size ? '...' : ''}]${targetName}`;\r\n                    return `[]${targetName}`;\r\n                }\r\n\r\n                // Resolve identifier types first\r\n                const resolved = this.resolveIdentifierType(type);\r\n\r\n                // NEW: Handle slice type alias specially\r\n                if (this.isStringType(resolved)) {\r\n                    return 'slice';\r\n                }\r\n\r\n                // Check for struct with a name\r\n                if (resolved.isStruct()) {\r\n                    const struct = resolved.getStruct()!;\r\n                    if (struct.name && struct.name !== 'Anonymous') {\r\n                        return struct.name;\r\n                    }\r\n                    return 'struct';\r\n                }\r\n\r\n                // Check for enum with a name\r\n                if (resolved.isEnum()) {\r\n                    const enumType = resolved.getEnum()!;\r\n                    if (enumType.name && enumType.name !== 'Anonymous') {\r\n                        return enumType.name;\r\n                    }\r\n                    return 'enum';\r\n                }\r\n\r\n                // Check for identifier (type alias)\r\n                if (type.isIdent()) {\r\n                    return type.getIdent()!.name;\r\n                }\r\n\r\n                // Fall back to toString()\r\n                return type.toString();\r\n            }\r\n\r\n        // └──────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌──────────────────────────────── ---- ────────────────────────────────┐\r\n\r\n            logStatistics(): void {\r\n                const duration = Date.now() - this.stats.startTime;\r\n                this.log('verbose',\r\n                    `Type Validation Statistics :\\n` +\r\n                    `  Duration                 : ${duration}ms\\n` +\r\n                    `  Types inferred           : ${this.stats.typesInferred}\\n` +\r\n                    `  Types cached             : ${this.stats.typesCached}\\n` +\r\n                    `  Compatibility checks     : ${this.stats.compatibilityChecks}\\n` +\r\n                    `  Calls validated          : ${this.stats.callsValidated}\\n` +\r\n                    `  Member access validated  : ${this.stats.memberAccessValidated}\\n` +\r\n                    `  Assignments validated    : ${this.stats.assignmentsValidated}\\n` +\r\n                    `  Returns validated        : ${this.stats.returnsValidated}\\n` +\r\n                    `  Cache size               : ${this.typeCtx.typeCache.size}\\n` +\r\n                    `  Errors                   : ${this.stats.errors}`\r\n                );\r\n            }\r\n\r\n        // └──────────────────────────────────────────────────────────────────────┘\r\n\r\n    }\r\n\r\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ExpressionEvaluator.ts — Compile-time expression evaluation.\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import * as AST                 from '@je-es/ast';\n    import { DiagCode }             from './DiagnosticManager';\n    import { AnalysisConfig }       from '../ast-analyzer';\n    import { Scope, Symbol, SymbolKind, ScopeKind }\n                                    from './ScopeManager';\n    import { DebugKind }            from './DebugManager';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ TYPE ════════════════════════════════════════╗\n\n    export type ComptimeValue = bigint | number | boolean | null;\n\n    export interface EvaluationResult {\n        value: ComptimeValue;\n        type: 'int' | 'float' | 'bool' | 'null';\n    }\n\n    export interface EvaluationContext {\n        allowFloats: boolean;\n        maxIntValue: bigint;\n        minIntValue: bigint;\n        targetType?: AST.TypeNode;  // For size-aware validation\n    }\n\n    type LocalVariableMap = Map<string, EvaluationResult>;\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class ExpressionEvaluator {\n\n        // ┌──────────────────────────────── INIT ────────────────────────────────┐\n\n            private readonly MAX_INT_64 = BigInt('9223372036854775807'); // i64::MAX\n            private readonly MIN_INT_64 = BigInt('-9223372036854775808'); // i64::MIN\n\n            private comptimeResultCache = new Map<string, EvaluationResult>();\n\n            constructor(public config: AnalysisConfig) {}\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ────────────────────────────────┐\n\n            evaluateComptimeExpression(expr: AST.ExprNode, targetType?: AST.TypeNode): bigint | null {\n                // Check if target is float type - return early\n                if (targetType && this.isFloatTargetType(targetType)) {\n                    return null;\n                }\n\n                const bounds = this.getTypeBounds(targetType);\n\n                const result = this.evaluateExpression(expr, {\n                    allowFloats: false,\n                    maxIntValue: this.MAX_INT_64,\n                    minIntValue: this.MIN_INT_64,\n                    targetType\n                });\n\n                if (!result) return null;\n\n                if (result.type !== 'int') {\n                    return null;\n                }\n\n                const value = result.value as bigint;\n\n                // Check bounds AFTER evaluation\n                if (targetType && (value < bounds.min || value > bounds.max)) {\n                    this.reportError(\n                        DiagCode.ARITHMETIC_OVERFLOW,\n                        `Value ${value} does not fit in type '${targetType.toString()}' (valid range: ${bounds.min} to ${bounds.max})`,\n                        expr.span\n                    );\n                    return null;\n                }\n\n                return value;\n            }\n\n            evaluateComptimeFloat(expr: AST.ExprNode, targetType?: AST.TypeNode): number | null {\n                const result = this.evaluateExpression(expr, {\n                    allowFloats: true,\n                    maxIntValue: this.MAX_INT_64,\n                    minIntValue: this.MIN_INT_64,\n                    targetType\n                });\n\n                if (!result) return null;\n\n                // Convert to float if needed\n                if (result.type === 'int') {\n                    return Number(result.value);\n                }\n\n                if (result.type === 'float') {\n                    const value = result.value as number;\n\n                    // Validate float bounds if target type specified\n                    if (targetType) {\n                        const bounds = this.getFloatBounds(targetType);\n                        if (value < bounds.min || value > bounds.max) {\n                            this.reportError(\n                                DiagCode.ARITHMETIC_OVERFLOW,\n                                `Float value ${value} does not fit in type '${targetType.toString()}'`,\n                                expr.span\n                            );\n                            return null;\n                        }\n                    }\n\n                    return value;\n                }\n\n                return null;\n            }\n\n            evaluateComptimeValue(expr: AST.ExprNode, targetType?: AST.TypeNode): ComptimeValue | null {\n                const allowFloats = !targetType || !this.isIntegerTargetType(targetType);\n\n                const result = this.evaluateExpression(expr, {\n                    allowFloats,\n                    maxIntValue: this.MAX_INT_64,\n                    minIntValue: this.MIN_INT_64,\n                    targetType\n                });\n\n                return result ? result.value : null;\n            }\n\n            evaluateExpression(expr: AST.ExprNode, ctx?: EvaluationContext): EvaluationResult | null {\n                const context = ctx || {\n                    allowFloats: true,\n                    maxIntValue: this.MAX_INT_64,\n                    minIntValue: this.MIN_INT_64\n                };\n\n                try {\n                    switch (expr.kind) {\n                        case 'Primary':\n                            return this.evaluatePrimary(expr.getPrimary()!, context);\n                        case 'Binary':\n                            return this.evaluateBinary(expr.getBinary()!, context);\n                        case 'Prefix':\n                            return this.evaluatePrefix(expr.getPrefix()!, context);\n                        case 'Postfix': {\n                            const postfix = expr.getPostfix();\n\n                            if (postfix?.kind === 'Call') {\n                                return this.evaluateComptimeFunctionCall(postfix.getCall()!, context);\n                            }\n\n                            return null;\n                        }\n                        case 'As':\n                            return this.evaluateAs(expr.getAs()!, context);\n                        case 'Sizeof':\n                            return this.evaluateSizeof(expr.getSizeof()!, context);\n                        default:\n                            return null;\n                    }\n                } catch (error) {\n                    this.reportError(\n                        DiagCode.ANALYSIS_ERROR,\n                        `Error evaluating compile-time expression: ${error}`,\n                        expr.span\n                    );\n                    return null;\n                }\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── PRIMARY ──────────────────────────────┐\n\n            private evaluatePrimary(primary: AST.PrimaryNode, ctx: EvaluationContext): EvaluationResult | null {\n                switch (primary.kind) {\n                    case 'Literal':\n                        return this.evaluateLiteral(primary.getLiteral()!, ctx);\n                    case 'Ident':\n                        return this.evaluateIdentifier(primary.getIdent()!, ctx);\n                    case 'Paren': {\n                        const paren = primary.getParen()!;\n                        return paren.source ? this.evaluateExpression(paren.source, ctx) : null;\n                    }\n                    default:\n                        return null;\n                }\n            }\n\n            private evaluateLiteral(literal: AST.LiteralNode, ctx: EvaluationContext): EvaluationResult | null {\n                switch (literal.kind) {\n                    case 'Integer': {\n                        try {\n                            const value = BigInt(literal.value as string);\n                            return { value, type: 'int' };\n                        } catch {\n                            this.reportError(\n                                DiagCode.ANALYSIS_ERROR,\n                                `Invalid integer literal: ${literal.value}`,\n                                literal.span\n                            );\n                            return null;\n                        }\n                    }\n\n                    case 'Float': {\n                        if (!ctx.allowFloats) {\n                            this.reportError(\n                                DiagCode.TYPE_MISMATCH,\n                                'Float literals not allowed in integer-only context',\n                                literal.span\n                            );\n                            return null;\n                        }\n\n                        try {\n                            const value = parseFloat(literal.value as string);\n\n                            if (!isFinite(value)) {\n                                this.reportError(\n                                    DiagCode.ARITHMETIC_OVERFLOW,\n                                    'Float literal out of valid range',\n                                    literal.span\n                                );\n                                return null;\n                            }\n\n                            return { value, type: 'float' };\n                        } catch {\n                            this.reportError(\n                                DiagCode.ANALYSIS_ERROR,\n                                `Invalid float literal: ${literal.value}`,\n                                literal.span\n                            );\n                            return null;\n                        }\n                    }\n\n                    case 'Character': {\n                        const charValue = literal.value as string;\n\n                        if (charValue.length === 0) {\n                            return { value: BigInt(0), type: 'int' };\n                        }\n\n                        const codePoint = charValue.codePointAt(0) || 0;\n\n                        if (codePoint > 127) {\n                            if (codePoint > 0x1FFFFF) {\n                                this.reportError(\n                                    DiagCode.ARITHMETIC_OVERFLOW,\n                                    `Character code point ${codePoint} exceeds u21 maximum (2,097,151)`,\n                                    literal.span\n                                );\n                                return null;\n                            }\n                        }\n\n                        return { value: BigInt(codePoint), type: 'int' };\n                    }\n\n                    case 'Bool':\n                        return { value: literal.value as boolean, type: 'bool' };\n\n                    case 'Null':\n                        return { value: null, type: 'null' };\n\n                    default:\n                        return null;\n                }\n            }\n\n            private evaluateIdentifier(ident: AST.IdentNode, ctx: EvaluationContext): EvaluationResult | null {\n                const symbol = this.config.services.scopeManager.lookupSymbol(ident.name);\n                if (!symbol) return null;\n\n                if (symbol.kind !== SymbolKind.Definition && symbol.kind !== SymbolKind.Variable) {\n                    return null;\n                }\n\n                if (symbol.mutability.kind !== 'Immutable') {\n                    return null;\n                }\n\n                if (symbol.metadata && typeof symbol.metadata === 'object') {\n                    const metadata = symbol.metadata as any;\n                    if (metadata.initializer) {\n                        return this.evaluateExpression(metadata.initializer, ctx);\n                    }\n                }\n\n                return null;\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── BINARY ──────────────────────────────┐\n\n            private evaluateBinary(binary: AST.BinaryNode, ctx: EvaluationContext): EvaluationResult | null {\n                const left = this.evaluateExpression(binary.left, ctx);\n                const right = this.evaluateExpression(binary.right, ctx);\n\n                if (!left || !right) return null;\n\n                if (!this.areTypesCompatible(left.type, right.type, binary.kind)) {\n                    this.reportError(\n                        DiagCode.TYPE_MISMATCH,\n                        `Cannot perform ${binary.kind} operation on incompatible types '${left.type}' and '${right.type}'`,\n                        binary.span\n                    );\n                    return null;\n                }\n\n                switch (binary.kind) {\n                    case 'Additive':\n                        return this.evaluateAdditive(left, right, binary.operator, binary.span);\n                    case 'Multiplicative':\n                        return this.evaluateMultiplicative(left, right, binary.operator, binary.span);\n                    case 'Power':\n                        return this.evaluatePower(left, right, binary.span);\n                    case 'Shift':\n                        return this.evaluateShift(left, right, binary.operator, binary.span);\n                    case 'BitwiseAnd':\n                    case 'BitwiseXor':\n                    case 'BitwiseOr':\n                        return this.evaluateBitwise(left, right, binary.kind, binary.span);\n                    case 'Relational':\n                    case 'Equality':\n                        return this.evaluateComparison(left, right, binary.operator, binary.span);\n                    case 'LogicalAnd':\n                    case 'LogicalOr':\n                        return this.evaluateLogical(left, right, binary.kind, binary.span);\n                    default:\n                        return null;\n                }\n            }\n\n            private evaluateAdditive(\n                left: EvaluationResult,\n                right: EvaluationResult,\n                op: string,\n                span: AST.Span\n            ): EvaluationResult | null {\n                if (left.type === 'bool' || right.type === 'bool') {\n                    this.reportError(\n                        DiagCode.TYPE_MISMATCH,\n                        `Cannot perform ${op === '+' ? 'addition' : 'subtraction'} on boolean type`,\n                        span\n                    );\n                    return null;\n                }\n\n                if (left.type === 'float' || right.type === 'float') {\n                    const l = this.toFloat(left);\n                    const r = this.toFloat(right);\n                    const result = op === '+' ? l + r : l - r;\n\n                    if (!isFinite(result)) {\n                        this.reportError(\n                            DiagCode.ARITHMETIC_OVERFLOW,\n                            `Float ${op === '+' ? 'addition' : 'subtraction'} overflow`,\n                            span\n                        );\n                        return null;\n                    }\n\n                    return { value: result, type: 'float' };\n                }\n\n                const l = left.value as bigint;\n                const r = right.value as bigint;\n\n                try {\n                    const result = op === '+' ? l + r : l - r;\n\n                    if (result > this.MAX_INT_64 || result < this.MIN_INT_64) {\n                        this.reportError(\n                            DiagCode.ARITHMETIC_OVERFLOW,\n                            `Integer ${op === '+' ? 'addition' : 'subtraction'} overflow: ${l} ${op} ${r} = ${result}`,\n                            span\n                        );\n                        return null;\n                    }\n\n                    return { value: result, type: 'int' };\n                } catch {\n                    this.reportError(\n                        DiagCode.ARITHMETIC_OVERFLOW,\n                        `Integer ${op === '+' ? 'addition' : 'subtraction'} overflow`,\n                        span\n                    );\n                    return null;\n                }\n            }\n\n            private evaluateMultiplicative(\n                left: EvaluationResult,\n                right: EvaluationResult,\n                op: string,\n                span: AST.Span\n            ): EvaluationResult | null {\n                if (left.type === 'bool' || right.type === 'bool') {\n                    this.reportError(\n                        DiagCode.TYPE_MISMATCH,\n                        `Cannot perform multiplication/division on boolean type`,\n                        span\n                    );\n                    return null;\n                }\n\n                if (left.type === 'float' || right.type === 'float') {\n                    const l = this.toFloat(left);\n                    const r = this.toFloat(right);\n\n                    if ((op === '/' || op === '%') && r === 0) {\n                        this.reportError(\n                            DiagCode.DIVISION_BY_ZERO,\n                            `${op === '/' ? 'Division' : 'Modulo'} by zero in compile-time expression`,\n                            span\n                        );\n                        return null;\n                    }\n\n                    let result: number;\n                    switch (op) {\n                        case '*': result = l * r; break;\n                        case '/': result = l / r; break;\n                        case '%': result = l % r; break;\n                        default: return null;\n                    }\n\n                    if (!isFinite(result)) {\n                        this.reportError(\n                            DiagCode.ARITHMETIC_OVERFLOW,\n                            `Float ${op} overflow`,\n                            span\n                        );\n                        return null;\n                    }\n\n                    return { value: result, type: 'float' };\n                }\n\n                const l = left.value as bigint;\n                const r = right.value as bigint;\n\n                if ((op === '/' || op === '%') && r === BigInt(0)) {\n                    this.reportError(\n                        DiagCode.DIVISION_BY_ZERO,\n                        `${op === '/' ? 'Division' : 'Modulo'} by zero in compile-time expression`,\n                        span\n                    );\n                    return null;\n                }\n\n                try {\n                    let result: bigint;\n                    switch (op) {\n                        case '*': result = l * r; break;\n                        case '/': result = l / r; break;\n                        case '%': result = l % r; break;\n                        default: return null;\n                    }\n\n                    if (result > this.MAX_INT_64 || result < this.MIN_INT_64) {\n                        this.reportError(\n                            DiagCode.ARITHMETIC_OVERFLOW,\n                            `Integer ${op} overflow: ${l} ${op} ${r}`,\n                            span\n                        );\n                        return null;\n                    }\n\n                    return { value: result, type: 'int' };\n                } catch {\n                    this.reportError(\n                        DiagCode.ARITHMETIC_OVERFLOW,\n                        `Integer ${op} overflow`,\n                        span\n                    );\n                    return null;\n                }\n            }\n\n            private evaluatePower(\n                left: EvaluationResult,\n                right: EvaluationResult,\n                span: AST.Span\n            ): EvaluationResult | null {\n                if (left.type === 'float' || right.type === 'float') {\n                    const l = this.toFloat(left);\n                    const r = this.toFloat(right);\n                    const result = Math.pow(l, r);\n\n                    if (!isFinite(result)) {\n                        this.reportError(\n                            DiagCode.ARITHMETIC_OVERFLOW,\n                            'Float power overflow',\n                            span\n                        );\n                        return null;\n                    }\n\n                    return { value: result, type: 'float' };\n                }\n\n                const base = left.value as bigint;\n                const exp = right.value as bigint;\n\n                if (exp < BigInt(0)) {\n                    this.reportError(\n                        DiagCode.ANALYSIS_ERROR,\n                        'Negative exponent not allowed in compile-time integer expression',\n                        span\n                    );\n                    return null;\n                }\n\n                if (exp > BigInt(10000)) {\n                    this.reportError(\n                        DiagCode.ARITHMETIC_OVERFLOW,\n                        'Exponent too large for compile-time evaluation',\n                        span\n                    );\n                    return null;\n                }\n\n                try {\n                    const result = base ** exp;\n\n                    if (result > this.MAX_INT_64 || result < this.MIN_INT_64) {\n                        this.reportError(\n                            DiagCode.ARITHMETIC_OVERFLOW,\n                            `Integer power overflow: ${base} ** ${exp}`,\n                            span\n                        );\n                        return null;\n                    }\n\n                    return { value: result, type: 'int' };\n                } catch {\n                    this.reportError(\n                        DiagCode.ARITHMETIC_OVERFLOW,\n                        'Integer power overflow',\n                        span\n                    );\n                    return null;\n                }\n            }\n\n            private evaluateShift(\n                left: EvaluationResult,\n                right: EvaluationResult,\n                op: string,\n                span: AST.Span\n            ): EvaluationResult | null {\n                if (left.type !== 'int' || right.type !== 'int') {\n                    this.reportError(\n                        DiagCode.TYPE_MISMATCH,\n                        'Shift operations require integer operands',\n                        span\n                    );\n                    return null;\n                }\n\n                const value = left.value as bigint;\n                const shift = right.value as bigint;\n\n                if (shift < BigInt(0)) {\n                    this.reportError(\n                        DiagCode.ANALYSIS_ERROR,\n                        'Negative shift amount not allowed',\n                        span\n                    );\n                    return null;\n                }\n\n                if (shift > BigInt(63)) {\n                    this.reportError(\n                        DiagCode.ANALYSIS_ERROR,\n                        'Shift amount too large (max 63 bits)',\n                        span\n                    );\n                    return null;\n                }\n\n                const shiftNum = Number(shift);\n                const result = op === '<<' ? value << BigInt(shiftNum) : value >> BigInt(shiftNum);\n\n                return { value: result, type: 'int' };\n            }\n\n            private evaluateBitwise(\n                left: EvaluationResult,\n                right: EvaluationResult,\n                op: 'BitwiseAnd' | 'BitwiseXor' | 'BitwiseOr',\n                span: AST.Span\n            ): EvaluationResult | null {\n                if (left.type !== 'int' || right.type !== 'int') {\n                    this.reportError(\n                        DiagCode.TYPE_MISMATCH,\n                        'Bitwise operations require integer operands',\n                        span\n                    );\n                    return null;\n                }\n\n                const l = left.value as bigint;\n                const r = right.value as bigint;\n\n                let result: bigint;\n                switch (op) {\n                    case 'BitwiseAnd': result = l & r; break;\n                    case 'BitwiseXor': result = l ^ r; break;\n                    case 'BitwiseOr': result = l | r; break;\n                }\n\n                return { value: result, type: 'int' };\n            }\n\n            private evaluateComparison(\n                left: EvaluationResult,\n                right: EvaluationResult,\n                op: string,\n                span: AST.Span\n            ): EvaluationResult | null {\n                if (left.type === 'null' || right.type === 'null') {\n                    if (op === '==' || op === '!=') {\n                        const result = (left.value === right.value) === (op === '==');\n                        return { value: result, type: 'bool' };\n                    }\n                    return null;\n                }\n\n                if (left.type === 'float' || right.type === 'float') {\n                    const l = this.toFloat(left);\n                    const r = this.toFloat(right);\n                    return { value: this.compare(l, r, op), type: 'bool' };\n                }\n\n                if (left.type === 'int' && right.type === 'int') {\n                    const l = left.value as bigint;\n                    const r = right.value as bigint;\n                    return { value: this.compare(l, r, op), type: 'bool' };\n                }\n\n                if (left.type === 'bool' && right.type === 'bool') {\n                    if (op === '==' || op === '!=') {\n                        const result = (left.value === right.value) === (op === '==');\n                        return { value: result, type: 'bool' };\n                    }\n                }\n\n                return null;\n            }\n\n            private evaluateLogical(\n                left: EvaluationResult,\n                right: EvaluationResult,\n                op: 'LogicalAnd' | 'LogicalOr',\n                span: AST.Span\n            ): EvaluationResult | null {\n                if (left.type !== 'bool' || right.type !== 'bool') {\n                    this.reportError(\n                        DiagCode.TYPE_MISMATCH,\n                        'Logical operations require boolean operands',\n                        span\n                    );\n                    return null;\n                }\n\n                const l = left.value as boolean;\n                const r = right.value as boolean;\n\n                const result = op === 'LogicalAnd' ? l && r : l || r;\n                return { value: result, type: 'bool' };\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── PREFIX ──────────────────────────────┐\n\n            private evaluatePrefix(prefix: AST.PrefixNode, ctx: EvaluationContext): EvaluationResult | null {\n                const value = this.evaluateExpression(prefix.expr, ctx);\n                if (!value) return null;\n\n                switch (prefix.kind) {\n                    case 'UnaryPlus':\n                        if (value.type !== 'int' && value.type !== 'float') {\n                            this.reportError(\n                                DiagCode.TYPE_MISMATCH,\n                                `Unary '+' requires numeric operand, got '${value.type}'`,\n                                prefix.span\n                            );\n                            return null;\n                        }\n                        return value;\n\n                    case 'UnaryMinus':\n                        if (value.type !== 'int' && value.type !== 'float') {\n                            this.reportError(\n                                DiagCode.TYPE_MISMATCH,\n                                `Unary '-' requires numeric operand, got '${value.type}'`,\n                                prefix.span\n                            );\n                            return null;\n                        }\n\n                        if (value.type === 'int') {\n                            const result = -(value.value as bigint);\n                            if (result > this.MAX_INT_64 || result < this.MIN_INT_64) {\n                                this.reportError(\n                                    DiagCode.ARITHMETIC_OVERFLOW,\n                                    'Integer negation overflow',\n                                    prefix.span\n                                );\n                                return null;\n                            }\n                            return { value: result, type: 'int' };\n                        }\n                        if (value.type === 'float') {\n                            return { value: -(value.value as number), type: 'float' };\n                        }\n                        return null;\n\n                    case 'LogicalNot':\n                        if (value.type !== 'bool') {\n                            this.reportError(\n                                DiagCode.TYPE_MISMATCH,\n                                `Logical not requires boolean operand, got '${value.type}'`,\n                                prefix.span\n                            );\n                            return null;\n                        }\n                        return { value: !(value.value as boolean), type: 'bool' };\n\n                    case 'BitwiseNot':\n                        if (value.type !== 'int') {\n                            this.reportError(\n                                DiagCode.TYPE_MISMATCH,\n                                `Bitwise not requires integer operand, got '${value.type}'`,\n                                prefix.span\n                            );\n                            return null;\n                        }\n                        return { value: ~(value.value as bigint), type: 'int' };\n\n                    default:\n                        return null;\n                }\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────── SPECIAL EXPRESSIONS ─────────────────────┐\n\n            private evaluateAs(asNode: AST.AsNode, ctx: EvaluationContext): EvaluationResult | null {\n                const value = this.evaluateExpression(asNode.base, ctx);\n                if (!value) return null;\n\n                const targetType = asNode.type;\n\n                // Int to float\n                if (value.type === 'int' && this.isFloatType(targetType)) {\n                    return { value: Number(value.value), type: 'float' };\n                }\n\n                // Float to int (truncation)\n                if (value.type === 'float' && this.isIntegerType(targetType)) {\n                    const intValue = BigInt(Math.trunc(value.value as number));\n                    if (intValue > this.MAX_INT_64 || intValue < this.MIN_INT_64) {\n                        this.reportError(\n                            DiagCode.ARITHMETIC_OVERFLOW,\n                            'Float to integer conversion overflow',\n                            asNode.span\n                        );\n                        return null;\n                    }\n                    return { value: intValue, type: 'int' };\n                }\n\n                return value;\n            }\n\n            private evaluateSizeof(sizeofNode: AST.SizeofNode, ctx: EvaluationContext): EvaluationResult | null {\n                const type = sizeofNode.expr.getType()!;\n                const size = this.computeTypeSize(type);\n                return size !== null ? { value: BigInt(size), type: 'int' } : null;\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌───────────────────────── COMPTIME FUNCTION CALLS ────────────────────┐\n\n            private evaluateComptimeFunctionCall(call: AST.CallNode, ctx: EvaluationContext): EvaluationResult | null {\n                const functionSymbol = this.findCallTargetSymbol(call.base);\n\n                if (!functionSymbol) {\n                    this.reportError(\n                        DiagCode.UNDEFINED_IDENTIFIER,\n                        'Function not found in compile-time call',\n                        call.base.span\n                    );\n                    return null;\n                }\n\n                // Handle function pointer variables\n                let targetSymbol = functionSymbol;\n\n                if (functionSymbol.kind === SymbolKind.Variable) {\n                    // Check if variable holds a reference to a comptime function\n                    if (functionSymbol.metadata?.initializer) {\n                        const initExpr = functionSymbol.metadata.initializer as AST.ExprNode;\n\n                        // If initializer is an identifier, resolve it\n                        if (initExpr.is('Primary')) {\n                            const primary = initExpr.getPrimary();\n                            if (primary?.is('Ident')) {\n                                const targetIdent = primary.getIdent()!;\n                                const resolvedSymbol = this.config.services.scopeManager.lookupSymbol(targetIdent.name);\n\n                                if (resolvedSymbol) {\n                                    // Check if the target is a comptime function\n                                    if (resolvedSymbol.kind === SymbolKind.Function &&\n                                        resolvedSymbol.metadata?.isComptimeFunction === true) {\n                                        // Variable holds a comptime function - use it!\n                                        targetSymbol = resolvedSymbol;\n                                        this.log('verbose',\n                                            `[Comptime] Resolved function pointer '${functionSymbol.name}' to comptime function '${resolvedSymbol.name}'`\n                                        );\n                                    } else {\n                                        // Variable holds a non-comptime function - cannot evaluate at compile-time\n                                        return null;\n                                    }\n                                } else {\n                                    return null;\n                                }\n                            } else {\n                                return null; // Complex initializer\n                            }\n                        } else {\n                            return null; // Not a simple identifier\n                        }\n                    } else {\n                        return null; // No initializer metadata\n                    }\n                }\n\n                const isComptimeFunc = targetSymbol.metadata?.isComptimeFunction === true;\n\n                if (!isComptimeFunc) {\n                    this.reportError(\n                        DiagCode.TYPE_MISMATCH,\n                        `Cannot call non-comptime function '${targetSymbol.name}' in compile-time context. Mark it with 'comptime' keyword.`,\n                        call.base.span\n                    );\n                    return null;\n                }\n\n                // Create cache key including arguments\n                const cacheKey = this.createComptimeCacheKey(targetSymbol, call.args, ctx);\n                const cached = this.comptimeResultCache.get(cacheKey);\n\n                if (cached) {\n                    this.log('verbose',\n                        `[Comptime] Using cached result for '${targetSymbol.name}': ${cached.value} (${cached.type})`\n                    );\n                    return cached;\n                }\n\n                // Validate argument count\n                const expectedParams = targetSymbol.metadata?.comptimeParameters as AST.FieldNode[] | undefined;\n                const expectedCount = expectedParams?.length || 0;\n\n                // Allow fewer arguments if defaults are provided\n                if (call.args.length > expectedCount) {\n                    this.reportError(\n                        DiagCode.TYPE_MISMATCH,\n                        `Comptime function '${targetSymbol.name}' expects at most ${expectedCount} argument(s), but got ${call.args.length}`,\n                        call.span\n                    );\n                    return null;\n                }\n\n                const body = targetSymbol.metadata?.comptimeFunctionBody as AST.StmtNode | undefined;\n\n                if (!body) {\n                    this.reportError(\n                        DiagCode.INTERNAL_ERROR,\n                        `Comptime function '${targetSymbol.name}' has no body stored`,\n                        call.base.span\n                    );\n                    return null;\n                }\n\n                // Get the FUNCTION'S scope (where parameters live), not the parent scope\n                // functionSymbol.scope is the MODULE scope, we need the child FUNCTION scope\n                const parentScope = this.config.services.scopeManager.getScope(targetSymbol.scope);\n                const functionScope = this.config.services.scopeManager.findChildScopeByNameFromId(\n                    targetSymbol.name,\n                    parentScope.id,\n                    ScopeKind.Function\n                );\n\n                if (!functionScope) {\n                    this.reportError(\n                        DiagCode.INTERNAL_ERROR,\n                        `Cannot find function scope for comptime function '${targetSymbol.name}'`,\n                        call.base.span\n                    );\n                    return null;\n                }\n\n                this.log('verbose',\n                    `[Comptime] Evaluating function '${targetSymbol.name}' with ${call.args.length} argument(s) in scope ${functionScope.id}`\n                );\n\n                // Evaluate call arguments FIRST (in caller's context)\n                const evaluatedArgs: EvaluationResult[] = [];\n\n                for (let i = 0; i < call.args.length; i++) {\n                    const argValue = this.evaluateExpression(call.args[i], ctx);\n\n                    if (!argValue) {\n                        this.reportError(\n                            DiagCode.ANALYSIS_ERROR,\n                            `Could not evaluate argument ${i + 1} at compile time`,\n                            call.args[i].span\n                        );\n                        return null;\n                    }\n\n                    evaluatedArgs.push(argValue);\n\n                    this.log('verbose',\n                        `[Comptime] Argument ${i + 1} evaluated to ${argValue.value} (${argValue.type})`\n                    );\n                }\n\n                // Evaluate default values for missing arguments\n                if (expectedParams) {\n                    for (let i = call.args.length; i < expectedParams.length; i++) {\n                        const param = expectedParams[i];\n\n                        if (!param.initializer) {\n                            this.reportError(\n                                DiagCode.TYPE_MISMATCH,\n                                `Comptime function '${targetSymbol.name}' requires ${expectedParams.length} argument(s), but got ${call.args.length}`,\n                                call.span\n                            );\n                            return null;\n                        }\n\n                        // Evaluate default value in CALLER'S context\n                        const defaultValue = this.evaluateExpression(param.initializer, ctx);\n\n                        if (!defaultValue) {\n                            this.reportError(\n                                DiagCode.ANALYSIS_ERROR,\n                                `Could not evaluate default value for parameter '${param.ident.name}' at compile time`,\n                                param.initializer.span\n                            );\n                            return null;\n                        }\n\n                        evaluatedArgs.push(defaultValue);\n\n                        this.log('verbose',\n                            `[Comptime] Parameter ${i + 1} using default value ${defaultValue.value} (${defaultValue.type})`\n                        );\n                    }\n                }\n\n                const returnValue = this.extractReturnValueFromComptimeFunction(\n                    body,\n                    ctx,\n                    functionScope,\n                    evaluatedArgs\n                );\n\n                if (returnValue === null) {\n                    this.reportError(\n                        DiagCode.ANALYSIS_ERROR,\n                        `Could not evaluate comptime function '${targetSymbol.name}' at compile time. Ensure it has a simple 'return <constant>' statement.`,\n                        call.base.span\n                    );\n                    return null;\n                }\n\n                // Cache the result\n                this.comptimeResultCache.set(cacheKey, returnValue);\n\n                this.log('verbose',\n                    `[Comptime] Function '${targetSymbol.name}' returned ${returnValue.value} (${returnValue.type})`\n                );\n\n                return returnValue;\n            }\n\n            private extractReturnValueFromComptimeFunction(\n                body: AST.StmtNode | undefined,\n                ctx: EvaluationContext,\n                functionScope: Scope,\n                args: EvaluationResult[] = []\n            ): EvaluationResult | null {\n                if (!body) {\n                    return null;\n                }\n\n                const localVariables: LocalVariableMap = new Map();\n\n                // STEP 1: Bind arguments to parameters\n                // Get parameters from the function scope in declaration order\n                const paramSymbols = Array.from(functionScope.symbols.values());\n                    // .filter(s => s.kind === SymbolKind.Parameter)\n                    // .sort((a, b) => a.contextSpan.start - b.contextSpan.start);\n\n                this.log('verbose',\n                    `[Comptime] Found ${paramSymbols.length} parameters in scope`\n                );\n\n                for (let i = 0; i < args.length && i < paramSymbols.length; i++) {\n                    const paramName = paramSymbols[i].name;\n                    localVariables.set(paramName, args[i]);\n\n                    this.log('verbose',\n                        `[Comptime] Bound parameter '${paramName}' = ${args[i].value} (${args[i].type})`\n                    );\n                }\n\n                // Debug: Show what's in localVariables\n                this.log('verbose',\n                    `[Comptime] localVariables has ${localVariables.size} entries: ${Array.from(localVariables.keys()).join(', ')}`\n                );\n\n                const processStatement = (stmt: AST.StmtNode): EvaluationResult | null => {\n                    if (stmt.kind === 'Let') {\n                        const letNode = stmt.getLet();\n                        if (letNode && letNode.field.initializer) {\n                            const value = this.evaluateWithLocals(\n                                letNode.field.initializer,\n                                ctx,\n                                functionScope,\n                                localVariables\n                            );\n\n                            if (value) {\n                                localVariables.set(letNode.field.ident.name, value);\n\n                                this.log('verbose',\n                                    `[Comptime] Stored local variable '${letNode.field.ident.name}' = ${value.value} (${value.type})`\n                                );\n                            }\n                            return null;\n                        }\n                    }\n\n                    if (stmt.kind === 'Return') {\n                        const returnNode = stmt.getCtrlflow();\n                        if (returnNode?.value) {\n                            return this.evaluateWithLocals(\n                                returnNode.value,\n                                ctx,\n                                functionScope,\n                                localVariables\n                            );\n                        }\n                    }\n\n                    if (stmt.kind === 'Expression') {\n                        const expr = stmt.getExpr();\n                        if (expr) {\n                            return this.evaluateWithLocals(\n                                expr,\n                                ctx,\n                                functionScope,\n                                localVariables\n                            );\n                        }\n                    }\n\n                    return null;\n                };\n\n                if (body.kind === 'Block') {\n                    const blockNode = body.getBlock();\n                    if (!blockNode || blockNode.stmts.length === 0) {\n                        return null;\n                    }\n\n                    for (const stmt of blockNode.stmts) {\n                        const result = processStatement(stmt);\n\n                        if (result !== null) {\n                            return result;\n                        }\n                    }\n                } else {\n                    return processStatement(body);\n                }\n\n                return null;\n            }\n\n            // Helper to get parameter names in declaration order\n            private getParametersFromMetadata(functionScope: Scope): string[] {\n                // Get parameters directly from the scope symbols\n                // They're already in the correct order from collection phase\n                const paramSymbols = Array.from(functionScope.symbols.values())\n                    .filter(s => s.kind === SymbolKind.Parameter)\n                    .sort((a, b) => a.contextSpan.start - b.contextSpan.start);\n\n                return paramSymbols.map(s => s.name);\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌────────────────────────── EVALUATE WITH LOCALS ──────────────────────┐\n\n            private evaluateWithLocals(\n                expr: AST.ExprNode,\n                ctx: EvaluationContext,\n                scope: Scope,\n                locals: LocalVariableMap\n            ): EvaluationResult | null {\n                try {\n                    switch (expr.kind) {\n                        case 'Primary':\n                            return this.evaluatePrimaryWithLocals(expr.getPrimary()!, ctx, scope, locals);\n\n                        case 'Binary':\n                            return this.evaluateBinaryWithLocals(expr.getBinary()!, ctx, scope, locals);\n\n                        case 'Prefix':\n                            return this.evaluatePrefixWithLocals(expr.getPrefix()!, ctx, scope, locals);\n\n                        case 'Postfix': {\n                            const postfix = expr.getPostfix();\n                            if (postfix?.kind === 'Call') {\n                                return this.evaluateComptimeFunctionCall(postfix.getCall()!, ctx);\n                            }\n                            return null;\n                        }\n\n                        case 'As':\n                            return this.evaluateAsWithLocals(expr.getAs()!, ctx, scope, locals);\n\n                        case 'Sizeof':\n                            return this.evaluateSizeof(expr.getSizeof()!, ctx);\n\n                        default:\n                            return null;\n                    }\n                } catch (error) {\n                    this.reportError(\n                        DiagCode.ANALYSIS_ERROR,\n                        `Error evaluating compile-time expression: ${error}`,\n                        expr.span\n                    );\n                    return null;\n                }\n            }\n\n            private evaluatePrimaryWithLocals(\n                primary: AST.PrimaryNode,\n                ctx: EvaluationContext,\n                scope: Scope,\n                locals: LocalVariableMap\n            ): EvaluationResult | null {\n                switch (primary.kind) {\n                    case 'Literal':\n                        return this.evaluateLiteral(primary.getLiteral()!, ctx);\n\n                    case 'Ident':\n                        return this.evaluateIdentifierWithLocals(primary.getIdent()!, ctx, scope, locals);\n\n                    case 'Paren': {\n                        const paren = primary.getParen()!;\n                        return paren.source ? this.evaluateWithLocals(paren.source, ctx, scope, locals) : null;\n                    }\n\n                    default:\n                        return null;\n                }\n            }\n\n            private evaluateIdentifierWithLocals(\n                ident: AST.IdentNode,\n                ctx: EvaluationContext,\n                scope: Scope,\n                locals: LocalVariableMap\n            ): EvaluationResult | null {\n                const localValue = locals.get(ident.name);\n                if (localValue) {\n                    this.log('verbose',\n                        `[Comptime] Found local variable '${ident.name}' = ${localValue.value} (${localValue.type})`\n                    );\n                    return localValue;\n                }\n\n                this.log('verbose',\n                    `[Comptime] Variable '${ident.name}' not in locals, checking scope...`\n                );\n\n                const scopeSymbol = scope.symbols.get(ident.name);\n                if (scopeSymbol) {\n                    if (scopeSymbol.metadata && typeof scopeSymbol.metadata === 'object') {\n                        const metadata = scopeSymbol.metadata as any;\n                        if (metadata.initializer) {\n                            return this.evaluateWithLocals(metadata.initializer, ctx, scope, locals);\n                        }\n                    }\n                }\n\n                return this.evaluateIdentifier(ident, ctx);\n            }\n\n            private evaluateBinaryWithLocals(\n                binary: AST.BinaryNode,\n                ctx: EvaluationContext,\n                scope: Scope,\n                locals: LocalVariableMap\n            ): EvaluationResult | null {\n                const left = this.evaluateWithLocals(binary.left, ctx, scope, locals);\n                const right = this.evaluateWithLocals(binary.right, ctx, scope, locals);\n\n                if (!left || !right) return null;\n\n                if (!this.areTypesCompatible(left.type, right.type, binary.kind)) {\n                    this.reportError(\n                        DiagCode.TYPE_MISMATCH,\n                        `Cannot perform ${binary.kind} operation on incompatible types '${left.type}' and '${right.type}'`,\n                        binary.span\n                    );\n                    return null;\n                }\n\n                switch (binary.kind) {\n                    case 'Additive':\n                        return this.evaluateAdditive(left, right, binary.operator, binary.span);\n                    case 'Multiplicative':\n                        return this.evaluateMultiplicative(left, right, binary.operator, binary.span);\n                    case 'Power':\n                        return this.evaluatePower(left, right, binary.span);\n                    case 'Shift':\n                        return this.evaluateShift(left, right, binary.operator, binary.span);\n                    case 'BitwiseAnd':\n                    case 'BitwiseXor':\n                    case 'BitwiseOr':\n                        return this.evaluateBitwise(left, right, binary.kind, binary.span);\n                    case 'Relational':\n                    case 'Equality':\n                        return this.evaluateComparison(left, right, binary.operator, binary.span);\n                    case 'LogicalAnd':\n                    case 'LogicalOr':\n                        return this.evaluateLogical(left, right, binary.kind, binary.span);\n                    default:\n                        return null;\n                }\n            }\n\n            private evaluatePrefixWithLocals(\n                prefix: AST.PrefixNode,\n                ctx: EvaluationContext,\n                scope: Scope,\n                locals: LocalVariableMap\n            ): EvaluationResult | null {\n                const value = this.evaluateWithLocals(prefix.expr, ctx, scope, locals);\n                if (!value) return null;\n\n                switch (prefix.kind) {\n                    case 'UnaryPlus':\n                        if (value.type !== 'int' && value.type !== 'float') {\n                            this.reportError(\n                                DiagCode.TYPE_MISMATCH,\n                                `Unary '+' requires numeric operand, got '${value.type}'`,\n                                prefix.span\n                            );\n                            return null;\n                        }\n                        return value;\n\n                    case 'UnaryMinus':\n                        if (value.type !== 'int' && value.type !== 'float') {\n                            this.reportError(\n                                DiagCode.TYPE_MISMATCH,\n                                `Unary '-' requires numeric operand, got '${value.type}'`,\n                                prefix.span\n                            );\n                            return null;\n                        }\n\n                        if (value.type === 'int') {\n                            const result = -(value.value as bigint);\n                            if (result > this.MAX_INT_64 || result < this.MIN_INT_64) {\n                                this.reportError(\n                                    DiagCode.ARITHMETIC_OVERFLOW,\n                                    'Integer negation overflow',\n                                    prefix.span\n                                );\n                                return null;\n                            }\n                            return { value: result, type: 'int' };\n                        }\n                        if (value.type === 'float') {\n                            return { value: -(value.value as number), type: 'float' };\n                        }\n                        return null;\n\n                    case 'LogicalNot':\n                        if (value.type !== 'bool') {\n                            this.reportError(\n                                DiagCode.TYPE_MISMATCH,\n                                `Logical not requires boolean operand, got '${value.type}'`,\n                                prefix.span\n                            );\n                            return null;\n                        }\n                        return { value: !(value.value as boolean), type: 'bool' };\n\n                    case 'BitwiseNot':\n                        if (value.type !== 'int') {\n                            this.reportError(\n                                DiagCode.TYPE_MISMATCH,\n                                `Bitwise not requires integer operand, got '${value.type}'`,\n                                prefix.span\n                            );\n                            return null;\n                        }\n                        return { value: ~(value.value as bigint), type: 'int' };\n\n                    default:\n                        return null;\n                }\n            }\n\n            private evaluateAsWithLocals(\n                asNode: AST.AsNode,\n                ctx: EvaluationContext,\n                scope: Scope,\n                locals: LocalVariableMap\n            ): EvaluationResult | null {\n                const value = this.evaluateWithLocals(asNode.base, ctx, scope, locals);\n                if (!value) return null;\n\n                const targetType = asNode.type;\n\n                if (value.type === 'int' && this.isFloatType(targetType)) {\n                    return { value: Number(value.value), type: 'float' };\n                }\n\n                if (value.type === 'float' && this.isIntegerType(targetType)) {\n                    const intValue = BigInt(Math.trunc(value.value as number));\n                    if (intValue > this.MAX_INT_64 || intValue < this.MIN_INT_64) {\n                        this.reportError(\n                            DiagCode.ARITHMETIC_OVERFLOW,\n                            'Float to integer conversion overflow',\n                            asNode.span\n                        );\n                        return null;\n                    }\n                    return { value: intValue, type: 'int' };\n                }\n\n                return value;\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HELP ────────────────────────────────┐\n\n            private createComptimeCacheKey(\n                functionSymbol: Symbol,\n                args: AST.ExprNode[],\n                ctx: EvaluationContext\n            ): string {\n                // Base key\n                let key = `${functionSymbol.name}:${functionSymbol.id}`;\n\n                // Add argument values to key\n                for (let i = 0; i < args.length; i++) {\n                    const argValue = this.evaluateExpression(args[i], ctx);\n                    if (argValue) {\n                        key += `:${argValue.type}:${argValue.value}`;\n                    } else {\n                        key += `:unknown`;\n                    }\n                }\n\n                return key;\n            }\n\n            private findCallTargetSymbol(baseExpr: AST.ExprNode): Symbol | null {\n                if (baseExpr.is('Primary')) {\n                    const primary = baseExpr.getPrimary();\n\n                    if (primary?.is('Ident')) {\n                        const ident = primary.getIdent();\n                        if (ident && !ident.builtin) {\n                            return this.config.services.scopeManager.lookupSymbol(ident.name);\n                        }\n                    }\n                }\n\n                return null;\n            }\n\n            private areTypesCompatible(t1: string, t2: string, op: string): boolean {\n                if (t1 === t2) {\n                    if (t1 === 'bool') {\n                        return op === 'LogicalAnd' ||\n                            op === 'LogicalOr' ||\n                            op === 'Equality' ||\n                            op === 'Relational';\n                    }\n                    if (t1 === 'null') {\n                        return op === 'Equality' || op === 'Relational';\n                    }\n                    return true;\n                }\n\n                if ((t1 === 'int' || t1 === 'float') && (t2 === 'int' || t2 === 'float')) {\n                    if (op === 'BitwiseAnd' || op === 'BitwiseXor' || op === 'BitwiseOr' || op === 'Shift') {\n                        return t1 === 'int' && t2 === 'int';\n                    }\n                    return true;\n                }\n\n                if (t1 === 'bool' || t2 === 'bool') {\n                    return false;\n                }\n\n                if (t1 === 'null' || t2 === 'null') {\n                    return op === 'Equality';\n                }\n\n                return false;\n            }\n\n            private toFloat(result: EvaluationResult): number {\n                if (result.type === 'float') return result.value as number;\n                if (result.type === 'int') return Number(result.value);\n                return 0;\n            }\n\n            private compare(l: any, r: any, op: string): boolean {\n                switch (op) {\n                    case '==': return l === r;\n                    case '!=': return l !== r;\n                    case '<': return l < r;\n                    case '<=': return l <= r;\n                    case '>': return l > r;\n                    case '>=': return l >= r;\n                    default: return false;\n                }\n            }\n\n            private isFloatType(type: AST.TypeNode): boolean {\n                return type.isFloat() || type.isComptimeFloat();\n            }\n\n            private isIntegerType(type: AST.TypeNode): boolean {\n                return type.isSigned() || type.isUnsigned() || type.isComptimeInt();\n            }\n\n            private isFloatTargetType(type: AST.TypeNode): boolean {\n                const unwrapped = this.unwrapType(type);\n                return unwrapped.isFloat() || unwrapped.isComptimeFloat();\n            }\n\n            private isIntegerTargetType(type: AST.TypeNode): boolean {\n                const unwrapped = this.unwrapType(type);\n                return unwrapped.isSigned() || unwrapped.isUnsigned() || unwrapped.isComptimeInt();\n            }\n\n            private unwrapType(type: AST.TypeNode): AST.TypeNode {\n                let unwrapped = type;\n\n                while (unwrapped.isOptional()) {\n                    unwrapped = unwrapped.getOptional()!.target;\n                }\n\n                if (unwrapped.isIdent()) {\n                    const ident = unwrapped.getIdent()!;\n                    if (!ident.builtin) {\n                        const symbol = this.config.services.scopeManager.lookupSymbol(ident.name);\n                        if (symbol && symbol.type) {\n                            return this.unwrapType(symbol.type);\n                        }\n                    }\n                }\n\n                return unwrapped;\n            }\n\n            private getFloatBounds(type: AST.TypeNode): { min: number; max: number } {\n                const unwrapped = this.unwrapType(type);\n\n                if (unwrapped.isFloat()) {\n                    const width = unwrapped.getWidth();\n                    switch (width) {\n                        case 16: return { min: -65504, max: 65504 };\n                        case 32: return { min: -3.4028235e38, max: 3.4028235e38 };\n                        case 64: return { min: -1.7976931348623157e308, max: 1.7976931348623157e308 };\n                        case 128: return { min: -Number.MAX_VALUE, max: Number.MAX_VALUE };\n                        default: return { min: -Number.MAX_VALUE, max: Number.MAX_VALUE };\n                    }\n                }\n\n                return { min: -Number.MAX_VALUE, max: Number.MAX_VALUE };\n            }\n\n            private getTypeBounds(type?: AST.TypeNode): { min: bigint; max: bigint } {\n                if (!type) {\n                    return { min: this.MIN_INT_64, max: this.MAX_INT_64 };\n                }\n\n                const unwrapped = this.unwrapType(type);\n\n                if (unwrapped.isSigned()) {\n                    const width = unwrapped.getWidth() || 64;\n                    const max = BigInt(2) ** BigInt(width - 1) - BigInt(1);\n                    const min = -(BigInt(2) ** BigInt(width - 1));\n                    return { min, max };\n                }\n\n                if (unwrapped.isUnsigned()) {\n                    const width = unwrapped.getWidth() || 64;\n                    const max = BigInt(2) ** BigInt(width) - BigInt(1);\n                    return { min: BigInt(0), max };\n                }\n\n                if (unwrapped.isComptimeInt()) {\n                    return { min: this.MIN_INT_64, max: this.MAX_INT_64 };\n                }\n\n                return { min: this.MIN_INT_64, max: this.MAX_INT_64 };\n            }\n\n            computeTypeSize(type: AST.TypeNode): number | null {\n                switch (type.kind) {\n                    case 'primitive': {\n                        const prim = type.getPrimitive()!;\n\n                        if (prim.width !== undefined) {\n                            return prim.width;\n                        }\n\n                        switch (prim.kind) {\n                            case 'bool': return 1;\n                            case 'void': return 0;\n                            default: return null;\n                        }\n                    }\n\n                    case 'pointer':\n                        return 64;\n\n                    case 'optional': {\n                        const inner = type.getOptional()!.target;\n                        const innerSize = this.computeTypeSize(inner);\n                        return innerSize !== null ? innerSize + 1 : null;\n                    }\n\n                    case 'array': {\n                        const arr = type.getArray()!;\n                        const elemSize = this.computeTypeSize(arr.target);\n                        if (elemSize === null) return null;\n\n                        if (arr.size) {\n                            const sizeValue = this.extractIntegerValue(arr.size);\n                            if (sizeValue !== undefined) {\n                                return elemSize * sizeValue;\n                            }\n                        }\n                        return null;\n                    }\n\n                    case 'tuple': {\n                        const tuple = type.getTuple()!;\n                        let totalSize = 0;\n\n                        for (const field of tuple.fields) {\n                            const fieldSize = this.computeTypeSize(field);\n                            if (fieldSize === null) return null;\n                            totalSize += fieldSize;\n                        }\n\n                        return totalSize;\n                    }\n\n                    case 'struct': {\n                        const struct = type.getStruct()!;\n                        let totalSize = 0;\n\n                        for (const member of struct.members) {\n                            if (member.isField()) {\n                                const field = member.getField()!;\n                                if (field.type) {\n                                    const fieldSize = this.computeTypeSize(field.type);\n                                    if (fieldSize === null) return null;\n                                    totalSize += fieldSize;\n                                }\n                            }\n                        }\n\n                        return totalSize;\n                    }\n\n                    default:\n                        return null;\n                }\n            }\n\n            extractIntegerValue(expr: AST.ExprNode): number | undefined {\n                const comptimeValue = this.evaluateComptimeExpression(expr);\n\n                if (comptimeValue === null) return undefined;\n\n                if (comptimeValue > BigInt(Number.MAX_SAFE_INTEGER) ||\n                    comptimeValue < BigInt(Number.MIN_SAFE_INTEGER)) {\n                    return undefined;\n                }\n\n                return Number(comptimeValue);\n            }\n\n            private reportError(code: DiagCode, message: string, span?: AST.Span): void {\n                this.config.services.diagnosticManager.reportError(code, message, span);\n            }\n\n            private reportWarning(code: DiagCode, message: string, span?: AST.Span): void {\n                this.config.services.diagnosticManager.reportWarning(code, message, span);\n            }\n\n            private reportInfo(code: DiagCode, message: string, span?: AST.Span): void {\n                this.config.services.diagnosticManager.reportInfo(code, message, span);\n            }\n\n            private log(kind: DebugKind, msg: string) {\n                this.config.services.debugManager?.log(kind, msg);\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// SemanticValidator.ts — Semantic validation phase.\n//\n// Developed with ❤️ by Maysara.\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import * as AST                     from '@je-es/ast';\n    import { AnalysisPhase }            from '../components/ContextTracker';\n    import { DiagCode, DiagKind }       from '../components/DiagnosticManager';\n    import { AnalysisConfig }           from '../ast-analyzer';\n    import { PhaseBase }                from '../interfaces/PhaseBase';\n    import { ScopeKind, Symbol, SymbolKind }       from '../components/ScopeManager';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ TYPE ════════════════════════════════════════╗\n\n    interface EntryPointValidation {\n        hasEntryModule: boolean;\n        hasMainFunction: boolean;\n        mainIsPublic: boolean;\n        errors: string[];\n    }\n\n    interface UnusedSymbolAnalysis {\n        unusedVariables: Symbol[];\n        unusedParameters: Symbol[];\n        unusedFunctions: Symbol[];\n        totalUnused: number;\n    }\n\n    interface SemanticStats {\n        entryPointChecks: number;\n        unusedSymbolChecks: number;\n        visibilityChecks: number;\n        moduleIntegrityChecks: number;\n        errors: number;\n        warnings: number;\n        startTime: number;\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class SemanticValidator extends PhaseBase {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            private stats               : SemanticStats         = this.initStats();\n\n            constructor( config : AnalysisConfig ) {\n                super(AnalysisPhase.SemanticValidation, config);\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ────────────────────────────────┐\n\n            handle(): boolean {\n                try {\n                    this.log('verbose', 'Starting semantic validation phase...');\n                    this.stats.startTime = Date.now();\n\n                    this.validateEntryPoint();\n                    this.validateUnusedSymbols();\n                    this.validateModuleIntegrity();\n                    this.validateVisibilityRules();\n\n                    this.logStatistics();\n                    return !this.config.services.diagnosticManager.hasErrors();\n\n                } catch (error) {\n                    this.log('errors', `Fatal error during semantic validation: ${error}`);\n                    this.reportError(\n                        DiagCode.ANALYSIS_ERROR,\n                        `Semantic validation failed: ${error}`\n                    );\n                    return false;\n                }\n            }\n\n            reset(): void {\n                this.stats              = this.initStats();\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── ---- ────────────────────────────────┐\n\n            private validateEntryPoint(): void {\n                this.log('symbols', 'Validating entry point');\n                this.stats.entryPointChecks++;\n\n                const entryModuleName = this.config.program!.metadata?.entryModule as string;\n                if (!entryModuleName) {\n                    // No entry module specified - this might be a library, so just return\n                    this.log('verbose', 'No entry module specified, skipping entry point validation');\n                    return;\n                }\n\n                const validation = this.performEntryPointValidation(entryModuleName);\n                this.reportEntryPointErrors(validation, entryModuleName);\n            }\n\n            private performEntryPointValidation(entryModuleName: string): EntryPointValidation {\n                const result: EntryPointValidation = {\n                    hasEntryModule: false,\n                    hasMainFunction: false,\n                    mainIsPublic: false,\n                    errors: []\n                };\n\n                // Check if entry module exists\n                const entryModule = this.config.program!.modules.get(entryModuleName);\n                if (!entryModule) {\n                    result.errors.push(`Entry module '${entryModuleName}' not found`);\n                    return result;\n                }\n                result.hasEntryModule = true;\n\n                // Set context for better error reporting\n                this.config.services.contextTracker.setModuleName(entryModuleName);\n                if (typeof entryModule.metadata?.path === 'string') {\n                    this.config.services.contextTracker.setModulePath(entryModule.metadata.path);\n                }\n\n                // Look for main function\n                const mainFunc = entryModule.findFunction('main');\n                if (!mainFunc) {\n                    result.errors.push(`Entry module '${entryModuleName}' does not contain 'main' function`);\n                    return result;\n                }\n                result.hasMainFunction = true;\n\n                // Check if main is public\n                if (mainFunc.visibility.kind !== 'Public') {\n                    result.errors.push(`Main function in entry module '${entryModuleName}' must be public`);\n                    return result;\n                }\n                result.mainIsPublic = true;\n\n                // Additional validation for main function signature\n                this.validateMainFunctionSignature(mainFunc, result);\n\n                return result;\n            }\n\n            private validateMainFunctionSignature(mainFunc: AST.FuncStmtNode, result: EntryPointValidation): void {\n                // Validate parameter count (main should have 0 or specific parameters)\n                if (mainFunc.parameters.length > 2) {\n                    result.errors.push(`Main function should not have more than 2 parameters`);\n                }\n\n                // Check return type if specified\n                if (mainFunc.returnType && !this.isValidMainReturnType(mainFunc.returnType)) {\n                    result.errors.push(`Main function should return void or exit code type`);\n                }\n            }\n\n            private isValidMainReturnType(returnType: AST.TypeNode): boolean {\n                return returnType.isVoid() ||\n                       (returnType.isSigned() && returnType.getWidth() === 32) ||\n                       (returnType.isUnsigned() && returnType.getWidth() === 8);\n            }\n\n            private reportEntryPointErrors(validation: EntryPointValidation, entryModuleName: string): void {\n                for (const error of validation.errors) {\n                    let code: DiagCode;\n\n                    if (error.includes('not found')) {\n                        code = DiagCode.ENTRY_MODULE_NOT_FOUND;\n                    } else if (error.includes('does not contain')) {\n                        code = DiagCode.ENTRY_MODULE_NO_MAIN;\n                    } else if (error.includes('must be public')) {\n                        code = DiagCode.ENTRY_MODULE_PRIVATE_MAIN;\n                    } else {\n                        code = DiagCode.ANALYSIS_ERROR;\n                    }\n\n                    this.reportError(code, error);\n                    this.stats.errors++;\n                }\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── ---- ────────────────────────────────┐\n\n            private validateUnusedSymbols(): void {\n                this.log('symbols', 'Validating unused symbols');\n                this.stats.unusedSymbolChecks++;\n\n                const analysis = this.analyzeUnusedSymbols();\n                this.reportUnusedSymbols(analysis);\n            }\n\n            private analyzeUnusedSymbols(): UnusedSymbolAnalysis {\n                const analysis: UnusedSymbolAnalysis = {\n                    unusedVariables: [],\n                    unusedParameters: [],\n                    unusedFunctions: [],\n                    totalUnused: 0\n                };\n\n                for (const symbol of this.config.services.scopeManager.getAllSymbols().values()) {\n                    if (!symbol.used && this.shouldCheckForUnused(symbol)) {\n                        switch (symbol.kind) {\n                            case SymbolKind.Variable:\n                                analysis.unusedVariables.push(symbol);\n                                break;\n                            case SymbolKind.Parameter:\n                                analysis.unusedParameters.push(symbol);\n                                break;\n                            case SymbolKind.Function:\n                                analysis.unusedFunctions.push(symbol);\n                                break;\n                        }\n                        analysis.totalUnused++;\n                    }\n                }\n\n                return analysis;\n            }\n\n            private shouldCheckForUnused(symbol: Symbol): boolean {\n                // Skip symbols that start with underscore (conventional ignore)\n                if (symbol.name.startsWith('_')) {\n                    return false;\n                }\n\n                // Skip public symbols (may be used by other modules or external code)\n                if (symbol.visibility.kind === 'Public') {\n                    return false;\n                }\n\n                // Skip main function\n                if (symbol.name === 'main' && symbol.kind === SymbolKind.Function) {\n                    return false;\n                }\n\n                // Skip builtin functions\n                if (symbol.name.startsWith('@')) {\n                    return false;\n                }\n\n                // Skip imported symbols (they might be used indirectly)\n                if (symbol.importSource) {\n                    return false;\n                }\n\n                return true;\n            }\n\n            private reportUnusedSymbols(analysis: UnusedSymbolAnalysis): void {\n                // Report unused variables\n                for (const symbol of analysis.unusedVariables) {\n                    this.reportUnusedSymbol(symbol, DiagCode.UNUSED_VARIABLE, 'Variable');\n                }\n\n                // Report unused parameters\n                for (const symbol of analysis.unusedParameters) {\n                    this.reportUnusedSymbol(symbol, DiagCode.UNUSED_PARAMETER, 'Parameter');\n                }\n\n                // Report unused functions\n                for (const symbol of analysis.unusedFunctions) {\n                    this.reportUnusedSymbol(symbol, DiagCode.UNUSED_FUNCTION, 'Function');\n                }\n\n                // Log summary\n                if (analysis.totalUnused > 0) {\n                    this.log('verbose',\n                        `Found ${analysis.totalUnused} unused symbols: ` +\n                        `${analysis.unusedVariables.length} variables, ` +\n                        `${analysis.unusedParameters.length} parameters, ` +\n                        `${analysis.unusedFunctions.length} functions`\n                    );\n                }\n            }\n\n            private reportUnusedSymbol(symbol: Symbol, code: DiagCode, symbolType: string): void {\n                const prevModule = this.config.services.contextTracker.getModuleName();\n                const prevPath = this.config.services.contextTracker.getModulePath();\n                const prevSpan = this.config.services.contextTracker.getContextSpan();\n\n                try {\n                    // Set module context for better error reporting\n                    if (symbol.module) {\n                        this.config.services.contextTracker.setModuleName(symbol.module);\n                        const module = this.config.program!.modules.get(symbol.module);\n                        if (module && typeof module.metadata?.path === 'string') {\n                            this.config.services.contextTracker.setModulePath(module.metadata.path);\n                        }\n                    }\n\n                    this.config.services.contextTracker.setCurrentContextSpan(symbol.contextSpan);\n\n                    // Don't warn about unused static methods\n                    if (symbol.kind === SymbolKind.Function) {\n                        const parentScope = this.config.services.scopeManager.getScope(symbol.scope);\n                        if (parentScope.kind === ScopeKind.Type) {\n                            // Check if it's a static method\n                            if (symbol.visibility.kind === 'Static') {\n                                return; // Skip warning for static methods\n                            }\n                        }\n                    }\n\n                    if(symbol.name === 'self' && symbol.kind === SymbolKind.Parameter) {\n                        return; // Skip warning for 'self' in function\n                    }\n\n                    this.config.services.diagnosticManager.push({\n                        code,\n                        kind: DiagKind.WARNING,\n                        msg: `${symbolType} '${symbol.name}' is declared but never used`,\n                        targetSpan: symbol.targetSpan\n                    });\n\n                    this.stats.warnings++;\n                } finally {\n                    // Restore previous context\n                    this.config.services.contextTracker.setModuleName(prevModule);\n                    this.config.services.contextTracker.setModulePath(prevPath);\n                    this.config.services.contextTracker.setCurrentContextSpan(prevSpan);\n                }\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── ---- ────────────────────────────────┐\n\n            private validateModuleIntegrity(): void {\n                this.log('symbols', 'Validating module integrity');\n                this.stats.moduleIntegrityChecks++;\n\n                for (const [moduleName, module] of this.config.program!.modules) {\n                    this.validateSingleModuleIntegrity(moduleName, module);\n                }\n            }\n\n            private validateSingleModuleIntegrity(moduleName: string, module: AST.Module): void {\n                const prevModule = this.config.services.contextTracker.getModuleName();\n                const prevPath = this.config.services.contextTracker.getModulePath();\n                const prevSpan = this.config.services.contextTracker.getContextSpan();\n\n                try {\n                    this.config.services.contextTracker.setModuleName(moduleName);\n                    if (typeof module.metadata?.path === 'string') {\n                        this.config.services.contextTracker.setModulePath(module.metadata.path);\n                    }\n\n                    // Set span context from module metadata if it's a valid span\n                    const moduleSpan = module.metadata?.span;\n                    if (moduleSpan && typeof moduleSpan === 'object' &&\n                        'start' in moduleSpan && 'end' in moduleSpan) {\n                        this.config.services.contextTracker.setCurrentContextSpan(moduleSpan as AST.Span);\n                    }\n\n                    // Check for empty modules\n                    if (module.statements.length === 0) {\n                        this.reportWarning(\n                            DiagCode.ANALYSIS_ERROR,\n                            `Module '${moduleName}' is empty`\n                        );\n                        return;\n                    }\n                } finally {\n                    // Restore previous context\n                    this.config.services.contextTracker.setModuleName(prevModule);\n                    this.config.services.contextTracker.setModulePath(prevPath);\n                    this.config.services.contextTracker.setCurrentContextSpan(prevSpan);\n                }\n\n                // Check for circular imports\n                this.checkCircularImports(moduleName, module);\n\n                // Validate export consistency\n                this.validateExportConsistency(moduleName, module);\n            }\n\n            private checkCircularImports(moduleName: string, module: AST.Module): void {\n                const importedModules = new Set<string>();\n\n                for (const stmt of module.statements) {\n                    if (stmt.kind === 'Use') {\n                        const useNode = stmt.getUse()!;\n                        if (useNode.path) {\n                            const importedModule = this.findModuleByPath(useNode.path);\n                            if (importedModule) {\n                                importedModules.add(importedModule);\n\n                                // Check if imported module also imports this module\n                                if (this.hasCircularImport(moduleName, importedModule, new Set())) {\n                                    this.reportWarning(\n                                        DiagCode.IMPORT_CIRCULAR_DEPENDENCY,\n                                        `Circular import detected between '${moduleName}' and '${importedModule}'`,\n                                        useNode.span\n                                    );\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n            private hasCircularImport(originalModule: string, currentModule: string, visited: Set<string>): boolean {\n                if (visited.has(currentModule)) {\n                    return currentModule === originalModule;\n                }\n\n                visited.add(currentModule);\n                const module = this.config.program!.modules.get(currentModule);\n                if (!module) return false;\n\n                for (const stmt of module.statements) {\n                    if (stmt.kind === 'Use') {\n                        const useNode = stmt.getUse()!;\n                        if (useNode.path) {\n                            const importedModule = this.findModuleByPath(useNode.path);\n                            if (importedModule === originalModule) {\n                                return true;\n                            }\n                            if (importedModule && this.hasCircularImport(originalModule, importedModule, new Set(visited))) {\n                                return true;\n                            }\n                        }\n                    }\n                }\n\n                return false;\n            }\n\n            private validateExportConsistency(moduleName: string, module: AST.Module): void {\n                // Check that all public symbols are actually accessible\n                const moduleScope = this.config.services.scopeManager.findScopeByName(moduleName, 'Module' as any);\n                if (!moduleScope) return;\n\n                for (const [symbolName, symbol] of moduleScope.symbols) {\n                    if (symbol.visibility.kind === 'Public' && !symbol.used) {\n                        // This is handled by unused symbol validation, but we could add\n                        // module-specific export consistency checks here\n                    }\n                }\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── ---- ────────────────────────────────┐\n\n            private validateVisibilityRules(): void {\n                this.log('symbols', 'Validating visibility rules');\n                this.stats.visibilityChecks++;\n\n                for (const symbol of this.config.services.scopeManager.getAllSymbols().values()) {\n                    this.validateSymbolVisibility(symbol);\n                }\n            }\n\n            private validateSymbolVisibility(symbol: Symbol): void {\n                // Private symbols should not be accessed outside their module\n                if (symbol.visibility.kind === 'Private' && symbol.used) {\n                    this.validatePrivateSymbolUsage(symbol);\n                }\n\n                // Public symbols should be meaningfully public\n                if (symbol.visibility.kind === 'Public') {\n                    this.validatePublicSymbolExposure(symbol);\n                }\n            }\n\n            private validatePrivateSymbolUsage(symbol: Symbol): void {\n                // This would require more sophisticated cross-module usage analysis\n                // For now, we trust that the symbol resolver has handled this correctly\n            }\n\n            private validatePublicSymbolExposure(symbol: Symbol): void {\n                // Check if public symbols are actually used or meant to be API\n                if (!symbol.used && symbol.kind !== SymbolKind.Function) {\n                    // Public unused symbols might indicate API design issues\n                    // But this is more of a design hint than an error\n                }\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── ---- ────────────────────────────────┐\n\n            private findModuleByPath(importPath: string): string | undefined {\n                for (const [name, module] of this.config.program!.modules) {\n                    const modulePath = module.metadata?.path as string | undefined;\n                    if (modulePath === importPath) {\n                        return name;\n                    }\n                }\n                return undefined;\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── ---- ────────────────────────────────┐\n\n            private init(): boolean {\n                this.config.services.contextTracker.reset();\n                this.config.services.contextTracker.setPhase(AnalysisPhase.SemanticValidation);\n\n                this.log('verbose', 'Semantic validation initialized');\n                return true;\n            }\n\n            private initStats(): SemanticStats {\n                return {\n                    entryPointChecks: 0,\n                    unusedSymbolChecks: 0,\n                    visibilityChecks: 0,\n                    moduleIntegrityChecks: 0,\n                    errors: 0,\n                    warnings: 0,\n                    startTime: Date.now()\n                };\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── ---- ────────────────────────────────┐\n\n            logStatistics(): void {\n                const duration = Date.now() - this.stats.startTime;\n                this.log('verbose',\n                    `Semantic Validation Statistics     :\\n` +\n                    `  Duration                         : ${duration}ms\\n` +\n                    `  Entry point checks               : ${this.stats.entryPointChecks}\\n` +\n                    `  Unused symbol checks             : ${this.stats.unusedSymbolChecks}\\n` +\n                    `  Visibility checks                : ${this.stats.visibilityChecks}\\n` +\n                    `  Module integrity checks          : ${this.stats.moduleIntegrityChecks}\\n` +\n                    `  Errors                           : ${this.stats.errors}\\n` +\n                    `  Warnings                         : ${this.stats.warnings}`\n                );\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝"],"mappings":"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","names":["DiagCode","DiagKind","DeclarationPhase","ExpressionContext","AnalysisPhase","ScopeKind","SymbolKind","AST","module","module","exports","existingSymbol","AST","module","symbolName","existingSymbol","resolvedPath","targetModuleName","targetModuleScope","_a","AST","l","r","module","currentScope","initType","_a","_b","sizeExpr","memberType","normalizedTarget","normalizedSource","result","width1","width2","maxWidth","module"]}